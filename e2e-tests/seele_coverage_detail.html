
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com\seeleteam\go-seele\cmd\node\cmd\config.go (82.5%)</option>
				
				<option value="file1">github.com\seeleteam\go-seele\cmd\node\cmd\root.go (25.0%)</option>
				
				<option value="file2">github.com\seeleteam\go-seele\cmd\node\cmd\start.go (13.2%)</option>
				
				<option value="file3">github.com\seeleteam\go-seele\cmd\node\cmd\validate_key.go (33.3%)</option>
				
				<option value="file4">github.com\seeleteam\go-seele\common\Address.go (89.4%)</option>
				
				<option value="file5">github.com\seeleteam\go-seele\common\constant.go (57.1%)</option>
				
				<option value="file6">github.com\seeleteam\go-seele\common\converter.go (80.0%)</option>
				
				<option value="file7">github.com\seeleteam\go-seele\common\file.go (100.0%)</option>
				
				<option value="file8">github.com\seeleteam\go-seele\common\hash.go (80.8%)</option>
				
				<option value="file9">github.com\seeleteam\go-seele\common\hexutil\hexutil.go (89.5%)</option>
				
				<option value="file10">github.com\seeleteam\go-seele\common\keystore\keystore.go (65.0%)</option>
				
				<option value="file11">github.com\seeleteam\go-seele\common\keystore\passphrase.go (83.1%)</option>
				
				<option value="file12">github.com\seeleteam\go-seele\common\rlpwrapper.go (100.0%)</option>
				
				<option value="file13">github.com\seeleteam\go-seele\common\shard.go (100.0%)</option>
				
				<option value="file14">github.com\seeleteam\go-seele\common\simple_decimal.go (100.0%)</option>
				
				<option value="file15">github.com\seeleteam\go-seele\common\stdin.go (0.0%)</option>
				
				<option value="file16">github.com\seeleteam\go-seele\common\util.go (100.0%)</option>
				
				<option value="file17">github.com\seeleteam\go-seele\core\block_index.go (88.9%)</option>
				
				<option value="file18">github.com\seeleteam\go-seele\core\blockchain.go (72.0%)</option>
				
				<option value="file19">github.com\seeleteam\go-seele\core\blockchain_recover.go (72.2%)</option>
				
				<option value="file20">github.com\seeleteam\go-seele\core\evm.go (73.4%)</option>
				
				<option value="file21">github.com\seeleteam\go-seele\core\genesis.go (76.0%)</option>
				
				<option value="file22">github.com\seeleteam\go-seele\core\headerchain.go (80.0%)</option>
				
				<option value="file23">github.com\seeleteam\go-seele\core\state\journal.go (100.0%)</option>
				
				<option value="file24">github.com\seeleteam\go-seele\core\state\statedb.go (73.8%)</option>
				
				<option value="file25">github.com\seeleteam\go-seele\core\state\statedb_evm.go (80.6%)</option>
				
				<option value="file26">github.com\seeleteam\go-seele\core\state\stateobject.go (92.2%)</option>
				
				<option value="file27">github.com\seeleteam\go-seele\core\store\cached_store.go (82.4%)</option>
				
				<option value="file28">github.com\seeleteam\go-seele\core\store\db_store.go (82.2%)</option>
				
				<option value="file29">github.com\seeleteam\go-seele\core\store\mem_store.go (55.1%)</option>
				
				<option value="file30">github.com\seeleteam\go-seele\core\tx_collection.go (100.0%)</option>
				
				<option value="file31">github.com\seeleteam\go-seele\core\tx_pool.go (46.2%)</option>
				
				<option value="file32">github.com\seeleteam\go-seele\core\tx_pool_config.go (100.0%)</option>
				
				<option value="file33">github.com\seeleteam\go-seele\core\tx_pool_queue.go (90.3%)</option>
				
				<option value="file34">github.com\seeleteam\go-seele\core\types\block.go (100.0%)</option>
				
				<option value="file35">github.com\seeleteam\go-seele\core\types\receipt.go (100.0%)</option>
				
				<option value="file36">github.com\seeleteam\go-seele\core\types\transaction.go (73.9%)</option>
				
				<option value="file37">github.com\seeleteam\go-seele\crypto\crypto.go (88.1%)</option>
				
				<option value="file38">github.com\seeleteam\go-seele\crypto\ecies\asn1.go (58.2%)</option>
				
				<option value="file39">github.com\seeleteam\go-seele\crypto\ecies\ecies.go (75.6%)</option>
				
				<option value="file40">github.com\seeleteam\go-seele\crypto\ecies\params.go (42.6%)</option>
				
				<option value="file41">github.com\seeleteam\go-seele\crypto\secp256k1\curve.go (20.5%)</option>
				
				<option value="file42">github.com\seeleteam\go-seele\crypto\secp256k1\panic_cb.go (0.0%)</option>
				
				<option value="file43">github.com\seeleteam\go-seele\crypto\secp256k1\secp256.go (52.2%)</option>
				
				<option value="file44">github.com\seeleteam\go-seele\crypto\sha.go (100.0%)</option>
				
				<option value="file45">github.com\seeleteam\go-seele\crypto\sha3\hashes.go (100.0%)</option>
				
				<option value="file46">github.com\seeleteam\go-seele\crypto\sha3\register.go (100.0%)</option>
				
				<option value="file47">github.com\seeleteam\go-seele\crypto\sha3\sha3.go (95.2%)</option>
				
				<option value="file48">github.com\seeleteam\go-seele\crypto\sha3\shake.go (22.2%)</option>
				
				<option value="file49">github.com\seeleteam\go-seele\crypto\sha3\xor_generic.go (100.0%)</option>
				
				<option value="file50">github.com\seeleteam\go-seele\crypto\sha3\xor_unaligned.go (100.0%)</option>
				
				<option value="file51">github.com\seeleteam\go-seele\crypto\signature.go (81.5%)</option>
				
				<option value="file52">github.com\seeleteam\go-seele\database\leveldb\batch.go (100.0%)</option>
				
				<option value="file53">github.com\seeleteam\go-seele\database\leveldb\leveldb.go (62.5%)</option>
				
				<option value="file54">github.com\seeleteam\go-seele\database\leveldb\metrics.go (61.7%)</option>
				
				<option value="file55">github.com\seeleteam\go-seele\event\manager.go (97.4%)</option>
				
				<option value="file56">github.com\seeleteam\go-seele\log\caller.go (85.7%)</option>
				
				<option value="file57">github.com\seeleteam\go-seele\log\log.go (82.4%)</option>
				
				<option value="file58">github.com\seeleteam\go-seele\merkle\merkle_tree.go (93.0%)</option>
				
				<option value="file59">github.com\seeleteam\go-seele\metrics\metrics.go (71.4%)</option>
				
				<option value="file60">github.com\seeleteam\go-seele\metrics\runtimecpu.go (80.0%)</option>
				
				<option value="file61">github.com\seeleteam\go-seele\metrics\runtimedisk.go (10.7%)</option>
				
				<option value="file62">github.com\seeleteam\go-seele\metrics\runtimemetrics.go (77.3%)</option>
				
				<option value="file63">github.com\seeleteam\go-seele\miner\core.go (73.0%)</option>
				
				<option value="file64">github.com\seeleteam\go-seele\miner\miner.go (0.0%)</option>
				
				<option value="file65">github.com\seeleteam\go-seele\miner\pow\engine.go (96.8%)</option>
				
				<option value="file66">github.com\seeleteam\go-seele\miner\pow\reward.go (100.0%)</option>
				
				<option value="file67">github.com\seeleteam\go-seele\miner\task.go (2.6%)</option>
				
				<option value="file68">github.com\seeleteam\go-seele\monitor\api.go (83.3%)</option>
				
				<option value="file69">github.com\seeleteam\go-seele\monitor\monitorservice.go (85.7%)</option>
				
				<option value="file70">github.com\seeleteam\go-seele\node\node.go (66.7%)</option>
				
				<option value="file71">github.com\seeleteam\go-seele\node\node_rpc.go (28.0%)</option>
				
				<option value="file72">github.com\seeleteam\go-seele\p2p\conn.go (0.0%)</option>
				
				<option value="file73">github.com\seeleteam\go-seele\p2p\discovery\bucket.go (55.8%)</option>
				
				<option value="file74">github.com\seeleteam\go-seele\p2p\discovery\database.go (35.2%)</option>
				
				<option value="file75">github.com\seeleteam\go-seele\p2p\discovery\distance.go (100.0%)</option>
				
				<option value="file76">github.com\seeleteam\go-seele\p2p\discovery\message.go (0.0%)</option>
				
				<option value="file77">github.com\seeleteam\go-seele\p2p\discovery\net.go (0.0%)</option>
				
				<option value="file78">github.com\seeleteam\go-seele\p2p\discovery\node.go (67.4%)</option>
				
				<option value="file79">github.com\seeleteam\go-seele\p2p\discovery\server.go (0.0%)</option>
				
				<option value="file80">github.com\seeleteam\go-seele\p2p\discovery\table.go (20.8%)</option>
				
				<option value="file81">github.com\seeleteam\go-seele\p2p\discovery\udp.go (8.5%)</option>
				
				<option value="file82">github.com\seeleteam\go-seele\p2p\message.go (0.0%)</option>
				
				<option value="file83">github.com\seeleteam\go-seele\p2p\peer.go (13.7%)</option>
				
				<option value="file84">github.com\seeleteam\go-seele\p2p\peer_set.go (81.8%)</option>
				
				<option value="file85">github.com\seeleteam\go-seele\p2p\protocol.go (0.0%)</option>
				
				<option value="file86">github.com\seeleteam\go-seele\p2p\qvic\fechelper.go (97.0%)</option>
				
				<option value="file87">github.com\seeleteam\go-seele\p2p\qvic\qconn.go (0.0%)</option>
				
				<option value="file88">github.com\seeleteam\go-seele\p2p\qvic\qvicmgr.go (69.4%)</option>
				
				<option value="file89">github.com\seeleteam\go-seele\p2p\qvic\speedmeter.go (93.5%)</option>
				
				<option value="file90">github.com\seeleteam\go-seele\p2p\qvic\tokenbucket.go (82.6%)</option>
				
				<option value="file91">github.com\seeleteam\go-seele\p2p\qvic\vbitvec.go (82.1%)</option>
				
				<option value="file92">github.com\seeleteam\go-seele\p2p\qvic\vpacket.go (77.8%)</option>
				
				<option value="file93">github.com\seeleteam\go-seele\p2p\server.go (0.0%)</option>
				
				<option value="file94">github.com\seeleteam\go-seele\rpc2\client.go (87.1%)</option>
				
				<option value="file95">github.com\seeleteam\go-seele\rpc2\errors.go (33.3%)</option>
				
				<option value="file96">github.com\seeleteam\go-seele\rpc2\http.go (43.9%)</option>
				
				<option value="file97">github.com\seeleteam\go-seele\rpc2\inproc.go (100.0%)</option>
				
				<option value="file98">github.com\seeleteam\go-seele\rpc2\ipc.go (87.5%)</option>
				
				<option value="file99">github.com\seeleteam\go-seele\rpc2\ipc_windows.go (85.7%)</option>
				
				<option value="file100">github.com\seeleteam\go-seele\rpc2\json.go (71.8%)</option>
				
				<option value="file101">github.com\seeleteam\go-seele\rpc2\server.go (75.0%)</option>
				
				<option value="file102">github.com\seeleteam\go-seele\rpc2\subscription.go (96.9%)</option>
				
				<option value="file103">github.com\seeleteam\go-seele\rpc2\types.go (94.4%)</option>
				
				<option value="file104">github.com\seeleteam\go-seele\rpc2\utils.go (90.0%)</option>
				
				<option value="file105">github.com\seeleteam\go-seele\rpc2\websocket.go (64.9%)</option>
				
				<option value="file106">github.com\seeleteam\go-seele\rpc\batch.go (0.0%)</option>
				
				<option value="file107">github.com\seeleteam\go-seele\rpc\client.go (0.0%)</option>
				
				<option value="file108">github.com\seeleteam\go-seele\rpc\errors.go (18.8%)</option>
				
				<option value="file109">github.com\seeleteam\go-seele\rpc\httpserver.go (78.8%)</option>
				
				<option value="file110">github.com\seeleteam\go-seele\rpc\json.go (72.4%)</option>
				
				<option value="file111">github.com\seeleteam\go-seele\rpc\server.go (100.0%)</option>
				
				<option value="file112">github.com\seeleteam\go-seele\rpc\websocket.go (10.0%)</option>
				
				<option value="file113">github.com\seeleteam\go-seele\seele\api_debug.go (0.0%)</option>
				
				<option value="file114">github.com\seeleteam\go-seele\seele\api_miner.go (0.0%)</option>
				
				<option value="file115">github.com\seeleteam\go-seele\seele\api_network.go (0.0%)</option>
				
				<option value="file116">github.com\seeleteam\go-seele\seele\api_public.go (49.1%)</option>
				
				<option value="file117">github.com\seeleteam\go-seele\seele\api_txpool.go (0.0%)</option>
				
				<option value="file118">github.com\seeleteam\go-seele\seele\download\api.go (0.0%)</option>
				
				<option value="file119">github.com\seeleteam\go-seele\seele\download\downloader.go (4.3%)</option>
				
				<option value="file120">github.com\seeleteam\go-seele\seele\download\peer.go (2.4%)</option>
				
				<option value="file121">github.com\seeleteam\go-seele\seele\download\taskMgr.go (0.0%)</option>
				
				<option value="file122">github.com\seeleteam\go-seele\seele\peer.go (18.8%)</option>
				
				<option value="file123">github.com\seeleteam\go-seele\seele\peer_set.go (55.1%)</option>
				
				<option value="file124">github.com\seeleteam\go-seele\seele\seeleprotocol.go (2.2%)</option>
				
				<option value="file125">github.com\seeleteam\go-seele\seele\seeleservice.go (43.3%)</option>
				
				<option value="file126">github.com\seeleteam\go-seele\trie\node.go (50.0%)</option>
				
				<option value="file127">github.com\seeleteam\go-seele\trie\trie.go (84.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package cmd

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "math/big"
        "path/filepath"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core"
        "github.com/seeleteam/go-seele/crypto"
        "github.com/seeleteam/go-seele/log/comm"
        "github.com/seeleteam/go-seele/metrics"
        "github.com/seeleteam/go-seele/node"
        "github.com/seeleteam/go-seele/p2p"
)

// Config is the Configuration of node
type Config struct {
        //Config is the Configuration of log
        LogConfig comm.LogConfig `json:"log"`

        // basic config for Node
        BasicConfig node.BasicConfig `json:"basic"`

        // The configuration of p2p network
        P2PConfig p2p.Config `json:"p2p"`

        // HttpServer config for http server
        HTTPServer node.HTTPServer `json:"httpServer"`

        // The configuration of websocket rpc service
        WSServerConfig node.WSServerConfig `json:"wsserver"`

        // metrics config info
        MetricsConfig *metrics.Config `json:"metrics"`

        // genesis config info
        GenesisConfig core.GenesisInfo `json:"genesis"`
}

// GetConfigFromFile unmarshals the config from the given file
func GetConfigFromFile(filepath string) (*Config, error) <span class="cov8" title="1">{
        var config Config
        buff, err := ioutil.ReadFile(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;config, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(buff, &amp;config)
        return &amp;config, err</span>
}

// LoadConfigFromFile gets node config from the given file
func LoadConfigFromFile(configFile string, accounts string) (*node.Config, error) <span class="cov8" title="1">{
        cmdConfig, err := GetConfigFromFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cmdConfig.GenesisConfig.Accounts, err = LoadAccountConfig(accounts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">config := CopyConfig(cmdConfig)
        config.P2PConfig, err = GetP2pConfig(cmdConfig)
        if err != nil </span><span class="cov0" title="0">{
                return config, err
        }</span>

        <span class="cov8" title="1">config.SeeleConfig.Coinbase = common.HexMustToAddres(config.BasicConfig.Coinbase)
        config.SeeleConfig.TxConf = *core.DefaultTxPoolConfig()
        config.SeeleConfig.GenesisConfig = cmdConfig.GenesisConfig
        common.LogConfig.PrintLog = config.LogConfig.PrintLog
        common.LogConfig.IsDebug = config.LogConfig.IsDebug
        common.LogFileName = fmt.Sprintf("%s.%s", config.BasicConfig.DataDir, common.LogFileName)
        config.BasicConfig.DataDir = filepath.Join(common.GetDefaultDataFolder(), config.BasicConfig.DataDir)
        return config, nil</span>
}

// CopyConfig copy Config from the given config
func CopyConfig(cmdConfig *Config) *node.Config <span class="cov8" title="1">{
        config := &amp;node.Config{
                BasicConfig:    cmdConfig.BasicConfig,
                LogConfig:      cmdConfig.LogConfig,
                HTTPServer:     cmdConfig.HTTPServer,
                WSServerConfig: cmdConfig.WSServerConfig,
                P2PConfig:      cmdConfig.P2PConfig,
                SeeleConfig:    node.SeeleConfig{},
                MetricsConfig:  cmdConfig.MetricsConfig,
        }
        return config
}</span>

// GetP2pConfig get P2PConfig from the given config
func GetP2pConfig(cmdConfig *Config) (p2p.Config, error) <span class="cov8" title="1">{
        if cmdConfig.P2PConfig.PrivateKey == nil </span><span class="cov8" title="1">{
                key, err := crypto.LoadECDSAFromString(cmdConfig.P2PConfig.SubPrivateKey) // GetP2pConfigPrivateKey get privateKey from the given config
                if err != nil </span><span class="cov0" title="0">{
                        return cmdConfig.P2PConfig, err
                }</span>
                <span class="cov8" title="1">cmdConfig.P2PConfig.PrivateKey = key</span>
        }
        <span class="cov8" title="1">return cmdConfig.P2PConfig, nil</span>
}

func LoadAccountConfig(account string) (map[common.Address]*big.Int, error) <span class="cov8" title="1">{
        result := make(map[common.Address]*big.Int)
        if account == "" </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov8" title="1">buff, err := ioutil.ReadFile(account)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(buff, &amp;result)
        return result, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package cmd

import (
        "fmt"
        "os"

        "github.com/seeleteam/go-seele/cmd/util"
        "github.com/spf13/cobra"
)

// rootCmd represents the base command called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "node",
        Short: "node command for starting a node",
        Long:  `use "node help [&lt;command&gt;]" for detailed usage`,
        // Uncomment the following line if your bare application
        // has an action associated with it:
        //        Run: func(cmd *cobra.Command, args []string) { },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(util.GetGenerateKeyPairCmd("node"))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package cmd

import (
        "context"
        "fmt"
        "path/filepath"
        "strings"
        "sync"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/metrics"
        miner2 "github.com/seeleteam/go-seele/miner"
        "github.com/seeleteam/go-seele/monitor"
        "github.com/seeleteam/go-seele/node"
        "github.com/seeleteam/go-seele/seele"
        "github.com/spf13/cobra"
)

var seeleNodeConfigFile string
var miner string
var metricsEnableFlag bool
var accountsConfig string
var threads int

// startCmd represents the start command
var startCmd = &amp;cobra.Command{
        Use:   "start",
        Short: "start the node of seele",
        Long: `usage example:
                node.exe start -c cmd\node.json
                start a node.`,

        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                var wg sync.WaitGroup
                nCfg, err := LoadConfigFromFile(seeleNodeConfigFile, accountsConfig)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("reading the config file failed: %s\n", err.Error())
                        return
                }</span>

                // print some config infos
                <span class="cov0" title="0">fmt.Printf("log file: %s\n", filepath.Join(log.LogFolder, common.LogFileName))
                fmt.Printf("data folder: %s\n", nCfg.BasicConfig.DataDir)

                seeleNode, err := node.New(nCfg)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err.Error())
                        return
                }</span>

                // Create seele service and register the service
                <span class="cov0" title="0">slog := log.GetLogger("seele", common.LogConfig.PrintLog)
                serviceContext := seele.ServiceContext{
                        DataDir: nCfg.BasicConfig.DataDir,
                }
                ctx := context.WithValue(context.Background(), "ServiceContext", serviceContext)
                seeleService, err := seele.NewSeeleService(ctx, nCfg, slog)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err.Error())
                        return
                }</span>

                <span class="cov0" title="0">seeleService.Miner().SetThreads(threads)

                // monitor service
                monitorService, err := monitor.NewMonitorService(seeleService, seeleNode, nCfg, slog, "Test monitor")
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err.Error())
                        return
                }</span>

                <span class="cov0" title="0">services := []node.Service{seeleService, monitorService}
                for _, service := range services </span><span class="cov0" title="0">{
                        if err := seeleNode.Register(service); err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                                return
                        }</span>
                }

                <span class="cov0" title="0">err = seeleNode.Start()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("got error when start node: %s\n", err)
                        return
                }</span>

                <span class="cov0" title="0">minerInfo := strings.ToLower(miner)
                if minerInfo == "start" </span><span class="cov0" title="0">{
                        err = seeleService.Miner().Start()
                        if err != nil &amp;&amp; err != miner2.ErrMinerIsRunning </span><span class="cov0" title="0">{
                                fmt.Println("Starting the miner failed: ", err)
                                return
                        }</span>
                }<span class="cov0" title="0"> else if minerInfo == "stop" </span><span class="cov0" title="0">{
                        seeleService.Miner().Stop()
                }</span><span class="cov0" title="0"> else {
                        fmt.Println("invalid miner command, must be start or stop")
                        return
                }</span>

                <span class="cov0" title="0">if metricsEnableFlag </span><span class="cov0" title="0">{
                        metrics.StartMetricsWithConfig(
                                nCfg.MetricsConfig,
                                slog,
                                nCfg.BasicConfig.Name,
                                nCfg.BasicConfig.Version,
                                nCfg.P2PConfig.NetworkID,
                                nCfg.SeeleConfig.Coinbase,
                        )
                }</span>

                <span class="cov0" title="0">wg.Add(1)
                wg.Wait()</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(startCmd)

        startCmd.Flags().StringVarP(&amp;seeleNodeConfigFile, "config", "c", "", "seele node config file (required)")
        startCmd.MarkFlagRequired("config")

        startCmd.Flags().StringVarP(&amp;miner, "miner", "m", "start", "miner start or not, [start, stop]")
        startCmd.Flags().BoolVarP(&amp;metricsEnableFlag, "metrics", "t", false, "start metrics")
        startCmd.Flags().StringVarP(&amp;accountsConfig, "accounts", "", "", "init accounts info")
        startCmd.Flags().IntVarP(&amp;threads, "threads", "", 1, "miner thread value")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package cmd

import (
        "fmt"

        "github.com/seeleteam/go-seele/crypto"
        "github.com/spf13/cobra"
)

var (
        privateKey *string
)

// validatekeyCmd represents the validatekey command
var validatekeyCmd = &amp;cobra.Command{
        Use:   "validatekey",
        Short: "validate the private key and generate its public key",
        Long: `For example:
                        node.exe validatekey`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                key, err := crypto.LoadECDSAFromString(*privateKey)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("loading the private key failed: %s\n", err.Error())
                        return
                }</span>

                <span class="cov0" title="0">addr := crypto.GetAddress(&amp;key.PublicKey)

                fmt.Printf("public key: %s\n", addr.ToHex())</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(validatekeyCmd)

        privateKey = validatekeyCmd.Flags().StringP("key", "k", "", "private key")
        validatekeyCmd.MarkFlagRequired("key")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

import (
        "bytes"
        "crypto/ecdsa"
        "crypto/elliptic"
        "encoding/binary"
        "fmt"
        "math/big"

        "github.com/seeleteam/go-seele/common/hexutil"
)

//////////////////////////////////////////////////////////////////////////////
// Address format:
// - External account: pubKeyHash[12:32] and set last 4 bits to addressTypeExternal(1)
// - Contract account: AddrNonceHash[14:32] and set last 4 bits to addressTypeContract(2), the left 12 bits for shard (max shard is 4096).
//////////////////////////////////////////////////////////////////////////////

// AddressType represents the address type
type AddressType byte

const (
        addressLen = 20 // length in bytes

        // AddressTypeExternal is the address type for external account.
        AddressTypeExternal = AddressType(1)
        // AddressTypeContract is the address type for contract account.
        AddressTypeContract = AddressType(2)
)

// EmptyAddress presents an empty address
var EmptyAddress = Address{}

// Address we use public key as node id
type Address [addressLen]byte

// NewAddress converts a byte slice to a Address
func NewAddress(b []byte) (Address, error) <span class="cov8" title="1">{
        // Validate length
        if len(b) != addressLen </span><span class="cov0" title="0">{
                return EmptyAddress, fmt.Errorf("invalid address length %v, expected length is %v", len(b), addressLen)
        }</span>

        <span class="cov8" title="1">var id Address
        copy(id[:], b)

        return id, nil</span>
}

// PubKeyToAddress converts a ECC public key to an external address.
func PubKeyToAddress(pubKey *ecdsa.PublicKey, hashFunc func(interface{}) Hash) Address <span class="cov8" title="1">{
        buf := elliptic.Marshal(pubKey.Curve, pubKey.X, pubKey.Y)
        hash := hashFunc(buf[1:]).Bytes()

        var addr Address
        copy(addr[:], hash[12:]) // use last 20 bytes of public key hash

        // set address type in the last 4 bits
        addr[19] &amp;= 0xF0
        addr[19] |= byte(AddressTypeExternal)

        return addr
}</span>

// Type returns the address type
func (id *Address) Type() AddressType <span class="cov8" title="1">{
        return AddressType(id[addressLen-1] &amp; 0x0F)
}</span>

// Bytes get the actual bytes
//
// Note: if we want to use pointer type, need to change the code snippet in unit test:
//   BytesToAddress([]byte{1, 2}).Bytes()
//   -&gt;
//   addrBytes := BytesToAddress([]byte{1, 2})
//   (&amp;addrBytes).Bytes()
//
// refer link: https://stackoverflow.com/questions/10535743/address-of-a-temporary-in-go
func (id Address) Bytes() []byte <span class="cov8" title="1">{
        return id[:]
}</span>

// ToHex converts address to 0x prefixed HEX format.
func (id *Address) ToHex() string <span class="cov8" title="1">{
        return hexutil.BytesToHex(id.Bytes())
}</span>

// Equal checks if this address is the same with the specified address b.
func (id *Address) Equal(b Address) bool <span class="cov8" title="1">{
        return bytes.Equal(id[:], b[:])
}</span>

// IsEmpty returns true if this address is empty. Otherwise, false.
func (id *Address) IsEmpty() bool <span class="cov8" title="1">{
        return id.Equal(EmptyAddress)
}</span>

// HexToAddress converts the specified HEX string to address.
func HexToAddress(id string) (Address, error) <span class="cov8" title="1">{
        byte, err := hexutil.HexToBytes(id)
        if err != nil </span><span class="cov0" title="0">{
                return Address{}, err
        }</span>

        <span class="cov8" title="1">nid, err := NewAddress(byte)
        if err != nil </span><span class="cov0" title="0">{
                return Address{}, err
        }</span>

        <span class="cov8" title="1">return nid, nil</span>
}

// HexMustToAddres converts the specified HEX string to address.
// Panics on any error.
func HexMustToAddres(id string) Address <span class="cov8" title="1">{
        a, err := HexToAddress(id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return a</span>
}

// BytesToAddress converts the specified byte array to Address.
func BytesToAddress(bs []byte) Address <span class="cov8" title="1">{
        var addr Address

        if len(bs) &gt; len(addr) </span><span class="cov8" title="1">{
                bs = bs[len(bs)-len(addr):]
        }</span>

        <span class="cov8" title="1">copy(addr[len(addr)-len(bs):], bs)

        return addr</span>
}

// BigToAddress converts a big int to address.
func BigToAddress(b *big.Int) Address <span class="cov0" title="0">{ return BytesToAddress(b.Bytes()) }</span>

// Big converts address to a big int.
func (id *Address) Big() *big.Int <span class="cov8" title="1">{ return new(big.Int).SetBytes(id[:]) }</span>

// MarshalText marshals the address to HEX string.
func (id Address) MarshalText() ([]byte, error) <span class="cov8" title="1">{
        str := id.ToHex()
        return []byte(str), nil
}</span>

// UnmarshalText unmarshals address from HEX string.
func (id *Address) UnmarshalText(json []byte) error <span class="cov8" title="1">{
        a, err := HexToAddress(string(json))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">copy(id[:], a[:])
        return nil</span>
}

// Shard returns the shard number of this address.
func (id *Address) Shard() uint <span class="cov8" title="1">{
        var sum uint

        // sum [0:18]
        for _, b := range id[:18] </span><span class="cov8" title="1">{
                sum += uint(b)
        }</span>

        // sum [18:20] except address type
        <span class="cov8" title="1">tail := uint(binary.BigEndian.Uint16(id[18:]))
        sum += (tail &gt;&gt; 4)

        return (sum % ShardCount) + 1</span>
}

// CreateContractAddress returns a contract address that in the same shard of this address.
func (id *Address) CreateContractAddress(nonce uint64, hashFunc func(interface{}) Hash) Address <span class="cov8" title="1">{
        hash := hashFunc([]interface{}{id, nonce}).Bytes()

        targetShardNum := id.Shard()
        var sum uint

        // sum [14:] of public key hash
        for _, b := range hash[14:] </span><span class="cov8" title="1">{
                sum += uint(b)
        }</span>

        // sum [18:20] for shard mod and contract address type
        <span class="cov8" title="1">shardNum := (sum % ShardCount) + 1
        encoded := make([]byte, 2)
        var mod uint
        if shardNum &lt;= targetShardNum </span><span class="cov8" title="1">{
                mod = targetShardNum - shardNum
        }</span><span class="cov0" title="0"> else {
                mod = ShardCount + targetShardNum - shardNum
        }</span>
        <span class="cov8" title="1">mod &lt;&lt;= 4
        mod |= uint(AddressTypeContract) // set address type in the last 4 bits
        binary.BigEndian.PutUint16(encoded, uint16(mod))

        var contractAddr Address
        copy(contractAddr[:18], hash[14:]) // use last 18 bytes of hash (from address + nonce)
        copy(contractAddr[18:], encoded)   // last 2 bytes for shard mod and address type

        return contractAddr</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

import (
        "os"
        "os/user"
        "path/filepath"
        "time"

        "github.com/seeleteam/go-seele/log/comm"
)

const (
        // ShardCount represents the total number of shards.
        ShardCount = 20

        // PrintExplosionLog whether print explosion log flag. Most of them are transaction track logs
        PrintExplosionLog = false

        // MetricsRefreshTime is the time of metrics sleep 1 minute
        MetricsRefreshTime = time.Minute

        // CPUMetricsRefreshTime is the time of metrics monitor cpu
        CPUMetricsRefreshTime = time.Second
)

var (
        // tempFolder used to store temp file, such as log files
        tempFolder string

        // defaultDataFolder used to store persistent data info, such as the database and keystore
        defaultDataFolder string

        // LogConfig is the Configuration of log
        LogConfig = &amp;comm.LogConfig{PrintLog: true, IsDebug: true}

        // LogFileName default log file name
        LogFileName = "log.txt"
)

func init() <span class="cov8" title="1">{
        tempFolder = filepath.Join(os.TempDir(), "seeleTemp")

        usr, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">defaultDataFolder = filepath.Join(usr.HomeDir, ".seele")</span>
}

// GetTempFolder uses a getter to implement readonly
func GetTempFolder() string <span class="cov0" title="0">{
        return tempFolder
}</span>

// GetDefaultDataFolder gets the default data Folder
func GetDefaultDataFolder() string <span class="cov0" title="0">{
        return defaultDataFolder
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

import (
        "bytes"
        "encoding/binary"
        "log"
)

// ConvertInt64ToBytes converts a int64 value into a byte array
func ConvertInt64ToBytes(num int64) []byte <span class="cov8" title="1">{
        buff := new(bytes.Buffer)
        err := binary.Write(buff, binary.BigEndian, num)
        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>

        <span class="cov8" title="1">return buff.Bytes()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

import (
        "os"
)

// FileOrFolderExists checks if a file or folder exists
func FileOrFolderExists(fileOrFolder string) bool <span class="cov8" title="1">{
        _, err := os.Stat(fileOrFolder)
        return !os.IsNotExist(err)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

import (
        "bytes"
        "math/big"

        "github.com/seeleteam/go-seele/common/hexutil"
)

const (
        // HashLength the leghth of hash
        HashLength = 32
)

// EmptyHash empty hash
var EmptyHash = Hash{}

// Hash the hash value generated by sha-3
type Hash [HashLength]byte

// BytesToHash converts bytes to hash value
func BytesToHash(b []byte) Hash <span class="cov8" title="1">{
        a := &amp;Hash{}
        a.SetBytes(b)
        return *a
}</span>

// StringToHash converts a string to the hash
func StringToHash(s string) Hash <span class="cov8" title="1">{
        return BytesToHash([]byte(s))
}</span>

// SetBytes sets the hash to the value of b.
func (a *Hash) SetBytes(b []byte) <span class="cov8" title="1">{
        if len(b) &gt; HashLength </span><span class="cov0" title="0">{
                b = b[len(b)-HashLength:]
        }</span>

        <span class="cov8" title="1">copy(a[HashLength-len(b):], b)</span>
}

// Bytes returns its actual bits
func (a Hash) Bytes() []byte <span class="cov8" title="1">{
        return a[:]
}</span>

// String returns the string representation of the hash
func (a *Hash) String() string <span class="cov8" title="1">{
        return string(a[:])
}</span>

// Equal returns a boolean value indicating whether the hash a is equal to the input hash b.
func (a *Hash) Equal(b Hash) bool <span class="cov8" title="1">{
        return bytes.Equal(a[:], b[:])
}</span>

// ToHex returns the hex form of the hash
func (a Hash) ToHex() string <span class="cov8" title="1">{
        return hexutil.BytesToHex(a[:])
}</span>

// HexToHash return the hash form of the hex
func HexToHash(hex string) (Hash, error) <span class="cov8" title="1">{
        byte, err := hexutil.HexToBytes(hex)
        if err != nil </span><span class="cov0" title="0">{
                return EmptyHash, err
        }</span>

        <span class="cov8" title="1">hash := BytesToHash(byte)
        return hash, nil</span>
}

// IsEmpty return true if this hash is empty. Otherwise, false.
func (a Hash) IsEmpty() bool <span class="cov8" title="1">{
        return a == EmptyHash
}</span>

// BigToHash converts a big int to Hash.
func BigToHash(b *big.Int) Hash <span class="cov0" title="0">{ return BytesToHash(b.Bytes()) }</span>

// Big converts this Hash to a big int.
func (a Hash) Big() *big.Int <span class="cov0" title="0">{ return new(big.Int).SetBytes(a[:]) }</span>

// MarshalText marshals the Hash to HEX string.
func (a Hash) MarshalText() ([]byte, error) <span class="cov8" title="1">{
        str := a.ToHex()
        return []byte(str), nil
}</span>

// UnmarshalText unmarshals Hash from HEX string.
func (a *Hash) UnmarshalText(json []byte) error <span class="cov8" title="1">{
        b, err := HexToHash(string(json))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">copy(a[:], b[:])
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package hexutil

import (
        "encoding/hex"
)

var (
        // ErrEmptyString empty hex string
        ErrEmptyString = &amp;decError{"empty hex string"}
        // ErrSyntax invalid hex string
        ErrSyntax = &amp;decError{"invalid hex string"}
        // ErrMissingPrefix hex string without 0x prefix
        ErrMissingPrefix = &amp;decError{"hex string without 0x prefix"}
        // ErrOddLength hex string of odd length
        ErrOddLength = &amp;decError{"hex string of odd length"}
)

type decError struct{ msg string }

func (err *decError) Error() string <span class="cov0" title="0">{ return err.msg }</span>

// BytesToHex encodes b as a hex string with 0x prefix.
func BytesToHex(b []byte) string <span class="cov8" title="1">{
        enc := make([]byte, len(b)*2+2)
        copy(enc, "0x")
        hex.Encode(enc[2:], b)
        return string(enc)
}</span>

// HexToBytes decodes a hex string with 0x prefix.
func HexToBytes(input string) ([]byte, error) <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return nil, ErrEmptyString
        }</span>
        <span class="cov8" title="1">if !Has0xPrefix(input) </span><span class="cov8" title="1">{
                return nil, ErrMissingPrefix
        }</span>
        <span class="cov8" title="1">b, err := hex.DecodeString(input[2:])
        if err != nil </span><span class="cov8" title="1">{
                err = mapError(err)
        }</span>
        <span class="cov8" title="1">return b, err</span>
}

// Has0xPrefix returns true if input starts with 0x, otherwise false
func Has0xPrefix(input string) bool <span class="cov8" title="1">{
        return len(input) &gt;= 2 &amp;&amp; input[0] == '0' &amp;&amp; (input[1] == 'x' || input[1] == 'X')
}</span>

// mapError maps err to a more specific error
func mapError(err error) error <span class="cov8" title="1">{
        if _, ok := err.(hex.InvalidByteError); ok </span><span class="cov8" title="1">{
                return ErrSyntax
        }</span>
        <span class="cov8" title="1">if err == hex.ErrLength </span><span class="cov8" title="1">{
                return ErrOddLength
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package keystore

import (
        "io/ioutil"
        "os"
        "path/filepath"
)

// GetKey get private key from a file
func GetKey(fileName, password string) (*Key, error) <span class="cov8" title="1">{
        content, err := ioutil.ReadFile(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return DecryptKey(content, password)</span>
}

// StoreKey store private key in a file. Note it is not encrypted. Need to support it later.
func StoreKey(fileName, password string, key *Key) error <span class="cov8" title="1">{
        content, err := EncryptKey(key, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return writeKeyFile(fileName, content)</span>
}

func writeKeyFile(file string, content []byte) error <span class="cov8" title="1">{
        // Create the keystore directory with appropriate permissions
        // in case it is not present yet.
        const dirPerm = 0700
        if err := os.MkdirAll(filepath.Dir(file), dirPerm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Atomic write: create a temporary hidden file first then move it into place.
        <span class="cov8" title="1">f, err := ioutil.TempFile(filepath.Dir(file), "."+filepath.Base(file)+".tmp")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := f.Write(content); err != nil </span><span class="cov0" title="0">{
                f.Close()
                os.Remove(f.Name())
                return err
        }</span>
        <span class="cov8" title="1">f.Close()
        return os.Rename(f.Name(), file)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package keystore

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"

        "github.com/ethereum/go-ethereum/common/math"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
        "golang.org/x/crypto/scrypt"
)

// Scrypt common parameter
const (
        ScryptN     = 1 &lt;&lt; 18
        ScryptP     = 1
        scryptR     = 8
        scryptDKLen = 32
)

var (
        // ErrDecrypt error when the passphrase is not right
        ErrDecrypt = errors.New("could not decrypt key with given passphrase")

        // ErrEmptyAuthKey error when the auth key is empty
        ErrEmptyAuthKey = errors.New("encryption auth key could not be empty")
)

// EncryptKey encrypts a key using the specified scrypt parameters into a json
// passphrase -&gt; script function -&gt; decryption key
// decryption key + private key -&gt;  aes-128-ctr algorithm -&gt; encrypted private key
func EncryptKey(key *Key, auth string) ([]byte, error) <span class="cov8" title="1">{
        salt := getRandBuff(32)
        scryptKey, err := getScryptKey(salt, auth)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">encryptKey := scryptKey[:16]
        keyBytes := math.PaddedBigBytes(key.PrivateKey.D, 32)

        iv := getRandBuff(aes.BlockSize) // 16
        cipherText, err := aesCTRXOR(encryptKey, keyBytes, iv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">mac := crypto.HashBytes(scryptKey[16:32], cipherText)
        info := cryptoInfo{
                CipherText: hex.EncodeToString(cipherText),
                CipherIV:   hex.EncodeToString(iv),
                Salt:       hex.EncodeToString(salt),
                MAC:        mac.ToHex(),
        }

        encryptedKey := encryptedKey{
                Version: Version,
                Address: key.Address.ToHex(),
                Crypto:  info,
        }

        return json.MarshalIndent(encryptedKey, "", "\t")</span>
}

// DecryptKey decrypts a key from a json blob, returning the private key itself.
func DecryptKey(keyjson []byte, auth string) (*Key, error) <span class="cov8" title="1">{
        k := new(encryptedKey)
        if err := json.Unmarshal(keyjson, k); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">keyBytes, err := doDecrypt(k, auth)
        // Handle any decryption errors and return the key
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">key, err := crypto.ToECDSA(keyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">addr := crypto.GetAddress(&amp;key.PublicKey)

        return &amp;Key{
                Address:    *addr,
                PrivateKey: key,
        }, nil</span>
}

func doDecrypt(keyProtected *encryptedKey, auth string) ([]byte, error) <span class="cov8" title="1">{
        if keyProtected.Version != Version </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Version not supported: %v", keyProtected.Version)
        }</span>

        <span class="cov8" title="1">mac, err := common.HexToHash(keyProtected.Crypto.MAC)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">iv, err := hex.DecodeString(keyProtected.Crypto.CipherIV)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cipherText, err := hex.DecodeString(keyProtected.Crypto.CipherText)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">salt, err := hex.DecodeString(keyProtected.Crypto.Salt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">scyptKey, err := getScryptKey(salt, auth)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">calculatedMAC := crypto.HashBytes(scyptKey[16:32], cipherText)
        if !calculatedMAC.Equal(mac) </span><span class="cov8" title="1">{
                return nil, ErrDecrypt
        }</span>

        <span class="cov8" title="1">plainText, err := aesCTRXOR(scyptKey[:16], cipherText, iv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return plainText, err</span>
}

// use scrypt to calculate auth key
func getScryptKey(salt []byte, auth string) ([]byte, error) <span class="cov8" title="1">{
        if len(auth) &lt; 1 </span><span class="cov8" title="1">{
                return nil, ErrEmptyAuthKey
        }</span>

        <span class="cov8" title="1">authArray := []byte(auth)
        return scrypt.Key(authArray, salt, ScryptN, scryptR, ScryptP, scryptDKLen)</span>
}

// AES-128 is selected due to size of encryptKey.
// when inText is plain text, the return value is cipher text
// when inText is cipher text, the return value is plain text
func aesCTRXOR(key, inText, iv []byte) ([]byte, error) <span class="cov8" title="1">{
        aesBlock, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">stream := cipher.NewCTR(aesBlock, iv)
        outText := make([]byte, len(inText))
        stream.XORKeyStream(outText, inText)
        return outText, err</span>
}

func getRandBuff(n int) []byte <span class="cov8" title="1">{
        mainBuff := make([]byte, n)
        _, err := io.ReadFull(rand.Reader, mainBuff)
        if err != nil </span><span class="cov0" title="0">{
                panic("reading from crypto/rand failed: " + err.Error())</span>
        }

        <span class="cov8" title="1">return mainBuff</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

import (
        "github.com/ethereum/go-ethereum/rlp"
)

// rlp is an effective serialize and deserialize function with no schema
// we use it as our network byte array converter

// Deserialize wrapper decode
func Deserialize(data []byte, value interface{}) error <span class="cov8" title="1">{
        return rlp.DecodeBytes(data, value)
}</span>

// Serialize wrapper encode
func Serialize(in interface{}) ([]byte, error) <span class="cov8" title="1">{
        return rlp.EncodeToBytes(in)
}</span>

// SerializePanic serialize the input data to byte array.
// Panics on error, e.g. unsupported data type for RLP encoding.
func SerializePanic(in interface{}) []byte <span class="cov8" title="1">{
        bytes, err := Serialize(in)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return bytes</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

// UndefinedShardNumber is the default value if shard number not specified.
const UndefinedShardNumber = uint(0)

// LocalShardNumber defines the shard number of coinbase.
// Generally, it must be initialized during program startup.
var LocalShardNumber uint

// IsShardEnabled returns true if the LocalShardNumber is set. Otherwise, false.
func IsShardEnabled() bool <span class="cov8" title="1">{
        return LocalShardNumber &gt; UndefinedShardNumber &amp;&amp; LocalShardNumber &lt;= ShardCount
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

import (
        "fmt"
        "math/big"
        "strings"
)

var (
        //SeeleToFan base feifan coin number
        SeeleToFan = big.NewInt(100000000)
)

//BigToDecimal simply changes big int to decimal which will miss additional 0 in the last
func BigToDecimal(amount *big.Int) string <span class="cov8" title="1">{
        base := SeeleToFan
        var quotient = big.NewInt(0)
        var mod = big.NewInt(0)
        var numstr string

        quotient.Div(amount, base)
        mod.Mod(amount, base)
        modValue := mod.Text(10)
        quotientValue := quotient.Text(10)

        if strings.EqualFold(modValue, "0") </span><span class="cov8" title="1">{
                numstr = quotientValue
        }</span><span class="cov8" title="1"> else {
                numstr = quotientValue + "." + fmt.Sprintf("%08s", modValue)
                numstr = strings.TrimRight(numstr, "0")
        }</span>

        <span class="cov8" title="1">return numstr</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

import (
        "bytes"
        "fmt"

        "github.com/howeyc/gopass"
)

// GetPassword ask user for password interactively
func GetPassword() (string, error) <span class="cov0" title="0">{
        fmt.Printf("Please input your key file password: ")
        pass, err := gopass.GetPasswd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(pass), nil</span>
}

// SetPassword ask user input password twice and get the password interactively
func SetPassword() (string, error) <span class="cov0" title="0">{
        fmt.Printf("Password: ")
        pass, err := gopass.GetPasswd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">fmt.Printf("Repeat password:")
        passRepeat, err := gopass.GetPasswd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if !bytes.Equal(pass, passRepeat) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("repeat password is not equal to orignal one")
        }</span>

        <span class="cov0" title="0">return string(pass), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package common

import (
        "github.com/hashicorp/golang-lru"
)

// CopyBytes copies and returns a new bytes from the specified source bytes.
func CopyBytes(src []byte) []byte <span class="cov8" title="1">{
        if src == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">dest := make([]byte, len(src))
        copy(dest, src)
        return dest</span>
}

// MustNewCache creates a LRU cache with specified size. Panics on any error.
func MustNewCache(size int) *lru.Cache <span class="cov8" title="1">{
        cache, err := lru.New(size)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span> // error occurs only when size &lt;= 0.
        }

        <span class="cov8" title="1">return cache</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

import (
        "math/big"

        "github.com/orcaman/concurrent-map"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/state"
        "github.com/seeleteam/go-seele/core/types"
)

// BlockIndex is the index of the block chain
type BlockIndex struct {
        state           *state.Statedb
        currentBlock    *types.Block
        totalDifficulty *big.Int
}

// NewBlockIndex constructs and returns a BlockIndex instance
func NewBlockIndex(state *state.Statedb, block *types.Block, td *big.Int) *BlockIndex <span class="cov8" title="1">{
        return &amp;BlockIndex{
                state:           state,
                currentBlock:    block,
                totalDifficulty: td,
        }
}</span>

// BlockLeaves is the block leaves used for block forking
// Note that BlockLeaves is not thread safe
type BlockLeaves struct {
        blockIndexMap cmap.ConcurrentMap //block hash -&gt; blockIndex

        bestIndex *BlockIndex // the block index which is the first index with the largest total difficulty
}

// NewBlockLeaves constructs and returns a NewBlockLeaves instance
func NewBlockLeaves() *BlockLeaves <span class="cov8" title="1">{
        return &amp;BlockLeaves{
                blockIndexMap: cmap.New(),
        }
}</span>

// Remove removes the specified block index from the block leaves
func (bf *BlockLeaves) Remove(old *BlockIndex) <span class="cov8" title="1">{
        bf.blockIndexMap.Remove(old.currentBlock.HeaderHash.String())
        bf.updateBestIndexWhenRemove(old)
}</span>

// Add adds the specified block index to the block leaves
func (bf *BlockLeaves) Add(index *BlockIndex) <span class="cov8" title="1">{
        bf.blockIndexMap.Set(index.currentBlock.HeaderHash.String(), index)
        bf.updateBestIndexWhenAdd(index)
}</span>

// RemoveByHash removes the block index of the specified hash from the block leaves
func (bf *BlockLeaves) RemoveByHash(hash common.Hash) <span class="cov8" title="1">{
        index := bf.GetBlockIndexByHash(hash)
        bf.blockIndexMap.Remove(hash.String())
        if index != nil </span><span class="cov8" title="1">{
                bf.updateBestIndexWhenRemove(index)
        }</span>
}

// GetBestBlock gets the current block of the best block index in the block leaves
func (bf *BlockLeaves) GetBestBlock() *types.Block <span class="cov8" title="1">{
        return bf.GetBestBlockIndex().currentBlock
}</span>

// GetBestStateDB gets the state DB of the best block index in the block leaves
func (bf *BlockLeaves) GetBestStateDB() *state.Statedb <span class="cov8" title="1">{
        return bf.GetBestBlockIndex().state
}</span>

// GetBlockIndexByHash gets the block index with the specified hash in the block leaves
func (bf *BlockLeaves) GetBlockIndexByHash(hash common.Hash) *BlockIndex <span class="cov8" title="1">{
        index, ok := bf.blockIndexMap.Get(hash.String())
        if ok </span><span class="cov8" title="1">{
                return index.(*BlockIndex)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Count returns the number of the block indices in the block leaves
func (bf *BlockLeaves) Count() int <span class="cov8" title="1">{
        return bf.blockIndexMap.Count()
}</span>

// GetBestBlockIndex gets the best block index in the block leaves
func (bf *BlockLeaves) GetBestBlockIndex() *BlockIndex <span class="cov8" title="1">{
        return bf.bestIndex
}</span>

// updateBestIndexWhenRemove updates the best index when removing the given block index from the block leaves
func (bf *BlockLeaves) updateBestIndexWhenRemove(index *BlockIndex) <span class="cov8" title="1">{
        if bf.bestIndex != nil &amp;&amp; bf.bestIndex.currentBlock.HeaderHash == index.currentBlock.HeaderHash </span><span class="cov8" title="1">{
                bf.bestIndex = bf.findBestBlockIndex()
        }</span>
}

// updateBestIndexWhenAdd updates the best index when adding the given block index to the block leaves
func (bf *BlockLeaves) updateBestIndexWhenAdd(index *BlockIndex) <span class="cov8" title="1">{
        if bf.bestIndex == nil || bf.bestIndex.totalDifficulty.Cmp(index.totalDifficulty) &lt; 0 </span><span class="cov8" title="1">{
                bf.bestIndex = index
        }</span>
}

// findBestBlockIndex searchs for the block index of the largest total difficult from the block leaves
func (bf *BlockLeaves) findBestBlockIndex() *BlockIndex <span class="cov8" title="1">{
        maxTD := big.NewInt(0)
        var result *BlockIndex
        for item := range bf.blockIndexMap.IterBuffered() </span><span class="cov0" title="0">{
                index := item.Val.(*BlockIndex)
                if maxTD.Cmp(index.totalDifficulty) &lt; 0 </span><span class="cov0" title="0">{
                        maxTD = index.totalDifficulty
                        result = index
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// IsBestBlockIndex indicates whether the given block index is the best compared with all indices in the block leaves
func (bf *BlockLeaves) IsBestBlockIndex(index *BlockIndex) bool <span class="cov8" title="1">{
        td := index.totalDifficulty
        for item := range bf.blockIndexMap.IterBuffered() </span><span class="cov8" title="1">{
                bi := item.Val.(*BlockIndex)
                if td.Cmp(bi.totalDifficulty) &lt;= 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

import (
        "bytes"
        "errors"
        "fmt"
        "math/big"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/state"
        "github.com/seeleteam/go-seele/core/store"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/core/vm"
        "github.com/seeleteam/go-seele/database"
        "github.com/seeleteam/go-seele/event"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/metrics"
        "github.com/seeleteam/go-seele/miner/pow"
)

const (
        // limit block should not be ahead of 10 seconds of current time
        futureBlockLimit int64 = 10

        // block transaction number limit, 1000 simple transactions are about 152kb
        // If for block size as 100KB, it could contains about 5k transactions
        BlockTransactionNumberLimit = 5000
)

var (
        // ErrBlockHeaderNil is returned when the block header is nil.
        ErrBlockHeaderNil = errors.New("block header is nil")

        // ErrBlockHashMismatch is returned when the block hash does not match the header hash.
        ErrBlockHashMismatch = errors.New("block header hash mismatch")

        // ErrBlockTxsHashMismatch is returned when the block transactions hash does not match
        // the transaction root hash in the header.
        ErrBlockTxsHashMismatch = errors.New("block transactions root hash mismatch")

        // ErrBlockInvalidParentHash is returned when inserting a new header with invalid parent block hash.
        ErrBlockInvalidParentHash = errors.New("invalid parent block hash")

        // ErrBlockInvalidHeight is returned when inserting a new header with invalid block height.
        ErrBlockInvalidHeight = errors.New("invalid block height")

        // ErrBlockAlreadyExists is returned when inserted block already exists
        ErrBlockAlreadyExists = errors.New("block already exists")

        // ErrBlockStateHashMismatch is returned when the calculated account state hash of block
        // does not match the state root hash in block header.
        ErrBlockStateHashMismatch = errors.New("block state hash mismatch")

        // ErrBlockReceiptHashMismatch is returned when the calculated receipts hash of block
        // does not match the receipts root hash in block header.
        ErrBlockReceiptHashMismatch = errors.New("block receipts hash mismatch")

        // ErrBlockEmptyTxs is returned when writing a block with empty transactions.
        ErrBlockEmptyTxs = errors.New("empty transactions in block")

        // ErrBlockInvalidToAddress is returned when the to address of miner reward tx is nil.
        ErrBlockInvalidToAddress = errors.New("invalid to address")

        // ErrBlockCoinbaseMismatch is returned when the to address of miner reward tx does not match
        // the creator address in the block header.
        ErrBlockCoinbaseMismatch = errors.New("coinbase mismatch")

        // ErrBlockCreateTimeNull is returned when block create time is nil
        ErrBlockCreateTimeNull = errors.New("block must have create time")

        // ErrBlockCreateTimeOld is returned when block create time is previous of parent block time
        ErrBlockCreateTimeOld = errors.New("block time must be later than parent block time")

        // ErrBlockCreateTimeInFuture is returned when block create time is ahead of 10 seconds of now
        ErrBlockCreateTimeInFuture = errors.New("future block. block time is ahead 10 seconds of now")

        // ErrBlockDifficultInvalid is returned when block difficult is invalid
        ErrBlockDifficultInvalid = errors.New("block difficult is invalid")

        // ErrBlockTooManyTxs is returned when block have too many txs
        ErrBlockTooManyTxs = errors.New("block have too many transactions")

        // ErrBlockExtraDataNotEmpty is returned when the block extra data is not empty.
        ErrBlockExtraDataNotEmpty = errors.New("block extra data is not empty")
)

type consensusEngine interface {
        // ValidateHeader validates the specified header and return error if validation failed.
        // Generally, need to validate the block nonce.
        ValidateHeader(blockHeader *types.BlockHeader) error

        // ValidateRewardAmount validates the specified amount and returns error if validation failed.
        // The amount of miner reward will change over time.
        ValidateRewardAmount(blockHeight uint64, amount *big.Int) error
}

// Blockchain represents the blockchain with a genesis block. The Blockchain manages
// blocks insertion, deletion, reorganizations and persistence with a given database.
// This is a thread safe structure. we must keep all of its parameters are thread safe too.
type Blockchain struct {
        bcStore        store.BlockchainStore
        accountStateDB database.Database
        engine         consensusEngine
        genesisBlock   *types.Block
        lock           sync.RWMutex // lock for update blockchain info. for example write block

        blockLeaves *BlockLeaves
        log         *log.SeeleLog

        rp *recoveryPoint // used to recover blockchain in case of program crashed when write a block
}

// NewBlockchain returns an initialized blockchain with the given store and account state DB.
func NewBlockchain(bcStore store.BlockchainStore, accountStateDB database.Database, recoveryPointFile string) (*Blockchain, error) <span class="cov8" title="1">{
        bc := &amp;Blockchain{
                bcStore:        bcStore,
                accountStateDB: accountStateDB,
                engine:         &amp;pow.Engine{},
                log:            log.GetLogger("blockchain", common.LogConfig.PrintLog),
        }

        var err error

        // recover from program crash
        bc.rp, err = loadRecoveryPoint(recoveryPointFile)
        if err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to load recovery point info from file, %v", err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = bc.rp.recover(bcStore); err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to recover blockchain, info = %+v, error = %v", *bc.rp, err.Error())
                return nil, err
        }</span>

        // Get the genesis block from store
        <span class="cov8" title="1">genesisHash, err := bcStore.GetBlockHash(genesisBlockHeight)
        if err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to get block hash of genesis block height, %v", err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">bc.genesisBlock, err = bcStore.GetBlock(genesisHash)
        if err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to get block by genesis block hash, hash = %v, error = %v", genesisHash.ToHex(), err.Error())
                return nil, err
        }</span>

        // Get the HEAD block from store
        <span class="cov8" title="1">currentHeaderHash, err := bcStore.GetHeadBlockHash()
        if err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to get HEAD block hash, %v", err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">currentBlock, err := bcStore.GetBlock(currentHeaderHash)
        if err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to get block by HEAD block hash, hash = %v, error = %v", currentHeaderHash.ToHex(), err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">td, err := bcStore.GetBlockTotalDifficulty(currentHeaderHash)
        if err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to get HEAD block TD, hash = %v, error = %v", currentHeaderHash.ToHex(), err.Error())
                return nil, err
        }</span>

        // Get the state DB of the current block
        <span class="cov8" title="1">currentState, err := state.NewStatedb(currentBlock.Header.StateHash, accountStateDB)
        if err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to create state DB, state hash = %v, error = %v", currentBlock.Header.StateHash, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">blockIndex := NewBlockIndex(currentState, currentBlock, td)
        bc.blockLeaves = NewBlockLeaves()
        bc.blockLeaves.Add(blockIndex)

        return bc, nil</span>
}

// CurrentBlock returns the HEAD block of the blockchain.
func (bc *Blockchain) CurrentBlock() *types.Block <span class="cov8" title="1">{
        bc.lock.RLock()
        defer bc.lock.RUnlock()

        index := bc.blockLeaves.GetBestBlockIndex()
        if index == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return index.currentBlock</span>
}

// GetCurrentState returns the state DB of the current block.
func (bc *Blockchain) GetCurrentState() (*state.Statedb, error) <span class="cov8" title="1">{
        block := bc.CurrentBlock()
        return state.NewStatedb(block.Header.StateHash, bc.accountStateDB)
}</span>

// GetCurrentInfo return the current block and current state info
func (bc *Blockchain) GetCurrentInfo() (*types.Block, *state.Statedb, error) <span class="cov0" title="0">{
        block := bc.CurrentBlock()
        statedb, err := state.NewStatedb(block.Header.StateHash, bc.accountStateDB)
        return block, statedb, err
}</span>

// WriteBlock writes the specified block to the blockchain store.
func (bc *Blockchain) WriteBlock(block *types.Block) error <span class="cov8" title="1">{
        startWriteBlockTime := time.Now()
        if err := bc.doWriteBlock(block); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">markTime := time.Since(startWriteBlockTime)
        metrics.MetricsWriteBlockMeter.Mark(markTime.Nanoseconds())
        return nil</span>
}

func (bc *Blockchain) doWriteBlock(block *types.Block) error <span class="cov8" title="1">{
        if err := bc.validateBlock(block); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Do not write the block if already exists.
        <span class="cov8" title="1">exist, err := bc.bcStore.HasBlock(block.HeaderHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if exist </span><span class="cov8" title="1">{
                return ErrBlockAlreadyExists
        }</span>

        <span class="cov8" title="1">bc.lock.Lock()
        defer bc.lock.Unlock()

        var preBlock *types.Block
        if preBlock, err = bc.bcStore.GetBlock(block.Header.PreviousBlockHash); err != nil </span><span class="cov8" title="1">{
                return ErrBlockInvalidParentHash
        }</span>

        // Ensure the specified block is valid to insert.
        <span class="cov8" title="1">if err = bc.validateBlockInChain(block, preBlock); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Process the txs in the block and check the state root hash.
        <span class="cov8" title="1">var blockStatedb *state.Statedb
        var receipts []*types.Receipt
        if blockStatedb, receipts, err = bc.applyTxs(block, preBlock); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate receipts root hash.
        <span class="cov8" title="1">if receiptsRootHash := types.ReceiptMerkleRootHash(receipts); !receiptsRootHash.Equal(block.Header.ReceiptHash) </span><span class="cov0" title="0">{
                return ErrBlockReceiptHashMismatch
        }</span>

        // Validate state root hash.
        <span class="cov8" title="1">batch := bc.accountStateDB.NewBatch()
        committed := false
        defer func() </span><span class="cov8" title="1">{
                if !committed </span><span class="cov8" title="1">{
                        batch.Rollback()
                }</span>
        }()

        <span class="cov8" title="1">var stateRootHash common.Hash
        if stateRootHash, err = blockStatedb.Commit(batch); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !stateRootHash.Equal(block.Header.StateHash) </span><span class="cov0" title="0">{
                return ErrBlockStateHashMismatch
        }</span>

        // Update block leaves and write the block into store.
        <span class="cov8" title="1">currentBlock := &amp;types.Block{
                HeaderHash:   block.HeaderHash,
                Header:       block.Header.Clone(),
                Transactions: make([]*types.Transaction, len(block.Transactions)),
        }
        copy(currentBlock.Transactions, block.Transactions)

        var previousTd *big.Int
        if previousTd, err = bc.bcStore.GetBlockTotalDifficulty(block.Header.PreviousBlockHash); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">currentTd := new(big.Int).Add(previousTd, block.Header.Difficulty)
        blockIndex := NewBlockIndex(blockStatedb, currentBlock, currentTd)
        isHead := bc.blockLeaves.IsBestBlockIndex(blockIndex)

        /////////////////////////////////////////////////////////////////
        // PAY ATTENTION TO THE ORDER OF WRITING DATA INTO DB.
        // OTHERWISE, THERE MAY BE INCONSISTENT DATA.
        // 1. Write account states
        // 2. Write receipts
        // 3. Write block
        /////////////////////////////////////////////////////////////////
        if err = batch.Commit(); err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to batch commit account states, %v", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = bc.rp.onPutBlockStart(block, bc.bcStore, isHead); err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to set recovery point before put block into store, %v", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = bc.bcStore.PutReceipts(block.HeaderHash, receipts); err != nil </span><span class="cov0" title="0">{
                bc.log.Error("Failed to save receipts into store, %v", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = bc.bcStore.PutBlock(block, currentTd, isHead); err != nil </span><span class="cov8" title="1">{
                bc.log.Error("Failed to save block into store, %v", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">bc.rp.onPutBlockEnd()

        // If the new block has larger TD, the canonical chain will be changed.
        // In this case, need to update the height-to-blockHash mapping for the new canonical chain.
        if isHead </span><span class="cov8" title="1">{
                if err = deleteLargerHeightBlocks(bc.bcStore, block.Header.Height+1, bc.rp); err != nil </span><span class="cov0" title="0">{
                        bc.log.Error("Failed to delete larger height blocks when HEAD changed, larger height = %v, error = %v", block.Header.Height+1, err.Error())
                        return err
                }</span>

                <span class="cov8" title="1">if err = overwriteStaleBlocks(bc.bcStore, block.Header.PreviousBlockHash, bc.rp); err != nil </span><span class="cov0" title="0">{
                        bc.log.Error("Failed to overwrite stale blocks, hash = %v, error = %v", block.Header.PreviousBlockHash, err.Error())
                        return err
                }</span>
        }

        // update block header after meta info updated
        <span class="cov8" title="1">bc.blockLeaves.Add(blockIndex)
        bc.blockLeaves.RemoveByHash(block.Header.PreviousBlockHash)

        committed = true
        if isHead </span><span class="cov8" title="1">{
                event.ChainHeaderChangedEventMananger.Fire(block.HeaderHash)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateBlock validates all blockhain independent fields in the block.
func (bc *Blockchain) validateBlock(block *types.Block) error <span class="cov8" title="1">{
        if block == nil || block.Header == nil </span><span class="cov0" title="0">{
                return ErrBlockHeaderNil
        }</span>

        <span class="cov8" title="1">if !block.HeaderHash.Equal(block.Header.Hash()) </span><span class="cov8" title="1">{
                return ErrBlockHashMismatch
        }</span>

        <span class="cov8" title="1">if len(block.Transactions) &gt; BlockTransactionNumberLimit </span><span class="cov0" title="0">{
                return ErrBlockTooManyTxs
        }</span>

        // Validate timestamp
        <span class="cov8" title="1">if block.Header.CreateTimestamp == nil </span><span class="cov0" title="0">{
                return ErrBlockCreateTimeNull
        }</span>

        <span class="cov8" title="1">future := new(big.Int).SetInt64(time.Now().Unix() + futureBlockLimit)
        if block.Header.CreateTimestamp.Cmp(future) &gt; 0 </span><span class="cov0" title="0">{
                return ErrBlockCreateTimeInFuture
        }</span>

        // Now, the extra data in block header should be empty except the genesis block.
        <span class="cov8" title="1">if len(block.Header.ExtraData) &gt; 0 </span><span class="cov8" title="1">{
                return ErrBlockExtraDataNotEmpty
        }</span>

        // Validate miner shard
        <span class="cov8" title="1">if common.IsShardEnabled() </span><span class="cov0" title="0">{
                if shard := block.GetShardNumber(); shard != common.LocalShardNumber </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid shard number. block shard number is [%v], but local shard number is [%v]", shard, common.LocalShardNumber)
                }</span>
        }

        // Validate tx merkle root hash
        <span class="cov8" title="1">txsHash := types.MerkleRootHash(block.Transactions)
        if !txsHash.Equal(block.Header.TxHash) </span><span class="cov8" title="1">{
                return ErrBlockTxsHashMismatch
        }</span>

        <span class="cov8" title="1">return bc.engine.ValidateHeader(block.Header)</span>
}

// validateBlockInChain validates the specified block against with the previous block.
func (bc *Blockchain) validateBlockInChain(block, preBlock *types.Block) error <span class="cov8" title="1">{
        if block.Header.Height != preBlock.Header.Height+1 </span><span class="cov8" title="1">{
                return ErrBlockInvalidHeight
        }</span>

        <span class="cov8" title="1">if block.Header.CreateTimestamp.Cmp(preBlock.Header.CreateTimestamp) &lt; 0 </span><span class="cov0" title="0">{
                return ErrBlockCreateTimeOld
        }</span>

        <span class="cov8" title="1">difficult := pow.GetDifficult(block.Header.CreateTimestamp.Uint64(), preBlock.Header)
        if difficult == nil || difficult.Cmp(block.Header.Difficulty) != 0 </span><span class="cov0" title="0">{
                return ErrBlockDifficultInvalid
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetStore returns the blockchain store instance.
func (bc *Blockchain) GetStore() store.BlockchainStore <span class="cov8" title="1">{
        return bc.bcStore
}</span>

// applyTxs processes the txs in the specified block and returns the new state DB of the block.
// This method supposes the specified block is validated.
func (bc *Blockchain) applyTxs(block, preBlock *types.Block) (*state.Statedb, []*types.Receipt, error) <span class="cov8" title="1">{
        minerRewardTx, err := bc.validateMinerRewardTx(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">statedb, err := state.NewStatedb(preBlock.Header.StateHash, bc.accountStateDB)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">receipts, err := bc.updateStateDB(statedb, minerRewardTx, block.Transactions[1:], block.Header)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return statedb, receipts, nil</span>
}

func (bc *Blockchain) validateMinerRewardTx(block *types.Block) (*types.Transaction, error) <span class="cov8" title="1">{
        if len(block.Transactions) == 0 </span><span class="cov0" title="0">{
                return nil, ErrBlockEmptyTxs
        }</span>

        <span class="cov8" title="1">minerRewardTx := block.Transactions[0]
        if minerRewardTx.Data.To.IsEmpty() </span><span class="cov0" title="0">{
                return nil, ErrBlockInvalidToAddress
        }</span>

        <span class="cov8" title="1">if !bytes.Equal(minerRewardTx.Data.To.Bytes(), block.Header.Creator.Bytes()) </span><span class="cov0" title="0">{
                return nil, ErrBlockCoinbaseMismatch
        }</span>

        <span class="cov8" title="1">if minerRewardTx.Data.Amount == nil </span><span class="cov0" title="0">{
                return nil, types.ErrAmountNil
        }</span>

        <span class="cov8" title="1">if minerRewardTx.Data.Amount.Sign() &lt; 0 </span><span class="cov0" title="0">{
                return nil, types.ErrAmountNegative
        }</span>

        <span class="cov8" title="1">if err := bc.engine.ValidateRewardAmount(block.Header.Height, minerRewardTx.Data.Amount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if minerRewardTx.Data.Timestamp != block.Header.CreateTimestamp.Uint64() </span><span class="cov0" title="0">{
                return nil, types.ErrTimestampMismatch
        }</span>

        <span class="cov8" title="1">return minerRewardTx, nil</span>
}

func (bc *Blockchain) updateStateDB(statedb *state.Statedb, minerRewardTx *types.Transaction, txs []*types.Transaction, blockHeader *types.BlockHeader) ([]*types.Receipt, error) <span class="cov8" title="1">{
        // process miner reward
        rewardTxReceipt, err := ApplyRewardTx(minerRewardTx, statedb)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">receipts := make([]*types.Receipt, len(txs)+1)

        // add the receipt of the reward tx
        receipts[0] = rewardTxReceipt

        if err := types.BatchValidateTxs(txs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // process other txs
        <span class="cov8" title="1">for i, tx := range txs </span><span class="cov8" title="1">{
                if err := tx.ValidateState(statedb); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">receipt, err := bc.ApplyTransaction(tx, i+1, minerRewardTx.Data.To, statedb, blockHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">receipts[i+1] = receipt</span>
        }

        <span class="cov8" title="1">return receipts, nil</span>
}

// ApplyRewardTx applies a reward transaction, changes corresponding statedb and generates a receipt.
func ApplyRewardTx(rewardTx *types.Transaction, statedb *state.Statedb) (*types.Receipt, error) <span class="cov8" title="1">{
        statedb.CreateAccount(rewardTx.Data.To)
        statedb.AddBalance(rewardTx.Data.To, rewardTx.Data.Amount)

        hash, err := statedb.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">receipt := types.MakeRewardReceipt(rewardTx)
        receipt.PostState = hash

        return receipt, nil</span>
}

// ApplyTransaction applies a transaction, changes corresponding statedb and generates its receipt
func (bc *Blockchain) ApplyTransaction(tx *types.Transaction, txIndex int, coinbase common.Address, statedb *state.Statedb, blockHeader *types.BlockHeader) (*types.Receipt, error) <span class="cov8" title="1">{
        context := NewEVMContext(tx, blockHeader, coinbase, bc.bcStore)
        receipt, err := ProcessContract(context, tx, txIndex, statedb, &amp;vm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return receipt, nil</span>
}

// deleteLargerHeightBlocks deletes the height-to-hash mappings with larger height in the canonical chain.
func deleteLargerHeightBlocks(bcStore store.BlockchainStore, largerHeight uint64, rp *recoveryPoint) error <span class="cov8" title="1">{
        // When recover the blockchain, the larger height block hash may be already deleted before program crash.
        if _, err := bcStore.DeleteBlockHash(largerHeight); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := largerHeight + 1; ; i++ </span><span class="cov8" title="1">{
                if rp != nil </span><span class="cov8" title="1">{
                        rp.onDeleteLargerHeightBlocks(i)
                }</span>

                <span class="cov8" title="1">deleted, err := bcStore.DeleteBlockHash(i)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if !deleted </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if rp != nil </span><span class="cov8" title="1">{
                rp.onDeleteLargerHeightBlocks(0)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// overwriteStaleBlocks overwrites the stale canonical height-to-hash mappings.
func overwriteStaleBlocks(bcStore store.BlockchainStore, staleHash common.Hash, rp *recoveryPoint) error <span class="cov8" title="1">{
        var overwritten bool
        var err error

        // When recover the blockchain, the stale block hash my be already overwritten before program crash.
        if _, staleHash, err = overwriteSingleStaleBlock(bcStore, staleHash); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for !staleHash.Equal(common.EmptyHash) </span><span class="cov8" title="1">{
                if rp != nil </span><span class="cov8" title="1">{
                        rp.onOverwriteStaleBlocks(staleHash)
                }</span>

                <span class="cov8" title="1">if overwritten, staleHash, err = overwriteSingleStaleBlock(bcStore, staleHash); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if !overwritten </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if rp != nil </span><span class="cov8" title="1">{
                rp.onOverwriteStaleBlocks(common.EmptyHash)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func overwriteSingleStaleBlock(bcStore store.BlockchainStore, hash common.Hash) (overwritten bool, preBlockHash common.Hash, err error) <span class="cov8" title="1">{
        header, err := bcStore.GetBlockHeader(hash)
        if err != nil </span><span class="cov0" title="0">{
                return false, common.EmptyHash, err
        }</span>

        <span class="cov8" title="1">canonicalHash, err := bcStore.GetBlockHash(header.Height)
        if err != nil </span><span class="cov0" title="0">{
                return false, common.EmptyHash, err
        }</span>

        <span class="cov8" title="1">if hash.Equal(canonicalHash) </span><span class="cov8" title="1">{
                return false, header.PreviousBlockHash, nil
        }</span>

        <span class="cov8" title="1">if err = bcStore.PutBlockHash(header.Height, hash); err != nil </span><span class="cov0" title="0">{
                return false, common.EmptyHash, err
        }</span>

        <span class="cov8" title="1">return true, header.PreviousBlockHash, nil</span>
}

// GetShardNumber returns the shard number of blockchian.
func (bc *Blockchain) GetShardNumber() (uint, error) <span class="cov8" title="1">{
        data, err := getGenesisExtraData(bc.genesisBlock)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return data.ShardNumber, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

import (
        "encoding/json"
        "io/ioutil"
        "os"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/store"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/log"
)

var rpLog = log.GetLogger("recoveryPoint", common.LogConfig.PrintLog)

// recoveryPoint is used for blockchain recovery in case of program crashed when write a block.
type recoveryPoint struct {
        WritingBlockHash           common.Hash // block hash that was writing to blockchain.
        WritingBlockHeight         uint64      // block height that was writing to blockchain.
        PreviousCanonicalBlockHash common.Hash // overwritten block hash once the writing block is new HEAD in canonical chain.
        PreviousHeadBlockHash      common.Hash // current HEAD block hash when write a block.
        LargerHeight               uint64      // Record the larger height block that to be removed from canonical chain.
        StaleHash                  common.Hash // Record the stale block hash for overwrite in canonical chain.

        file string
}

func loadRecoveryPoint(file string) (*recoveryPoint, error) <span class="cov8" title="1">{
        rp := recoveryPoint{
                file: file,
        }

        if len(file) == 0 || !common.FileOrFolderExists(file) </span><span class="cov8" title="1">{
                return &amp;rp, nil
        }</span>

        <span class="cov8" title="1">bytes, err := ioutil.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                rpLog.Error("Failed to read bytes from recovery point file, %v", err.Error())
                return &amp;rp, err
        }</span>

        <span class="cov8" title="1">if err = json.Unmarshal(bytes, &amp;rp); err != nil </span><span class="cov0" title="0">{
                rpLog.Warn("Failed to unmarshal encoded JSON data to recovery point info, file = %v, error = %v", file, err.Error())
                rp.serialize()
        }</span>

        <span class="cov8" title="1">return &amp;rp, nil</span>
}

func (rp *recoveryPoint) recover(bcStore store.BlockchainStore) error <span class="cov8" title="1">{
        saved := true

        // recover the previous HEAD block hash.
        if !rp.PreviousHeadBlockHash.IsEmpty() </span><span class="cov8" title="1">{
                if err := bcStore.PutHeadBlockHash(rp.PreviousHeadBlockHash); err != nil </span><span class="cov0" title="0">{
                        rpLog.Error("Failed to recover HEAD block hash, hash = %v, error = %v", rp.PreviousCanonicalBlockHash.ToHex(), err.Error())
                        return err
                }</span>

                <span class="cov8" title="1">rp.PreviousHeadBlockHash = common.EmptyHash
                rpLog.Info("Succeed to recover HEAD block hash.")</span>
        }

        // recover the previous block hash in canonical chain.
        <span class="cov8" title="1">if rp.WritingBlockHeight &gt; 0 &amp;&amp; !rp.PreviousCanonicalBlockHash.IsEmpty() </span><span class="cov0" title="0">{
                if err := bcStore.PutBlockHash(rp.WritingBlockHeight, rp.PreviousCanonicalBlockHash); err != nil </span><span class="cov0" title="0">{
                        rpLog.Error("Failed to recover the block hash by height in canonical chain, height = %v, hash = %v, error = %v", rp.LargerHeight, rp.PreviousCanonicalBlockHash, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">rp.PreviousCanonicalBlockHash = common.EmptyHash
                rpLog.Info("Succeed to recover the block hash by height in canonical chain.")</span>
        }

        // delete the crashed block.
        <span class="cov8" title="1">if !rp.WritingBlockHash.IsEmpty() </span><span class="cov8" title="1">{
                if err := bcStore.DeleteBlock(rp.WritingBlockHash); err != nil </span><span class="cov0" title="0">{
                        rpLog.Error("Failed to delete the crashed block, hash = %v, error = %v", rp.WritingBlockHash, err.Error())
                        return err
                }</span>

                <span class="cov8" title="1">rp.WritingBlockHash = common.EmptyHash
                saved = false
                rpLog.Info("Succeed to delete the crashed block.")</span>
        }

        // go on to delete larger height blocks from canonical chain.
        <span class="cov8" title="1">if saved &amp;&amp; rp.LargerHeight &gt; 0 </span><span class="cov8" title="1">{
                if err := deleteLargerHeightBlocks(bcStore, rp.LargerHeight, nil); err != nil </span><span class="cov0" title="0">{
                        rpLog.Error("Failed to delete the larger height blocks in canonical chain, height = %v, error = %v", rp.LargerHeight, err.Error())
                        return err
                }</span>

                <span class="cov8" title="1">rpLog.Info("Succeed to delete the larger height blocks in canonical chain.")</span>
        }

        <span class="cov8" title="1">rp.LargerHeight = 0

        // go on to overwrite stale blocks in canonical chain.
        if saved &amp;&amp; !rp.StaleHash.IsEmpty() </span><span class="cov8" title="1">{
                if err := overwriteStaleBlocks(bcStore, rp.StaleHash, nil); err != nil </span><span class="cov0" title="0">{
                        rpLog.Error("Failed to overwrite the stale blocks in canonical chain, hash = %v, error = %v", rp.StaleHash, err.Error())
                        return err
                }</span>

                <span class="cov8" title="1">rpLog.Info("Succeed to overwrite stale blocks in canonical chain.")</span>
        }

        <span class="cov8" title="1">rp.StaleHash = common.EmptyHash

        rp.serialize()

        return nil</span>
}

func (rp *recoveryPoint) serialize() <span class="cov8" title="1">{
        // do nothing if file is empty.
        // Generally, UT could use empty file name to ignore the recovery point mechanism.
        if len(rp.file) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">encoded, err := json.MarshalIndent(rp, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                // just log the error so as not to block the blockchain initialization.
                rpLog.Warn("Failed to marshal recovery point info to JSON data, rp = %+v, error = %v", *rp, err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := ioutil.WriteFile(rp.file, encoded, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                // just log the error so as not to block the blockchain initialization.
                rpLog.Warn("Failed to write recovery point JSON data to file, file = %v, error = %v", rp.file, err.Error())
        }</span>
}

func (rp *recoveryPoint) onPutBlockStart(block *types.Block, bcStore store.BlockchainStore, isHead bool) error <span class="cov8" title="1">{
        rp.WritingBlockHash = block.HeaderHash
        rp.WritingBlockHeight = block.Header.Height

        // the block of specified height may not exist in canonical chain.
        if hash, err := bcStore.GetBlockHash(rp.WritingBlockHeight); err == nil </span><span class="cov8" title="1">{
                rp.PreviousCanonicalBlockHash = hash
        }</span><span class="cov8" title="1"> else {
                rp.PreviousCanonicalBlockHash = common.EmptyHash
        }</span>

        // HEAD block hash must exist
        <span class="cov8" title="1">hash, err := bcStore.GetHeadBlockHash()
        if err != nil </span><span class="cov0" title="0">{
                rpLog.Error("Failed to get HEAD block hash onPutBlockStart, %v", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">rp.PreviousHeadBlockHash = hash

        if isHead </span><span class="cov8" title="1">{
                rp.LargerHeight = block.Header.Height + 1
                rp.StaleHash = block.Header.PreviousBlockHash
        }</span><span class="cov8" title="1"> else {
                rp.LargerHeight = 0
                rp.StaleHash = common.EmptyHash
        }</span>

        <span class="cov8" title="1">rp.serialize()

        return nil</span>
}

func (rp *recoveryPoint) onPutBlockEnd() <span class="cov8" title="1">{
        rp.PreviousHeadBlockHash = common.EmptyHash
        rp.WritingBlockHeight = 0
        rp.PreviousCanonicalBlockHash = common.EmptyHash
        rp.WritingBlockHash = common.EmptyHash

        rp.serialize()
}</span>

func (rp *recoveryPoint) onDeleteLargerHeightBlocks(height uint64) <span class="cov8" title="1">{
        rp.LargerHeight = height
        rp.serialize()
}</span>

func (rp *recoveryPoint) onOverwriteStaleBlocks(hash common.Hash) <span class="cov8" title="1">{
        rp.StaleHash = hash
        rp.serialize()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

import (
        "math/big"

        "github.com/ethereum/go-ethereum/params"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/state"
        "github.com/seeleteam/go-seele/core/store"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/core/vm"
)

const maxTxGas = uint64(10000000)

// NewEVMContext creates a new context for use in the EVM.
func NewEVMContext(tx *types.Transaction, header *types.BlockHeader, minerAddress common.Address, bcStore store.BlockchainStore) *vm.Context <span class="cov8" title="1">{
        canTransferFunc := func(db vm.StateDB, addr common.Address, amount *big.Int) bool </span><span class="cov8" title="1">{
                return db.GetBalance(addr).Cmp(amount) &gt;= 0
        }</span>

        <span class="cov8" title="1">transferFunc := func(db vm.StateDB, sender, recipient common.Address, amount *big.Int) </span><span class="cov8" title="1">{
                db.SubBalance(sender, amount)
                db.AddBalance(recipient, amount)
        }</span>

        <span class="cov8" title="1">heightToHashMapping := map[uint64]common.Hash{
                header.Height - 1: header.PreviousBlockHash,
        }
        getHashFunc := func(height uint64) (common.Hash, error) </span><span class="cov0" title="0">{
                for preHash := header.PreviousBlockHash; ; </span><span class="cov0" title="0">{
                        if hash, ok := heightToHashMapping[height]; ok </span><span class="cov0" title="0">{
                                return hash, nil
                        }</span>

                        <span class="cov0" title="0">preHeader, err := bcStore.GetBlockHeader(preHash)
                        if err != nil </span><span class="cov0" title="0">{
                                return common.EmptyHash, err
                        }</span>

                        <span class="cov0" title="0">heightToHashMapping[preHeader.Height-1] = preHeader.PreviousBlockHash
                        preHash = preHeader.PreviousBlockHash</span>
                }
        }

        <span class="cov8" title="1">return &amp;vm.Context{
                CanTransfer: canTransferFunc,
                Transfer:    transferFunc,
                GetHash:     getHashFunc,
                Origin:      tx.Data.From,
                Coinbase:    minerAddress,
                BlockNumber: new(big.Int).SetUint64(header.Height),
                Time:        new(big.Int).Set(header.CreateTimestamp),
                Difficulty:  new(big.Int).Set(header.Difficulty),
                // GasLimit:    header.GasLimit,
                // GasPrice:    new(big.Int).Set(tx.GasPrice()),
        }</span>
}

// ProcessContract process the specified contract tx and return the receipt.
func ProcessContract(context *vm.Context, tx *types.Transaction, txIndex int, statedb *state.Statedb, vmConfig *vm.Config) (*types.Receipt, error) <span class="cov8" title="1">{
        statedb.Prepare(txIndex)
        evm := vm.NewEVM(*context, statedb, getDefaultChainConfig(), *vmConfig)

        var err error
        caller := vm.AccountRef(tx.Data.From)
        receipt := &amp;types.Receipt{TxHash: tx.Hash}
        gas := maxTxGas
        leftOverGas := uint64(0)
        gasFee := new(big.Int)

        // Currently, use maxTxGas gas to bypass ErrInsufficientBalance error and avoid overly complex contract creation or calculation.
        if tx.Data.To.IsEmpty() </span><span class="cov8" title="1">{
                gasFee = contractCreationFee(tx.Data.Payload)

                var createdContractAddr common.Address
                if receipt.Result, createdContractAddr, leftOverGas, err = evm.Create(caller, tx.Data.Payload, gas, tx.Data.Amount); err == nil </span><span class="cov8" title="1">{
                        receipt.ContractAddress = createdContractAddr.Bytes()
                }</span>
        }<span class="cov8" title="1"> else {
                statedb.SetNonce(tx.Data.From, tx.Data.AccountNonce+1)
                receipt.Result, leftOverGas, err = evm.Call(caller, tx.Data.To, tx.Data.Payload, gas, tx.Data.Amount)

                gasFee = usedGasFee(gas - leftOverGas)
        }</span>

        // Below error handling comes from ETH:
        // The only possible consensus-error would be if there wasn't
        // sufficient balance to make the transfer happen. The first
        // balance transfer may never fail.
        <span class="cov8" title="1">if err == vm.ErrInsufficientBalance </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">totalFee := new(big.Int).Add(gasFee, tx.Data.Fee)
        if balance := statedb.GetBalance(tx.Data.From); balance.Cmp(totalFee) &lt; 0 </span><span class="cov8" title="1">{
                return nil, vm.ErrInsufficientBalance
        }</span>

        // transfer fee to coinbase
        <span class="cov8" title="1">statedb.SubBalance(tx.Data.From, totalFee)
        statedb.AddBalance(context.Coinbase, totalFee)

        if err != nil </span><span class="cov0" title="0">{
                receipt.Failed = true
                receipt.Result = []byte(err.Error())
        }</span>

        <span class="cov8" title="1">receipt.UsedGas = gas - leftOverGas

        if receipt.PostState, err = statedb.Hash(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">receipt.Logs = statedb.GetCurrentLogs()
        if receipt.Logs == nil </span><span class="cov8" title="1">{
                receipt.Logs = make([]*types.Log, 0)
        }</span>

        <span class="cov8" title="1">return receipt, nil</span>
}

func getDefaultChainConfig() *params.ChainConfig <span class="cov8" title="1">{
        return &amp;params.ChainConfig{
                ChainId:             big.NewInt(1),
                HomesteadBlock:      big.NewInt(0),
                DAOForkBlock:        big.NewInt(0),
                DAOForkSupport:      true,
                EIP150Block:         big.NewInt(0),
                EIP155Block:         big.NewInt(0),
                EIP158Block:         big.NewInt(0),
                ByzantiumBlock:      big.NewInt(0),
                ConstantinopleBlock: nil,
                Ethash:              new(params.EthashConfig),
        }
}</span>

///////////////////////////////////////////////////////////////////////////////////////
// Gas fee model for test net
///////////////////////////////////////////////////////////////////////////////////////
var (
        contractFeeComplex       = new(big.Int).Div(common.SeeleToFan, big.NewInt(100))
        contractFeeCustomToken   = new(big.Int).Div(common.SeeleToFan, big.NewInt(200))
        contractFeeStandardToken = new(big.Int).Div(common.SeeleToFan, big.NewInt(500))
        contractFeeSimple        = new(big.Int).Div(common.SeeleToFan, big.NewInt(1000))

        lowPriceGas  = uint64(50000) // 2 storage op allowed
        overUsedStep = uint64(20000) // about 1 storage op

        gasFeeZero          = new(big.Int)
        gasFeeLowPrice      = new(big.Int).Div(contractFeeSimple, big.NewInt(1000))
        gasFeeHighPriceUnit = new(big.Int).Div(contractFeeSimple, big.NewInt(100))
)

// contractCreationFee returns the contract creation fee according to code size.
func contractCreationFee(code []byte) *big.Int <span class="cov8" title="1">{
        codeLen := len(code)

        // complex contract &gt; 16KB
        if codeLen &gt; 16*1024*1024 </span><span class="cov0" title="0">{
                return contractFeeComplex
        }</span>

        // custom simple ERC20 token between [8KB, 16KB)
        <span class="cov8" title="1">if codeLen &gt; 8*1024*1024 </span><span class="cov0" title="0">{
                return contractFeeCustomToken
        }</span>

        // standard ERC20 token between [5KB, 8KB)
        <span class="cov8" title="1">if codeLen &gt; 4*1024*1024 </span><span class="cov0" title="0">{
                return contractFeeStandardToken
        }</span>

        // other simple contract
        <span class="cov8" title="1">return contractFeeSimple</span>
}

// usedGasFee returns the contract execution fee according to used gas.
//   - if usedGas == 0, returns 0.
//   - if usedGas &lt;= 50000 (2 store op allowed), returns 1/1000 * contractFeeSimple
//   - else returns 1/100 * contractFeeSimple * overUsed^2
func usedGasFee(usedGas uint64) *big.Int <span class="cov8" title="1">{
        if usedGas == 0 </span><span class="cov8" title="1">{
                return gasFeeZero
        }</span>

        <span class="cov8" title="1">if usedGas &lt;= lowPriceGas </span><span class="cov8" title="1">{
                return gasFeeLowPrice
        }</span>

        <span class="cov0" title="0">overUsed := (usedGas-lowPriceGas)/overUsedStep + 1

        return new(big.Int).Mul(gasFeeHighPriceUnit, new(big.Int).SetUint64(overUsed*overUsed))</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

import (
        "fmt"
        "math/big"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/state"
        "github.com/seeleteam/go-seele/core/store"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/database"
        "github.com/syndtr/goleveldb/leveldb/errors"
)

var (
        // ErrGenesisHashMismatch is returned when the genesis block hash between the store and memory mismatch.
        ErrGenesisHashMismatch = errors.New("genesis block hash mismatch")

        // ErrGenesisNotFound is returned when genesis block not found in the store.
        ErrGenesisNotFound = errors.New("genesis block not found")
)

const genesisBlockHeight = uint64(0)

// Genesis represents the genesis block in the blockchain.
type Genesis struct {
        header *types.BlockHeader
        info   GenesisInfo
}

// GenesisInfo genesis info for generating genesis block, it could be used for initializing account balance
type GenesisInfo struct {
        // Accounts accounts info for genesis block used for test
        // map key is account address -&gt; value is account balance
        Accounts map[common.Address]*big.Int `json:"accounts"`

        // Difficult initial difficult for mining. Use bigger difficult as you can. Because block is choose by total difficult
        Difficult int64 `json:"difficult"`

        // ShardNumber is the shard number of genesis block.
        ShardNumber uint `json:"shard"`
}

// genesisExtraData represents the extra data that saved in the genesis block in the blockchain.
type genesisExtraData struct {
        ShardNumber uint
}

// GetGenesis gets the genesis block according to accounts' balance
func GetGenesis(info GenesisInfo) *Genesis <span class="cov8" title="1">{
        if info.Difficult == 0 </span><span class="cov8" title="1">{
                info.Difficult = 1
        }</span>

        <span class="cov8" title="1">statedb, err := getStateDB(info)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">stateRootHash, err := statedb.Hash()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">extraData := genesisExtraData{info.ShardNumber}

        return &amp;Genesis{
                header: &amp;types.BlockHeader{
                        PreviousBlockHash: common.EmptyHash,
                        Creator:           common.Address{},
                        StateHash:         stateRootHash,
                        TxHash:            types.MerkleRootHash(nil),
                        Difficulty:        big.NewInt(info.Difficult),
                        Height:            genesisBlockHeight,
                        CreateTimestamp:   big.NewInt(0),
                        Nonce:             1,
                        ExtraData:         common.SerializePanic(extraData),
                },
                info: info,
        }</span>
}

// GetShardNumber gets the shard number of genesis
func (genesis *Genesis) GetShardNumber() uint <span class="cov0" title="0">{
        return genesis.info.ShardNumber
}</span>

// InitializeAndValidate writes the genesis block in the blockchain store if unavailable.
// Otherwise, check if the existing genesis block is valid in the blockchain store.
func (genesis *Genesis) InitializeAndValidate(bcStore store.BlockchainStore, accountStateDB database.Database) error <span class="cov8" title="1">{
        storedGenesisHash, err := bcStore.GetBlockHash(genesisBlockHeight)

        // FIXME use seele-defined common error instead of concrete levelDB error.
        if err == errors.ErrNotFound </span><span class="cov8" title="1">{
                return genesis.store(bcStore, accountStateDB)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">storedGenesis, err := bcStore.GetBlock(storedGenesisHash)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("get genesis block failed. %s", err))
        }</span>

        <span class="cov8" title="1">data, err := getGenesisExtraData(storedGenesis)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("get genesis extra data failed. %s", err))
        }</span>

        <span class="cov8" title="1">if data.ShardNumber != genesis.info.ShardNumber </span><span class="cov0" title="0">{
                return errors.New("specific shard number does not match with the shard number in genesis info")
        }</span>

        <span class="cov8" title="1">headerHash := genesis.header.Hash()
        if !headerHash.Equal(storedGenesisHash) </span><span class="cov8" title="1">{
                return ErrGenesisHashMismatch
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// store atomically stores the genesis block in the blockchain store.
func (genesis *Genesis) store(bcStore store.BlockchainStore, accountStateDB database.Database) error <span class="cov8" title="1">{
        statedb, err := getStateDB(genesis.info)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">batch := accountStateDB.NewBatch()
        statedb.Commit(batch)
        if err = batch.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return bcStore.PutBlockHeader(genesis.header.Hash(), genesis.header, genesis.header.Difficulty, true)</span>
}

func getStateDB(info GenesisInfo) (*state.Statedb, error) <span class="cov8" title="1">{
        statedb, err := state.NewStatedb(common.EmptyHash, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for addr, amount := range info.Accounts </span><span class="cov8" title="1">{
                if !common.IsShardEnabled() || addr.Shard() == info.ShardNumber </span><span class="cov8" title="1">{
                        statedb.CreateAccount(addr)
                        statedb.SetBalance(addr, amount)
                }</span>
        }

        <span class="cov8" title="1">return statedb, nil</span>
}

// getGenesisExtraData returns the extra data of specified genesis block.
func getGenesisExtraData(genesisBlock *types.Block) (*genesisExtraData, error) <span class="cov8" title="1">{
        if genesisBlock.Header.Height != genesisBlockHeight </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid genesis block height %v", genesisBlock.Header.Height)
        }</span>

        <span class="cov8" title="1">data := genesisExtraData{}
        if err := common.Deserialize(genesisBlock.Header.ExtraData, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;data, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

import (
        "sync"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/store"
        "github.com/seeleteam/go-seele/core/types"
)

// HeaderChain represents the block header chain that is shared by the archive node and light node.
// This is a non-thread safe structure.
type HeaderChain struct {
        lock    sync.Mutex
        bcStore store.BlockchainStore

        genesisHeader     *types.BlockHeader
        currentHeader     *types.BlockHeader
        currentHeaderHash common.Hash
}

// NewHeaderChain returns a new instance of the HeaderChain structure.
func NewHeaderChain(bcStore store.BlockchainStore) (*HeaderChain, error) <span class="cov8" title="1">{
        hc := HeaderChain{
                bcStore: bcStore,
        }

        // Get the genesis block header from the store.
        genesisHash, err := bcStore.GetBlockHash(genesisBlockHeight)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hc.genesisHeader, err = bcStore.GetBlockHeader(genesisHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get the HEAD block header from the store.
        <span class="cov8" title="1">hc.currentHeaderHash, err = bcStore.GetHeadBlockHash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hc.currentHeader, err = bcStore.GetBlockHeader(hc.currentHeaderHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hc.lock = sync.Mutex{}

        return &amp;hc, nil</span>
}

// WriteHeader writes a new block header into the header chain.
// It requires the new header's parent header is the HEAD header
// in the chain.
func (hc *HeaderChain) WriteHeader(newHeader *types.BlockHeader) error <span class="cov8" title="1">{
        hc.lock.Lock()
        defer hc.lock.Unlock()

        newHeaderHash := newHeader.Hash()
        hc.currentHeaderHash, hc.currentHeader = newHeaderHash, newHeader.Clone()

        return nil
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package state

import (
        "math/big"

        "github.com/seeleteam/go-seele/common"
)

type journalEntry interface {
        // revert reverts the state change in the specified statedb
        revert(*Statedb)

        // dirtyAccount returns the account address of dirty data in statedb.
        // Return nil if the changed data not saved in statedb.
        dirtyAccount() *common.Address
}

type journal struct {
        entries []journalEntry
        dirties map[common.Address]uint
}

func newJournal() *journal <span class="cov8" title="1">{
        return &amp;journal{
                dirties: make(map[common.Address]uint),
        }
}</span>

func (j *journal) append(entry journalEntry) <span class="cov8" title="1">{
        j.entries = append(j.entries, entry)
        if addr := entry.dirtyAccount(); addr != nil </span><span class="cov8" title="1">{
                j.dirties[*addr]++
        }</span>
}

func (j *journal) snapshot() int <span class="cov8" title="1">{
        return len(j.entries)
}</span>

func (j *journal) revert(statedb *Statedb, snapshot int) <span class="cov8" title="1">{
        for i := len(j.entries) - 1; i &gt;= snapshot; i-- </span><span class="cov8" title="1">{
                j.entries[i].revert(statedb)

                if addr := j.entries[i].dirtyAccount(); addr != nil </span><span class="cov8" title="1">{
                        if j.dirties[*addr]--; j.dirties[*addr] == 0 </span><span class="cov8" title="1">{
                                delete(j.dirties, *addr)
                        }</span>
                }

                <span class="cov8" title="1">j.entries[i] = nil</span>
        }

        <span class="cov8" title="1">j.entries = j.entries[:snapshot]</span>
}

type (
        refundChange struct {
                prev uint64
        }
        storageChange struct {
                account *common.Address
                key     common.Hash
                prev    common.Hash
        }
        balanceChange struct {
                account *common.Address
                prev    *big.Int
        }
        codeChange struct {
                account *common.Address
                prev    []byte
        }
        nonceChange struct {
                account *common.Address
                prev    uint64
        }
        suicideChange struct {
                account      *common.Address
                prevSuicided bool
                prevBalance  *big.Int
        }
        createObjectChange struct {
                account *common.Address
        }
)

func (ch refundChange) revert(s *Statedb) <span class="cov8" title="1">{
        s.refund = ch.prev
}</span>

func (ch refundChange) dirtyAccount() *common.Address <span class="cov8" title="1">{
        return nil
}</span>

func (ch storageChange) revert(s *Statedb) <span class="cov8" title="1">{
        s.getStateObject(*ch.account).setState(ch.key, ch.prev)
}</span>

func (ch storageChange) dirtyAccount() *common.Address <span class="cov8" title="1">{
        return ch.account
}</span>

func (ch balanceChange) revert(s *Statedb) <span class="cov8" title="1">{
        s.getStateObject(*ch.account).account.Amount = ch.prev
}</span>

func (ch balanceChange) dirtyAccount() *common.Address <span class="cov8" title="1">{
        return ch.account
}</span>

func (ch codeChange) revert(s *Statedb) <span class="cov8" title="1">{
        s.getStateObject(*ch.account).setCode(ch.prev)
}</span>

func (ch codeChange) dirtyAccount() *common.Address <span class="cov8" title="1">{
        return ch.account
}</span>

func (ch nonceChange) revert(s *Statedb) <span class="cov8" title="1">{
        s.getStateObject(*ch.account).account.Nonce = ch.prev
}</span>

func (ch nonceChange) dirtyAccount() *common.Address <span class="cov8" title="1">{
        return ch.account
}</span>

func (ch suicideChange) revert(s *Statedb) <span class="cov8" title="1">{
        obj := s.getStateObject(*ch.account)
        if obj != nil </span><span class="cov8" title="1">{
                obj.suicided = ch.prevSuicided
                obj.account.Amount = ch.prevBalance
        }</span>
}

func (ch suicideChange) dirtyAccount() *common.Address <span class="cov8" title="1">{
        return ch.account
}</span>

func (ch createObjectChange) revert(s *Statedb) <span class="cov8" title="1">{
        delete(s.stateObjects, *ch.account)
}</span>

func (ch createObjectChange) dirtyAccount() *common.Address <span class="cov8" title="1">{
        return ch.account
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package state

import (
        "math/big"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/database"
        "github.com/seeleteam/go-seele/trie"
)

// StateCacheCapacity is the capacity of state cache
const StateCacheCapacity = 1000

var (
        stateBalance0 = big.NewInt(0)
)

// Statedb is used to store accounts into the MPT tree
type Statedb struct {
        db           database.Database
        trie         *trie.Trie
        stateObjects map[common.Address]*StateObject

        dbErr  error  // dbErr is used for record the database error.
        refund uint64 // The refund counter, also used by state transitioning.

        // Receipt logs for current processed tx.
        curTxIndex uint
        curLogs    []*types.Log

        // State modifications for current processed tx.
        curJournal *journal
}

// NewStatedb constructs and returns a statedb instance
func NewStatedb(root common.Hash, db database.Database) (*Statedb, error) <span class="cov8" title="1">{
        trie, err := trie.NewTrie(root, []byte("S"), db)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Statedb{
                db:           db,
                trie:         trie,
                stateObjects: make(map[common.Address]*StateObject),
                curJournal:   newJournal(),
        }, nil</span>
}

// GetCopy is a memory copy of state db.
func (s *Statedb) GetCopy() (*Statedb, error) <span class="cov0" title="0">{
        copyObjecsFunc := func(src map[common.Address]*StateObject) map[common.Address]*StateObject </span><span class="cov0" title="0">{
                dest := make(map[common.Address]*StateObject)
                for k, v := range src </span><span class="cov0" title="0">{
                        dest[k] = v
                }</span>
                <span class="cov0" title="0">return dest</span>
        }

        <span class="cov0" title="0">cpyTrie, err := s.trie.ShallowCopy()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Statedb{
                db:           s.db,
                trie:         cpyTrie,
                stateObjects: copyObjecsFunc(s.stateObjects),

                dbErr:  s.dbErr,
                refund: s.refund,
        }, nil</span>
}

// setError only records the first error.
func (s *Statedb) setError(err error) <span class="cov0" title="0">{
        if s.dbErr == nil </span><span class="cov0" title="0">{
                s.dbErr = err
        }</span>
}

// GetBalance returns the balance of the specified account if exists.
// Otherwise, returns zero.
func (s *Statedb) GetBalance(addr common.Address) *big.Int <span class="cov8" title="1">{
        object := s.getStateObject(addr)
        if object != nil </span><span class="cov8" title="1">{
                return object.GetAmount()
        }</span>
        <span class="cov0" title="0">return stateBalance0</span>
}

// SetBalance sets the balance of the specified account
func (s *Statedb) SetBalance(addr common.Address, balance *big.Int) <span class="cov8" title="1">{
        object := s.getStateObject(addr)
        if object != nil </span><span class="cov8" title="1">{
                s.curJournal.append(balanceChange{&amp;addr, object.GetAmount()})
                object.SetAmount(balance)
        }</span>
}

// AddBalance adds the specified amount to the balance for the specified account
func (s *Statedb) AddBalance(addr common.Address, amount *big.Int) <span class="cov8" title="1">{
        object := s.getStateObject(addr)
        if object != nil </span><span class="cov8" title="1">{
                s.curJournal.append(balanceChange{&amp;addr, object.GetAmount()})
                object.AddAmount(amount)
        }</span>
}

// SubBalance substracts the specified amount from the balance for the specified account
func (s *Statedb) SubBalance(addr common.Address, amount *big.Int) <span class="cov8" title="1">{
        object := s.getStateObject(addr)
        if object != nil </span><span class="cov8" title="1">{
                s.curJournal.append(balanceChange{&amp;addr, object.GetAmount()})
                object.SubAmount(amount)
        }</span>
}

// GetNonce gets the nonce of the specified account
func (s *Statedb) GetNonce(addr common.Address) uint64 <span class="cov8" title="1">{
        object := s.getStateObject(addr)
        if object != nil </span><span class="cov8" title="1">{
                return object.GetNonce()
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// SetNonce sets the nonce of the specified account
func (s *Statedb) SetNonce(addr common.Address, nonce uint64) <span class="cov8" title="1">{
        object := s.getStateObject(addr)
        if object != nil </span><span class="cov8" title="1">{
                s.curJournal.append(nonceChange{&amp;addr, object.GetNonce()})
                object.SetNonce(nonce)
        }</span>
}

// Hash flush the dirty data into trie and calculates the intermediate root hash.
func (s *Statedb) Hash() (common.Hash, error) <span class="cov8" title="1">{
        if s.dbErr != nil </span><span class="cov0" title="0">{
                return common.EmptyHash, s.dbErr
        }</span>

        <span class="cov8" title="1">for addr := range s.curJournal.dirties </span><span class="cov8" title="1">{
                if object, found := s.stateObjects[addr]; found </span><span class="cov8" title="1">{
                        if err := object.commit(s.db, s.trie, nil); err != nil </span><span class="cov0" title="0">{
                                return common.EmptyHash, err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.clearJournalAndRefund()

        return s.trie.Hash(), nil</span>
}

// Commit persists the trie to the specified batch.
func (s *Statedb) Commit(batch database.Batch) (common.Hash, error) <span class="cov8" title="1">{
        if batch == nil </span><span class="cov0" title="0">{
                panic("batch is nil")</span>
        }

        <span class="cov8" title="1">if s.dbErr != nil </span><span class="cov0" title="0">{
                return common.EmptyHash, s.dbErr
        }</span>

        <span class="cov8" title="1">for _, object := range s.stateObjects </span><span class="cov8" title="1">{
                if err := object.commit(s.db, s.trie, batch); err != nil </span><span class="cov0" title="0">{
                        return common.EmptyHash, err
                }</span>
        }

        <span class="cov8" title="1">return s.trie.Commit(batch), nil</span>
}

// GetOrNewStateObject gets or creates a state object
func (s *Statedb) GetOrNewStateObject(addr common.Address) *StateObject <span class="cov8" title="1">{
        object := s.getStateObject(addr)
        if object == nil </span><span class="cov8" title="1">{
                object = newStateObject(addr)
                object.SetNonce(0)
                s.stateObjects[addr] = object
        }</span>

        <span class="cov8" title="1">return object</span>
}

func (s *Statedb) getStateObject(addr common.Address) *StateObject <span class="cov8" title="1">{
        if object, ok := s.stateObjects[addr]; ok </span><span class="cov8" title="1">{
                if !object.deleted </span><span class="cov8" title="1">{
                        return object
                }</span>

                // object has already been deleted from trie.
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">object := newStateObject(addr)
        val, _ := s.trie.Get(addr[:])
        if len(val) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := common.Deserialize(val, &amp;object.account); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">s.stateObjects[addr] = object
        return object</span>
}

// Prepare resets the logs and journal to process a new tx.
func (s *Statedb) Prepare(txIndex int) <span class="cov8" title="1">{
        s.curTxIndex = uint(txIndex)
        s.curLogs = nil

        s.clearJournalAndRefund()
}</span>

func (s *Statedb) clearJournalAndRefund() <span class="cov8" title="1">{
        s.refund = 0
        s.curJournal.entries = s.curJournal.entries[:0]
        s.curJournal.dirties = make(map[common.Address]uint)
}</span>

// GetCurrentLogs returns the current transaction logs.
func (s *Statedb) GetCurrentLogs() []*types.Log <span class="cov8" title="1">{
        return s.curLogs
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package state

import (
        "math/big"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/types"
)

// CreateAccount creates a new account in statedb.
func (s *Statedb) CreateAccount(address common.Address) <span class="cov8" title="1">{
        stateObj := s.getStateObject(address)
        if stateObj != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">stateObj = newStateObject(address)
        s.curJournal.append(createObjectChange{&amp;address})
        s.stateObjects[address] = stateObj</span>
}

// GetCodeHash returns the hash of the contract code associated with the specified address if any.
// Otherwise, return an empty hash.
func (s *Statedb) GetCodeHash(address common.Address) common.Hash <span class="cov8" title="1">{
        stateObj := s.getStateObject(address)
        if stateObj == nil </span><span class="cov8" title="1">{
                return common.EmptyHash
        }</span>

        <span class="cov8" title="1">return common.BytesToHash(stateObj.account.CodeHash)</span>
}

// GetCode returns the contract code associated with the specified address if any.
// Otherwise, return nil.
func (s *Statedb) GetCode(address common.Address) []byte <span class="cov8" title="1">{
        stateObj := s.getStateObject(address)
        if stateObj == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">code, err := stateObj.loadCode(s.db)
        if err != nil </span><span class="cov0" title="0">{
                s.setError(err)
                return nil
        }</span>

        <span class="cov8" title="1">return code</span>
}

// SetCode sets the contract code of the specified address if exists.
func (s *Statedb) SetCode(address common.Address, code []byte) <span class="cov8" title="1">{
        // EVM call SetCode after CreateAccount during contract creation.
        // So, here the retrieved stateObj should not be nil.
        stateObj := s.getStateObject(address)
        if stateObj == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">prevCode, err := stateObj.loadCode(s.db)
        if err != nil </span><span class="cov0" title="0">{
                s.setError(err)
                return
        }</span>

        <span class="cov8" title="1">s.curJournal.append(codeChange{&amp;address, prevCode})

        stateObj.setCode(code)</span>
}

// GetCodeSize returns the size of the contract code associated with the specified address if any.
// Otherwise, return 0.
func (s *Statedb) GetCodeSize(address common.Address) int <span class="cov8" title="1">{
        code := s.GetCode(address)
        return len(code)
}</span>

// AddRefund refunds the specified gas value
func (s *Statedb) AddRefund(gas uint64) <span class="cov8" title="1">{
        s.curJournal.append(refundChange{s.refund})
        s.refund += gas
}</span>

// GetRefund returns the current value of the refund counter.
func (s *Statedb) GetRefund() uint64 <span class="cov8" title="1">{
        return s.refund
}</span>

// GetState returns the value of the specified key in account storage if exists.
// Otherwise, return empty hash.
func (s *Statedb) GetState(address common.Address, key common.Hash) common.Hash <span class="cov8" title="1">{
        stateObj := s.getStateObject(address)
        if stateObj == nil </span><span class="cov0" title="0">{
                return common.EmptyHash
        }</span>

        <span class="cov8" title="1">value, err := stateObj.getState(s.db, key)
        if err != nil </span><span class="cov0" title="0">{
                s.setError(err)
                return common.EmptyHash
        }</span>

        <span class="cov8" title="1">return value</span>
}

// SetState adds or updates the specified key-value pair in account storage.
func (s *Statedb) SetState(address common.Address, key common.Hash, value common.Hash) <span class="cov8" title="1">{
        stateObj := s.getStateObject(address)
        if stateObj == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">prevValue, err := stateObj.getState(s.db, key)
        if err != nil </span><span class="cov0" title="0">{
                s.setError(err)
                return
        }</span>

        <span class="cov8" title="1">s.curJournal.append(storageChange{&amp;address, key, prevValue})

        stateObj.setState(key, value)</span>
}

// Suicide marks the given account as suicided and clears the account balance.
// Note the account's state object is still available until the state is committed.
// Return true if the specified account exists, otherwise false.
func (s *Statedb) Suicide(address common.Address) bool <span class="cov8" title="1">{
        stateObj := s.getStateObject(address)
        if stateObj == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">s.curJournal.append(suicideChange{&amp;address, stateObj.suicided, stateObj.GetAmount()})

        stateObj.SetAmount(new(big.Int))
        stateObj.suicided = true

        return true</span>
}

// HasSuicided returns true if the specified account exists and suicided, otherwise false.
func (s *Statedb) HasSuicided(address common.Address) bool <span class="cov8" title="1">{
        stateObj := s.getStateObject(address)
        if stateObj == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return stateObj.suicided</span>
}

// Exist indicates whether the given account exists in statedb.
// Note that it should also return true for suicided accounts.
func (s *Statedb) Exist(address common.Address) bool <span class="cov8" title="1">{
        return s.getStateObject(address) != nil
}</span>

// Empty indicates whether the given account satisfies (balance = nonce = code = 0).
func (s *Statedb) Empty(address common.Address) bool <span class="cov8" title="1">{
        stateObj := s.getStateObject(address)
        return stateObj == nil || stateObj.empty()
}</span>

// RevertToSnapshot reverts all state changes made since the given revision.
func (s *Statedb) RevertToSnapshot(revid int) <span class="cov8" title="1">{
        s.curJournal.revert(s, revid)
}</span>

// Snapshot returns an identifier for the current revision of the statedb.
func (s *Statedb) Snapshot() int <span class="cov8" title="1">{
        return s.curJournal.snapshot()
}</span>

// AddLog adds a log.
func (s *Statedb) AddLog(log *types.Log) <span class="cov8" title="1">{
        log.TxIndex = s.curTxIndex

        s.curLogs = append(s.curLogs, log)
}</span>

// AddPreimage records a SHA3 preimage seen by the VM.
func (s *Statedb) AddPreimage(common.Hash, []byte) {<span class="cov0" title="0">
        // Currently, do not support SHA3 preimage produced by EVM.
}</span>

// ForEachStorage visits all the key-value pairs for the specified account storage.
func (s *Statedb) ForEachStorage(common.Address, func(common.Hash, common.Hash) bool) {<span class="cov0" title="0">
        // do nothing, since ETH only call this method in test.
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package state

import (
        "math/big"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
        "github.com/seeleteam/go-seele/database"
        "github.com/seeleteam/go-seele/trie"
)

var (
        keyPrefixCode   = []byte("code")
        dbPrefixStorage = []byte("s")
)

// Account is a balance model for blockchain
type Account struct {
        Nonce           uint64
        Amount          *big.Int
        CodeHash        []byte // contract code hash
        StorageRootHash []byte // merkle root of the storage trie
}

func newAccount() Account <span class="cov8" title="1">{
        return Account{
                Amount: new(big.Int),
        }
}</span>

func (a Account) clone() Account <span class="cov8" title="1">{
        return Account{
                Nonce:           a.Nonce,
                Amount:          new(big.Int).Set(a.Amount),
                CodeHash:        common.CopyBytes(a.CodeHash),
                StorageRootHash: common.CopyBytes(a.StorageRootHash),
        }
}</span>

// StateObject is the state object for statedb
type StateObject struct {
        address  common.Address
        addrHash common.Hash

        account      Account
        dirtyAccount bool

        code      []byte // contract code
        dirtyCode bool

        storageTrie      *trie.Trie
        cachedStorage    map[common.Hash]common.Hash // cache the retrieved account states.
        dirtyStorage     map[common.Hash]common.Hash // changed account states that need to flush to DB.
        storageTrieDirty bool

        // When a state object is marked as suicided, it will be deleted from the trie when commit the state DB.
        suicided bool

        // When a state object is marked as deleted, need not to load from trie again.
        deleted bool
}

func newStateObject(address common.Address) *StateObject <span class="cov8" title="1">{
        return &amp;StateObject{
                address:       address,
                addrHash:      crypto.HashBytes(address.Bytes()),
                account:       newAccount(),
                dirtyAccount:  true,
                cachedStorage: make(map[common.Hash]common.Hash),
                dirtyStorage:  make(map[common.Hash]common.Hash),
        }
}</span>

// GetCopy gets a copy of the state object
func (s *StateObject) GetCopy() *StateObject <span class="cov8" title="1">{
        cloned := *s

        cloned.account = s.account.clone()
        cloned.code = common.CopyBytes(s.code)
        cloned.cachedStorage = copyStorage(s.cachedStorage)
        cloned.dirtyStorage = copyStorage(s.dirtyStorage)

        return &amp;cloned
}</span>

func copyStorage(src map[common.Hash]common.Hash) map[common.Hash]common.Hash <span class="cov8" title="1">{
        cloned := make(map[common.Hash]common.Hash)

        for k, v := range src </span><span class="cov8" title="1">{
                cloned[k] = v
        }</span>

        <span class="cov8" title="1">return cloned</span>
}

// SetNonce sets the nonce of the account in the state object
func (s *StateObject) SetNonce(nonce uint64) <span class="cov8" title="1">{
        s.account.Nonce = nonce
        s.dirtyAccount = true
}</span>

// GetNonce gets the nonce of the account in the state object
func (s *StateObject) GetNonce() uint64 <span class="cov8" title="1">{
        return s.account.Nonce
}</span>

// GetAmount gets the balance amount of the account in the state object
func (s *StateObject) GetAmount() *big.Int <span class="cov8" title="1">{
        return new(big.Int).Set(s.account.Amount)
}</span>

// SetAmount sets the balance amount of the account in the state object
func (s *StateObject) SetAmount(amount *big.Int) <span class="cov8" title="1">{
        if amount.Sign() &gt;= 0 </span><span class="cov8" title="1">{
                s.account.Amount.Set(amount)
                s.dirtyAccount = true
        }</span>
}

// AddAmount adds the specified amount to the balance of the account in the state object
func (s *StateObject) AddAmount(amount *big.Int) <span class="cov8" title="1">{
        s.SetAmount(new(big.Int).Add(s.account.Amount, amount))
}</span>

// SubAmount substracts the specified amount from the balance of the account in the state object
func (s *StateObject) SubAmount(amount *big.Int) <span class="cov8" title="1">{
        s.SetAmount(new(big.Int).Sub(s.account.Amount, amount))
}</span>

func (s *StateObject) loadCode(db database.Database) ([]byte, error) <span class="cov8" title="1">{
        if s.code != nil </span><span class="cov8" title="1">{
                return s.code, nil
        }</span>

        <span class="cov8" title="1">if len(s.account.CodeHash) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">code, err := db.Get(s.getCodeKey())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.code = code

        return code, nil</span>
}

func (s *StateObject) getCodeKey() []byte <span class="cov8" title="1">{
        return append(keyPrefixCode, s.addrHash.Bytes()...)
}</span>

func (s *StateObject) setCode(code []byte) <span class="cov8" title="1">{
        s.code = code
        s.dirtyCode = true

        if len(code) == 0 </span><span class="cov8" title="1">{
                s.account.CodeHash = nil
        }</span><span class="cov8" title="1"> else {
                s.account.CodeHash = crypto.HashBytes(code).Bytes()
        }</span>
        <span class="cov8" title="1">s.dirtyAccount = true</span>
}

func (s *StateObject) serializeCode(batch database.Batch) <span class="cov8" title="1">{
        if len(s.code) &gt; 0 </span><span class="cov8" title="1">{
                batch.Put(s.getCodeKey(), s.code)
        }</span>
}

// empty returns whether the account is considered empty (nonce == amount == 0 and no code).
// This is used during EVM execution.
func (s *StateObject) empty() bool <span class="cov0" title="0">{
        return s.account.Nonce == 0 &amp;&amp; s.account.Amount.Sign() == 0 &amp;&amp; len(s.account.CodeHash) == 0
}</span>

func (s *StateObject) setState(key, value common.Hash) <span class="cov8" title="1">{
        s.cachedStorage[key] = value

        if old, ok := s.dirtyStorage[key]; !ok || !old.Equal(value) </span><span class="cov8" title="1">{
                s.dirtyStorage[key] = value
        }</span>
}

func (s *StateObject) getState(db database.Database, key common.Hash) (common.Hash, error) <span class="cov8" title="1">{
        if value, ok := s.cachedStorage[key]; ok </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        <span class="cov8" title="1">if err := s.ensureStorageTrie(db); err != nil </span><span class="cov0" title="0">{
                return common.EmptyHash, err
        }</span>

        <span class="cov8" title="1">if value, ok := s.storageTrie.Get(s.getStorageKey(key)); ok </span><span class="cov8" title="1">{
                return common.BytesToHash(value), nil
        }</span>

        <span class="cov8" title="1">return common.EmptyHash, nil</span>
}

func (s *StateObject) ensureStorageTrie(db database.Database) error <span class="cov8" title="1">{
        if s.storageTrie != nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">rootHash := common.EmptyHash
        if len(s.account.StorageRootHash) &gt; 0 </span><span class="cov8" title="1">{
                rootHash = common.BytesToHash(s.account.StorageRootHash)
        }</span>

        <span class="cov8" title="1">trie, err := trie.NewTrie(rootHash, dbPrefixStorage, db)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.storageTrie = trie

        return nil</span>
}

func (s *StateObject) getStorageKey(key common.Hash) []byte <span class="cov8" title="1">{
        // trie key: address hash + storage key
        return append(s.addrHash.Bytes(), key.Bytes()...)
}</span>

// commitStorageTrie flush dirty storage to trie if any, and update the storage merkle root hash.
func (s *StateObject) commitStorageTrie(trieDB database.Database, commitBatch database.Batch) error <span class="cov8" title="1">{
        // not dirty and do not persist storage trie
        if len(s.dirtyStorage) == 0 &amp;&amp; (commitBatch == nil || !s.storageTrieDirty) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := s.ensureStorageTrie(trieDB); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // flush dirty storage into trie if any dirty
        <span class="cov8" title="1">for k, v := range s.dirtyStorage </span><span class="cov8" title="1">{
                if err := s.storageTrie.Put(s.getStorageKey(k), v.Bytes()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">s.storageTrieDirty = true</span>
        }

        // set account as dirty if dirty and reset dirty storage cache
        <span class="cov8" title="1">if len(s.dirtyStorage) &gt; 0 </span><span class="cov8" title="1">{
                s.dirtyAccount = true
                s.dirtyStorage = make(map[common.Hash]common.Hash)
        }</span>

        // commit to update the storage root hash or persist the storage trie to DB
        <span class="cov8" title="1">s.account.StorageRootHash = s.storageTrie.Commit(commitBatch).Bytes()

        if commitBatch != nil </span><span class="cov8" title="1">{
                s.storageTrieDirty = false
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// commit flush dirty data of state object to the specified db and trie if any.
func (s *StateObject) commit(storageTrieDB database.Database, trie *trie.Trie, batch database.Batch) error <span class="cov8" title="1">{
        // Commit storage change.
        if err := s.commitStorageTrie(storageTrieDB, batch); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Commit code change.
        <span class="cov8" title="1">if s.dirtyCode &amp;&amp; batch != nil </span><span class="cov8" title="1">{
                s.serializeCode(batch)
                s.dirtyCode = false
        }</span>

        // Commit account info change.
        <span class="cov8" title="1">if s.dirtyAccount </span><span class="cov8" title="1">{
                data := common.SerializePanic(s.account)
                trie.Put(s.address.Bytes(), data)
                s.dirtyAccount = false
        }</span>

        // Remove the account from state DB if suicided.
        <span class="cov8" title="1">if s.suicided &amp;&amp; !s.deleted </span><span class="cov8" title="1">{
                s.deleted = true
                trie.Delete(s.address.Bytes())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package store

import (
        "math/big"

        "github.com/hashicorp/golang-lru"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/types"
)

const (
        hashCacheSize   = 1024 // maximum 40K
        headerCacheSize = 512  // maximum 100K
        tdCacheSize     = 1024 // maximum 64K
        blockCacheSize  = 64   // maximum 64M
)

// cachedStore is used to cache recent accessed data to avoid frequent data deserialization.
type cachedStore struct {
        raw BlockchainStore

        hashCache   *lru.Cache // canonical blockchain height to hash cache.
        headerCache *lru.Cache // block hash to header cache.
        tdCache     *lru.Cache // block hash to total difficulty cache.
        blockCache  *lru.Cache // block hash to block cache.
}

// NewCachedStore returns a cached blockchainDatabase instance based on LRU.
func NewCachedStore(store BlockchainStore) BlockchainStore <span class="cov8" title="1">{
        return &amp;cachedStore{
                raw:         store,
                hashCache:   common.MustNewCache(hashCacheSize),
                headerCache: common.MustNewCache(headerCacheSize),
                tdCache:     common.MustNewCache(tdCacheSize),
                blockCache:  common.MustNewCache(blockCacheSize),
        }
}</span>

// GetBlockHash retrieves the block hash for the specified canonical block height.
func (store *cachedStore) GetBlockHash(height uint64) (common.Hash, error) <span class="cov8" title="1">{
        if hash, found := store.hashCache.Get(height); found </span><span class="cov8" title="1">{
                return hash.(common.Hash), nil
        }</span>

        <span class="cov8" title="1">hash, err := store.raw.GetBlockHash(height)
        if err == nil </span><span class="cov8" title="1">{
                store.hashCache.Add(height, hash)
        }</span>

        <span class="cov8" title="1">return hash, err</span>
}

// PutBlockHash writes the height-to-blockHash entry in the canonical chain.
func (store *cachedStore) PutBlockHash(height uint64, hash common.Hash) error <span class="cov8" title="1">{
        err := store.raw.PutBlockHash(height, hash)
        if err == nil </span><span class="cov8" title="1">{
                store.hashCache.Add(height, hash)
        }</span>

        <span class="cov8" title="1">return err</span>
}

// DeleteBlockHash deletes the block hash of the specified canonical block height.
func (store *cachedStore) DeleteBlockHash(height uint64) (bool, error) <span class="cov8" title="1">{
        store.hashCache.Remove(height)
        return store.raw.DeleteBlockHash(height)
}</span>

// GetHeadBlockHash retrieves the HEAD block hash.
func (store *cachedStore) GetHeadBlockHash() (common.Hash, error) <span class="cov0" title="0">{
        return store.raw.GetHeadBlockHash()
}</span>

// PutHeadBlockHash writes the HEAD block hash into the store.
func (store *cachedStore) PutHeadBlockHash(hash common.Hash) error <span class="cov0" title="0">{
        return store.raw.PutHeadBlockHash(hash)
}</span>

// GetBlockHeader retrieves the block header for the specified block hash.
func (store *cachedStore) GetBlockHeader(hash common.Hash) (*types.BlockHeader, error) <span class="cov8" title="1">{
        if header, found := store.headerCache.Get(hash); found </span><span class="cov8" title="1">{
                return header.(*types.BlockHeader), nil
        }</span>

        <span class="cov8" title="1">header, err := store.raw.GetBlockHeader(hash)
        if err == nil </span><span class="cov8" title="1">{
                store.headerCache.Add(hash, header)
        }</span>

        <span class="cov8" title="1">return header, err</span>
}

// PutBlockHeader serializes a block header with the specified total difficulty (td) into the store.
// The input parameter isHead indicates if the header is a HEAD block header.
func (store *cachedStore) PutBlockHeader(hash common.Hash, header *types.BlockHeader, td *big.Int, isHead bool) error <span class="cov8" title="1">{
        err := store.raw.PutBlockHeader(hash, header, td, isHead)
        if err == nil </span><span class="cov8" title="1">{
                store.headerCache.Add(hash, header)
                store.tdCache.Add(hash, td)

                if isHead </span><span class="cov8" title="1">{
                        store.hashCache.Add(header.Height, hash)
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

// GetBlockTotalDifficulty retrieves a block's total difficulty for the specified block hash.
func (store *cachedStore) GetBlockTotalDifficulty(hash common.Hash) (*big.Int, error) <span class="cov8" title="1">{
        if td, found := store.tdCache.Get(hash); found </span><span class="cov8" title="1">{
                return td.(*big.Int), nil
        }</span>

        <span class="cov8" title="1">td, err := store.raw.GetBlockTotalDifficulty(hash)
        if err == nil </span><span class="cov8" title="1">{
                store.tdCache.Add(hash, td)
        }</span>

        <span class="cov8" title="1">return td, err</span>
}

// PutBlock serializes the given block with the given total difficulty (td) into the store.
// The input parameter isHead indicates if the given block is a HEAD block.
func (store *cachedStore) PutBlock(block *types.Block, td *big.Int, isHead bool) error <span class="cov8" title="1">{
        err := store.raw.PutBlock(block, td, isHead)
        if err == nil </span><span class="cov8" title="1">{
                store.headerCache.Add(block.HeaderHash, block.Header)
                store.tdCache.Add(block.HeaderHash, td)
                store.blockCache.Add(block.HeaderHash, block)

                if isHead </span><span class="cov8" title="1">{
                        store.hashCache.Add(block.Header.Height, block.HeaderHash)
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

// GetBlock retrieves the block for the specified block hash.
func (store *cachedStore) GetBlock(hash common.Hash) (*types.Block, error) <span class="cov8" title="1">{
        if block, found := store.blockCache.Get(hash); found </span><span class="cov8" title="1">{
                return block.(*types.Block), nil
        }</span>

        <span class="cov8" title="1">block, err := store.raw.GetBlock(hash)
        if err == nil </span><span class="cov8" title="1">{
                store.blockCache.Add(hash, block)
        }</span>

        <span class="cov8" title="1">return block, err</span>
}

// HasBlock checks if the block with the specified hash exists.
func (store *cachedStore) HasBlock(hash common.Hash) (bool, error) <span class="cov0" title="0">{
        if store.headerCache.Contains(hash) </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov0" title="0">return store.raw.HasBlock(hash)</span>
}

// DeleteBlock deletes the block of the specified block hash.
func (store *cachedStore) DeleteBlock(hash common.Hash) error <span class="cov8" title="1">{
        // remove height-to-hash cache in canonical chain.
        header, err := store.raw.GetBlockHeader(hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">canonicalHash, err := store.GetBlockHash(header.Height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if canonicalHash.Equal(hash) </span><span class="cov8" title="1">{
                store.hashCache.Remove(header.Height)
        }</span>

        // remove other caches: header, td and block
        <span class="cov8" title="1">store.headerCache.Remove(hash)
        store.tdCache.Remove(hash)
        store.blockCache.Remove(hash)

        return store.raw.DeleteBlock(hash)</span>
}

// GetBlockByHeight retrieves the block for the specified block height.
func (store *cachedStore) GetBlockByHeight(height uint64) (*types.Block, error) <span class="cov0" title="0">{
        return store.raw.GetBlockByHeight(height)
}</span>

// PutReceipts serializes given receipts for the specified block hash.
func (store *cachedStore) PutReceipts(hash common.Hash, receipts []*types.Receipt) error <span class="cov0" title="0">{
        return store.raw.PutReceipts(hash, receipts)
}</span>

// GetReceiptsByBlockHash retrieves the receipts for the specified block hash.
func (store *cachedStore) GetReceiptsByBlockHash(hash common.Hash) ([]*types.Receipt, error) <span class="cov0" title="0">{
        return store.raw.GetReceiptsByBlockHash(hash)
}</span>

// GetReceiptByTxHash retrieves the receipt for the specified tx hash.
func (store *cachedStore) GetReceiptByTxHash(txHash common.Hash) (*types.Receipt, error) <span class="cov0" title="0">{
        return store.raw.GetReceiptByTxHash(txHash)
}</span>

// GetTxIndex retrieves the tx index for the specified tx hash.
func (store *cachedStore) GetTxIndex(txHash common.Hash) (*types.TxIndex, error) <span class="cov0" title="0">{
        return store.raw.GetTxIndex(txHash)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package store

import (
        "encoding/binary"
        "fmt"
        "math/big"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/database"
)

var (
        keyHeadBlockHash = []byte("HeadBlockHash")

        keyPrefixHash     = []byte("H")
        keyPrefixHeader   = []byte("h")
        keyPrefixTD       = []byte("t")
        keyPrefixBody     = []byte("b")
        keyPrefixReceipts = []byte("r")
        keyPrefixTxIndex  = []byte("i")
)

// blockBody represents the payload of a block
type blockBody struct {
        Txs []*types.Transaction // Txs is a transaction collection
}

// blockchainDatabase wraps a database used for the blockchain
type blockchainDatabase struct {
        db database.Database
}

// NewBlockchainDatabase returns a blockchainDatabase instance.
// There are following mappings in database:
//   1) keyPrefixHash + height =&gt; hash
//   2) keyHeadBlockHash =&gt; HEAD hash
//   3) keyPrefixHeader + hash =&gt; header
//   4) keyPrefixTD + hash =&gt; total difficulty (td for short)
//   5) keyPrefixBody + hash =&gt; block body (transactions)
//   6) keyPrefixReceipts + hash =&gt; block receipts
//   7) keyPrefixTxIndex + txHash =&gt; txIndex
func NewBlockchainDatabase(db database.Database) BlockchainStore <span class="cov8" title="1">{
        return &amp;blockchainDatabase{db}
}</span>

func heightToHashKey(height uint64) []byte  <span class="cov8" title="1">{ return append(keyPrefixHash, encodeBlockHeight(height)...) }</span>
func hashToHeaderKey(hash []byte) []byte    <span class="cov8" title="1">{ return append(keyPrefixHeader, hash...) }</span>
func hashToTDKey(hash []byte) []byte        <span class="cov8" title="1">{ return append(keyPrefixTD, hash...) }</span>
func hashToBodyKey(hash []byte) []byte      <span class="cov8" title="1">{ return append(keyPrefixBody, hash...) }</span>
func hashToReceiptsKey(hash []byte) []byte  <span class="cov8" title="1">{ return append(keyPrefixReceipts, hash...) }</span>
func txHashToIndexKey(txHash []byte) []byte <span class="cov8" title="1">{ return append(keyPrefixTxIndex, txHash...) }</span>

// GetBlockHash gets the hash of the block with the specified height in the blockchain database
func (store *blockchainDatabase) GetBlockHash(height uint64) (common.Hash, error) <span class="cov8" title="1">{
        hashBytes, err := store.db.Get(heightToHashKey(height))
        if err != nil </span><span class="cov8" title="1">{
                return common.EmptyHash, err
        }</span>

        <span class="cov8" title="1">return common.BytesToHash(hashBytes), nil</span>
}

// PutBlockHash puts the given block height which is encoded as the key
// and hash as the value to the blockchain database.
func (store *blockchainDatabase) PutBlockHash(height uint64, hash common.Hash) error <span class="cov8" title="1">{
        return store.db.Put(heightToHashKey(height), hash.Bytes())
}</span>

// DeleteBlockHash deletes the block hash mapped to by the specified height from the blockchain database
func (store *blockchainDatabase) DeleteBlockHash(height uint64) (bool, error) <span class="cov8" title="1">{
        key := heightToHashKey(height)

        found, err := store.db.Has(key)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if err = store.db.Delete(key); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

// encodeBlockHeight encodes a block height as big endian uint64
func encodeBlockHeight(height uint64) []byte <span class="cov8" title="1">{
        encoded := make([]byte, 8)
        binary.BigEndian.PutUint64(encoded, height)
        return encoded
}</span>

// GetHeadBlockHash gets the HEAD block hash in the blockchain database
func (store *blockchainDatabase) GetHeadBlockHash() (common.Hash, error) <span class="cov8" title="1">{
        hashBytes, err := store.db.Get(keyHeadBlockHash)
        if err != nil </span><span class="cov0" title="0">{
                return common.EmptyHash, err
        }</span>

        <span class="cov8" title="1">return common.BytesToHash(hashBytes), nil</span>
}

// PutHeadBlockHash writes the HEAD block hash into the store.
func (store *blockchainDatabase) PutHeadBlockHash(hash common.Hash) error <span class="cov8" title="1">{
        return store.db.Put(keyHeadBlockHash, hash.Bytes())
}</span>

// GetBlockHeader gets the header of the block with the specified hash in the blockchain database
func (store *blockchainDatabase) GetBlockHeader(hash common.Hash) (*types.BlockHeader, error) <span class="cov8" title="1">{
        headerBytes, err := store.db.Get(hashToHeaderKey(hash.Bytes()))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">header := new(types.BlockHeader)
        if err := common.Deserialize(headerBytes, header); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return header, nil</span>
}

// HasBlock indicates if the block with the specified hash exists in the blockchain database
func (store *blockchainDatabase) HasBlock(hash common.Hash) (bool, error) <span class="cov8" title="1">{
        key := hashToHeaderKey(hash.Bytes())

        found, err := store.db.Has(key)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return found, nil</span>
}

// PutBlockHeader serializes the given block header of the block with the specified hash
// and total difficulty into the blockchain database.
// isHead indicates if the given header is the HEAD block header
func (store *blockchainDatabase) PutBlockHeader(hash common.Hash, header *types.BlockHeader, td *big.Int, isHead bool) error <span class="cov8" title="1">{
        return store.putBlockInternal(hash, header, nil, td, isHead)
}</span>

func (store *blockchainDatabase) putBlockInternal(hash common.Hash, header *types.BlockHeader, body *blockBody, td *big.Int, isHead bool) error <span class="cov8" title="1">{
        if header == nil </span><span class="cov0" title="0">{
                panic("header is nil")</span>
        }

        <span class="cov8" title="1">headerBytes := common.SerializePanic(header)

        hashBytes := hash.Bytes()

        batch := store.db.NewBatch()
        batch.Put(hashToHeaderKey(hashBytes), headerBytes)
        batch.Put(hashToTDKey(hashBytes), common.SerializePanic(td))

        if body != nil </span><span class="cov8" title="1">{
                batch.Put(hashToBodyKey(hashBytes), common.SerializePanic(body))

                // Write index for each tx.
                for i, tx := range body.Txs </span><span class="cov8" title="1">{
                        idx := types.TxIndex{BlockHash: hash, Index: uint(i)}
                        encodedTxIndex := common.SerializePanic(idx)
                        batch.Put(txHashToIndexKey(tx.Hash.Bytes()), encodedTxIndex)
                }</span>
        }

        <span class="cov8" title="1">if isHead </span><span class="cov8" title="1">{
                batch.Put(heightToHashKey(header.Height), hashBytes)
                batch.Put(keyHeadBlockHash, hashBytes)
        }</span>

        <span class="cov8" title="1">return batch.Commit()</span>
}

// GetBlockTotalDifficulty gets the total difficulty of the block with the specified hash in the blockchain database
func (store *blockchainDatabase) GetBlockTotalDifficulty(hash common.Hash) (*big.Int, error) <span class="cov8" title="1">{
        tdBytes, err := store.db.Get(hashToTDKey(hash.Bytes()))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">td := new(big.Int)
        if err = common.Deserialize(tdBytes, td); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return td, nil</span>
}

// PutBlock serializes the given block with the specified total difficulty into the blockchain database.
// isHead indicates if the block is the header block
func (store *blockchainDatabase) PutBlock(block *types.Block, td *big.Int, isHead bool) error <span class="cov8" title="1">{
        if block == nil </span><span class="cov8" title="1">{
                panic("block is nil")</span>
        }

        <span class="cov8" title="1">return store.putBlockInternal(block.HeaderHash, block.Header, &amp;blockBody{block.Transactions}, td, isHead)</span>
}

// GetBlock gets the block with the specified hash in the blockchain database
func (store *blockchainDatabase) GetBlock(hash common.Hash) (*types.Block, error) <span class="cov8" title="1">{
        header, err := store.GetBlockHeader(hash)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">bodyKey := hashToBodyKey(hash.Bytes())
        hasBody, err := store.db.Has(bodyKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !hasBody </span><span class="cov0" title="0">{
                return &amp;types.Block{
                        HeaderHash: hash,
                        Header:     header,
                }, nil
        }</span>

        <span class="cov8" title="1">bodyBytes, err := store.db.Get(bodyKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">body := blockBody{}
        if err := common.Deserialize(bodyBytes, &amp;body); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.Block{
                HeaderHash:   hash,
                Header:       header,
                Transactions: body.Txs,
        }, nil</span>
}

// DeleteBlock deletes the block of the specified block hash.
func (store *blockchainDatabase) DeleteBlock(hash common.Hash) error <span class="cov8" title="1">{
        hashBytes := hash.Bytes()
        batch := store.db.NewBatch()

        // delete header, TD and receipts if any.
        headerKey := hashToHeaderKey(hashBytes)
        tdKey := hashToTDKey(hashBytes)
        receiptsKey := hashToReceiptsKey(hashBytes)
        if err := store.delete(batch, headerKey, tdKey, receiptsKey); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // get body for more deletion
        <span class="cov8" title="1">bodyKey := hashToBodyKey(hashBytes)
        found, err := store.db.Has(bodyKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                return batch.Commit()
        }</span>

        <span class="cov8" title="1">encodedBody, err := store.db.Get(bodyKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var body blockBody
        if err = common.Deserialize(encodedBody, &amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // delete all tx index in block
        <span class="cov8" title="1">for _, tx := range body.Txs </span><span class="cov8" title="1">{
                if err = store.delete(batch, txHashToIndexKey(tx.Hash.Bytes())); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // delete body
        <span class="cov8" title="1">batch.Delete(bodyKey)

        return batch.Commit()</span>
}

func (store *blockchainDatabase) delete(batch database.Batch, keys ...[]byte) error <span class="cov8" title="1">{
        for _, k := range keys </span><span class="cov8" title="1">{
                found, err := store.db.Has(k)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                        batch.Delete(k)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetBlockByHeight gets the block with the specified height in the blockchain database
func (store *blockchainDatabase) GetBlockByHeight(height uint64) (*types.Block, error) <span class="cov8" title="1">{
        hash, err := store.GetBlockHash(height)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">block, err := store.GetBlock(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return block, nil</span>
}

// PutReceipts serializes given receipts for the specified block hash.
func (store *blockchainDatabase) PutReceipts(hash common.Hash, receipts []*types.Receipt) error <span class="cov8" title="1">{
        encodedBytes, err := common.Serialize(receipts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">key := hashToReceiptsKey(hash.Bytes())

        return store.db.Put(key, encodedBytes)</span>
}

// GetReceiptsByBlockHash retrieves the receipts for the specified block hash.
func (store *blockchainDatabase) GetReceiptsByBlockHash(hash common.Hash) ([]*types.Receipt, error) <span class="cov8" title="1">{
        key := hashToReceiptsKey(hash.Bytes())
        encodedBytes, err := store.db.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">receipts := make([]*types.Receipt, 0)
        if err := common.Deserialize(encodedBytes, &amp;receipts); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return receipts, nil</span>
}

// GetReceiptByTxHash retrieves the receipt for the specified tx hash.
func (store *blockchainDatabase) GetReceiptByTxHash(txHash common.Hash) (*types.Receipt, error) <span class="cov8" title="1">{
        txIndex, err := store.GetTxIndex(txHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">receipts, err := store.GetReceiptsByBlockHash(txIndex.BlockHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if uint(len(receipts)) &lt;= txIndex.Index </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid tx index, txIndex = %v, receiptsLen = %v", *txIndex, len(receipts))
        }</span>

        <span class="cov8" title="1">return receipts[txIndex.Index], nil</span>
}

// GetTxIndex retrieves the tx index for the specified tx hash.
func (store *blockchainDatabase) GetTxIndex(txHash common.Hash) (*types.TxIndex, error) <span class="cov8" title="1">{
        data, err := store.db.Get(txHashToIndexKey(txHash.Bytes()))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">index := &amp;types.TxIndex{}
        if err := common.Deserialize(data, index); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return index, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package store

import (
        "errors"
        "math/big"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/types"
        leveldbErrors "github.com/syndtr/goleveldb/leveldb/errors"
)

var errNotFound = leveldbErrors.ErrNotFound
var ErrDBCorrupt = errors.New("db corrupted")

type memBlock struct {
        td       *big.Int
        block    *types.Block
        receipts []*types.Receipt
}

// MemStore prepresents a in-memory database that used for the blockchain.
type MemStore struct {
        CanonicalBlocks map[uint64]common.Hash // height to block hash map in canonical chain
        HeadBlockHash   common.Hash            // HEAD block hash
        Blocks          map[common.Hash]*memBlock
        TxLookups       map[common.Hash]types.TxIndex // tx hash to index mapping

        CorruptOnPutBlock bool // used to test blockchain recovery if program crashed
}

func NewMemStore() *MemStore <span class="cov8" title="1">{
        return &amp;MemStore{
                CanonicalBlocks: make(map[uint64]common.Hash),
                Blocks:          make(map[common.Hash]*memBlock),
                TxLookups:       make(map[common.Hash]types.TxIndex),
        }
}</span>

func (store *MemStore) GetBlockHash(height uint64) (common.Hash, error) <span class="cov8" title="1">{
        hash, found := store.CanonicalBlocks[height]
        if found </span><span class="cov8" title="1">{
                return hash, nil
        }</span>

        <span class="cov8" title="1">return common.EmptyHash, errNotFound</span>
}

func (store *MemStore) PutBlockHash(height uint64, hash common.Hash) error <span class="cov8" title="1">{
        store.CanonicalBlocks[height] = hash
        return nil
}</span>

func (store *MemStore) DeleteBlockHash(height uint64) (bool, error) <span class="cov8" title="1">{
        if _, found := store.CanonicalBlocks[height]; !found </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">delete(store.CanonicalBlocks, height)
        return true, nil</span>
}

func (store *MemStore) GetHeadBlockHash() (common.Hash, error) <span class="cov0" title="0">{
        return store.HeadBlockHash, nil
}</span>

func (store *MemStore) PutHeadBlockHash(hash common.Hash) error <span class="cov0" title="0">{
        store.HeadBlockHash = hash
        return nil
}</span>

func (store *MemStore) GetBlockHeader(hash common.Hash) (*types.BlockHeader, error) <span class="cov8" title="1">{
        block := store.Blocks[hash]
        if block == nil </span><span class="cov8" title="1">{
                return nil, errNotFound
        }</span>

        <span class="cov8" title="1">return block.block.Header, nil</span>
}

func (store *MemStore) PutBlockHeader(hash common.Hash, header *types.BlockHeader, td *big.Int, isHead bool) error <span class="cov8" title="1">{
        block := &amp;types.Block{
                Header:     header,
                HeaderHash: header.Hash(),
        }

        store.Blocks[hash] = &amp;memBlock{
                block: block,
                td:    td,
        }

        if isHead </span><span class="cov8" title="1">{
                store.CanonicalBlocks[header.Height] = hash
                store.HeadBlockHash = hash
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (store *MemStore) GetBlockTotalDifficulty(hash common.Hash) (*big.Int, error) <span class="cov8" title="1">{
        block := store.Blocks[hash]
        if block == nil </span><span class="cov8" title="1">{
                return nil, errNotFound
        }</span>

        <span class="cov8" title="1">return block.td, nil</span>
}

func (store *MemStore) PutBlock(block *types.Block, td *big.Int, isHead bool) error <span class="cov8" title="1">{
        storedBlock := store.Blocks[block.HeaderHash]
        if storedBlock == nil </span><span class="cov8" title="1">{
                storedBlock = &amp;memBlock{
                        td:    td,
                        block: block,
                }
        }</span><span class="cov0" title="0"> else {
                storedBlock.block = block
                storedBlock.td = td
        }</span>

        <span class="cov8" title="1">store.Blocks[block.HeaderHash] = storedBlock

        if store.CorruptOnPutBlock </span><span class="cov0" title="0">{
                return ErrDBCorrupt
        }</span>

        <span class="cov8" title="1">for i, tx := range block.Transactions </span><span class="cov8" title="1">{
                store.TxLookups[tx.Hash] = types.TxIndex{BlockHash: block.HeaderHash, Index: uint(i)}
        }</span>

        <span class="cov8" title="1">if isHead </span><span class="cov8" title="1">{
                store.CanonicalBlocks[block.Header.Height] = block.HeaderHash
                store.HeadBlockHash = block.HeaderHash
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (store *MemStore) GetBlock(hash common.Hash) (*types.Block, error) <span class="cov8" title="1">{
        if block := store.Blocks[hash]; block != nil </span><span class="cov8" title="1">{
                return block.block, nil
        }</span>

        <span class="cov8" title="1">return nil, errNotFound</span>
}

func (store *MemStore) HasBlock(hash common.Hash) (bool, error) <span class="cov0" title="0">{
        return store.Blocks[hash] != nil, nil
}</span>

func (store *MemStore) DeleteBlock(hash common.Hash) error <span class="cov8" title="1">{
        if block := store.Blocks[hash]; block != nil </span><span class="cov8" title="1">{
                for _, tx := range block.block.Transactions </span><span class="cov8" title="1">{
                        delete(store.TxLookups, tx.Hash)
                }</span>
        }

        <span class="cov8" title="1">delete(store.Blocks, hash)

        return nil</span>
}

func (store *MemStore) GetBlockByHeight(height uint64) (*types.Block, error) <span class="cov0" title="0">{
        hash, err := store.GetBlockHash(height)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return store.GetBlock(hash)</span>
}

func (store *MemStore) PutReceipts(hash common.Hash, receipts []*types.Receipt) error <span class="cov0" title="0">{
        block := store.Blocks[hash]
        if block == nil </span><span class="cov0" title="0">{
                block = &amp;memBlock{}
                store.Blocks[hash] = block
        }</span>

        <span class="cov0" title="0">block.receipts = receipts

        return nil</span>
}

func (store *MemStore) GetReceiptsByBlockHash(hash common.Hash) ([]*types.Receipt, error) <span class="cov0" title="0">{
        block := store.Blocks[hash]
        if block == nil </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>

        <span class="cov0" title="0">return block.receipts, nil</span>
}

func (store *MemStore) GetReceiptByTxHash(txHash common.Hash) (*types.Receipt, error) <span class="cov0" title="0">{
        txIndex, found := store.TxLookups[txHash]
        if !found </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>

        <span class="cov0" title="0">receipts, err := store.GetReceiptsByBlockHash(txIndex.BlockHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if uint(len(receipts)) &lt;= txIndex.Index </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>

        <span class="cov0" title="0">return receipts[txIndex.Index], nil</span>
}

func (store *MemStore) GetTxIndex(txHash common.Hash) (*types.TxIndex, error) <span class="cov0" title="0">{
        txIndex, found := store.TxLookups[txHash]
        if !found </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>

        <span class="cov0" title="0">return &amp;txIndex, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

import (
        "container/heap"
        "sort"

        "github.com/seeleteam/go-seele/core/types"
)

type heapItem struct {
        heapIndex int // used to randomly remove an item from heap.
}

type txHeapByNonce []*pooledTx

func (h txHeapByNonce) Len() int <span class="cov8" title="1">{
        return len(h)
}</span>

func (h txHeapByNonce) Less(i, j int) bool <span class="cov8" title="1">{
        return h[i].Data.AccountNonce &lt; h[j].Data.AccountNonce
}</span>

func (h txHeapByNonce) Swap(i, j int) <span class="cov8" title="1">{
        h[i], h[j] = h[j], h[i]
        h[i].heapIndex = i
        h[j].heapIndex = j
}</span>

func (h *txHeapByNonce) Push(x interface{}) <span class="cov8" title="1">{
        tx := x.(*pooledTx)
        tx.heapIndex = h.Len()
        *h = append(*h, tx)
}</span>

func (h *txHeapByNonce) Pop() interface{} <span class="cov8" title="1">{
        old := *h
        n := len(old)
        x := old[n-1]
        *h = old[0 : n-1]
        return x
}</span>

// txCollection represents the nonce sorted transactions of an account.
type txCollection struct {
        heapItem
        txs       map[uint64]*pooledTx
        nonceHeap txHeapByNonce
}

func newTxCollection() *txCollection <span class="cov8" title="1">{
        return &amp;txCollection{
                txs: make(map[uint64]*pooledTx),
        }
}</span>

func (collection *txCollection) add(tx *pooledTx) bool <span class="cov8" title="1">{
        if existTx := collection.txs[tx.Data.AccountNonce]; existTx != nil </span><span class="cov8" title="1">{
                existTx.Transaction = tx.Transaction
                existTx.timestamp = tx.timestamp
                return false
        }</span>

        <span class="cov8" title="1">heap.Push(&amp;collection.nonceHeap, tx)
        collection.txs[tx.Data.AccountNonce] = tx

        return true</span>
}

func (collection *txCollection) get(nonce uint64) *pooledTx <span class="cov8" title="1">{
        return collection.txs[nonce]
}</span>

func (collection *txCollection) remove(nonce uint64) bool <span class="cov8" title="1">{
        if tx := collection.txs[nonce]; tx != nil </span><span class="cov8" title="1">{
                heap.Remove(&amp;collection.nonceHeap, tx.heapIndex)
                delete(collection.txs, nonce)
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func (collection *txCollection) len() int <span class="cov8" title="1">{
        return collection.nonceHeap.Len()
}</span>

func (collection *txCollection) peek() *pooledTx <span class="cov8" title="1">{
        return collection.nonceHeap[0]
}</span>

func (collection *txCollection) pop() *pooledTx <span class="cov8" title="1">{
        tx := heap.Pop(&amp;collection.nonceHeap).(*pooledTx)
        delete(collection.txs, tx.Data.AccountNonce)
        return tx
}</span>

func (collection *txCollection) list() []*types.Transaction <span class="cov8" title="1">{
        result := make([]*types.Transaction, collection.len())
        for i, tx := range collection.nonceHeap </span><span class="cov8" title="1">{
                result[i] = tx.Transaction
        }</span>

        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                return result[i].Data.AccountNonce &lt; result[j].Data.AccountNonce
        }</span>)

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

import (
        "errors"
        "fmt"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/state"
        "github.com/seeleteam/go-seele/core/store"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/event"
        "github.com/seeleteam/go-seele/log"
)

var (
        errTxHashExists = errors.New("transaction hash already exists")
        errTxPoolFull   = errors.New("transaction pool is full")
        errTxFeeNil     = errors.New("fee can't be nil")
        errTxNonceUsed  = errors.New("transaction from this address already used its nonce")
)

const chainHeaderChangeBuffSize = 100
const overTimeInterval = 3 * time.Hour

type blockchain interface {
        GetCurrentState() (*state.Statedb, error)
        GetStore() store.BlockchainStore
}

type pooledTx struct {
        *types.Transaction
        heapItem
        timestamp time.Time
}

func newPooledTx(tx *types.Transaction) *pooledTx <span class="cov8" title="1">{
        return &amp;pooledTx{tx, heapItem{0}, time.Now()}
}</span>

// TransactionPool is a thread-safe container for transactions received
// from the network or submitted locally. A transaction will be removed from
// the pool once included in a blockchain.
type TransactionPool struct {
        mutex                    sync.RWMutex
        config                   TransactionPoolConfig
        chain                    blockchain
        hashToTxMap              map[common.Hash]*pooledTx
        pendingQueue             *pendingQueue
        processingTxs            map[common.Hash]struct{}
        lastHeader               common.Hash
        chainHeaderChangeChannel chan common.Hash
        log                      *log.SeeleLog
}

// NewTransactionPool creates and returns a transaction pool.
func NewTransactionPool(config TransactionPoolConfig, chain blockchain) (*TransactionPool, error) <span class="cov0" title="0">{
        header, err := chain.GetStore().GetHeadBlockHash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get chain header failed, %s", err)
        }</span>

        <span class="cov0" title="0">pool := &amp;TransactionPool{
                config:        config,
                chain:         chain,
                hashToTxMap:   make(map[common.Hash]*pooledTx),
                pendingQueue:  newPendingQueue(),
                processingTxs: make(map[common.Hash]struct{}),
                lastHeader:    header,
                log:           log.GetLogger("txpool", common.LogConfig.PrintLog),
                chainHeaderChangeChannel: make(chan common.Hash, chainHeaderChangeBuffSize),
        }

        event.ChainHeaderChangedEventMananger.AddAsyncListener(pool.chainHeaderChanged)
        go pool.MonitorChainHeaderChange()

        return pool, nil</span>
}

// chainHeaderChanged handle chain header changed event.
// add forked transaction back
// deleted invalid transaction
func (pool *TransactionPool) chainHeaderChanged(e event.Event) <span class="cov0" title="0">{
        newHeader := e.(common.Hash)
        if newHeader.IsEmpty() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">pool.chainHeaderChangeChannel &lt;- newHeader</span>
}

// MonitorChainHeaderChange monitor and handle chain header event
func (pool *TransactionPool) MonitorChainHeaderChange() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case newHeader := &lt;-pool.chainHeaderChangeChannel:<span class="cov0" title="0">
                        if pool.lastHeader.IsEmpty() </span><span class="cov0" title="0">{
                                pool.lastHeader = newHeader
                                return
                        }</span>

                        <span class="cov0" title="0">reinject := getReinjectTransaction(pool.chain.GetStore(), newHeader, pool.lastHeader, pool.log)
                        count := pool.addTransactions(reinject)
                        if count &gt; 0 </span><span class="cov0" title="0">{
                                pool.log.Info("add %d reinject transactions", count)
                        }</span>

                        <span class="cov0" title="0">pool.lastHeader = newHeader
                        pool.removeTransactions()</span>
                }
        }
}

func getReinjectTransaction(chainStore store.BlockchainStore, newHeader, lastHeader common.Hash, log *log.SeeleLog) []*types.Transaction <span class="cov8" title="1">{
        newBlock, err := chainStore.GetBlock(newHeader)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("got block failed, %s", err)
                return nil
        }</span>

        <span class="cov8" title="1">if newBlock.Header.PreviousBlockHash != lastHeader </span><span class="cov8" title="1">{
                lastBlock, err := chainStore.GetBlock(lastHeader)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("got block failed, %s", err)
                        return nil
                }</span>

                <span class="cov8" title="1">log.Debug("handle chain header forked, last height %d, new height %d", lastBlock.Header.Height, newBlock.Header.Height)
                // add committed txs back in current branch.
                toDeleted := make(map[common.Hash]*types.Transaction)
                toAdded := make(map[common.Hash]*types.Transaction)
                for newBlock.Header.Height &gt; lastBlock.Header.Height </span><span class="cov0" title="0">{
                        for _, t := range newBlock.GetExcludeRewardTransactions() </span><span class="cov0" title="0">{
                                toDeleted[t.Hash] = t
                        }</span>

                        <span class="cov0" title="0">if newBlock, err = chainStore.GetBlock(newBlock.Header.PreviousBlockHash); err != nil </span><span class="cov0" title="0">{
                                log.Error("got block failed, %s", err)
                                return nil
                        }</span>
                }

                <span class="cov8" title="1">for lastBlock.Header.Height &gt; newBlock.Header.Height </span><span class="cov0" title="0">{
                        for _, t := range lastBlock.GetExcludeRewardTransactions() </span><span class="cov0" title="0">{
                                toAdded[t.Hash] = t
                        }</span>

                        <span class="cov0" title="0">if lastBlock, err = chainStore.GetBlock(lastBlock.Header.PreviousBlockHash); err != nil </span><span class="cov0" title="0">{
                                log.Error("got block failed, %s", err)
                                return nil
                        }</span>
                }

                <span class="cov8" title="1">for lastBlock.HeaderHash != newBlock.HeaderHash </span><span class="cov8" title="1">{
                        for _, t := range lastBlock.GetExcludeRewardTransactions() </span><span class="cov8" title="1">{
                                toAdded[t.Hash] = t
                        }</span>

                        <span class="cov8" title="1">for _, t := range newBlock.GetExcludeRewardTransactions() </span><span class="cov8" title="1">{
                                toDeleted[t.Hash] = t
                        }</span>

                        <span class="cov8" title="1">if lastBlock, err = chainStore.GetBlock(lastBlock.Header.PreviousBlockHash); err != nil </span><span class="cov0" title="0">{
                                log.Error("got block failed, %s", err)
                                return nil
                        }</span>

                        <span class="cov8" title="1">if newBlock, err = chainStore.GetBlock(newBlock.Header.PreviousBlockHash); err != nil </span><span class="cov0" title="0">{
                                log.Error("got block failed, %s", err)
                                return nil
                        }</span>
                }

                <span class="cov8" title="1">reinject := make([]*types.Transaction, 0)
                for key, t := range toAdded </span><span class="cov8" title="1">{
                        if _, ok := toDeleted[key]; !ok </span><span class="cov8" title="1">{
                                reinject = append(reinject, t)
                        }</span>
                }

                <span class="cov8" title="1">log.Debug("to added tx length %d, to deleted tx length %d, to reinject tx length %d",
                        len(toAdded), len(toDeleted), len(reinject))
                return reinject</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (pool *TransactionPool) addTransactions(txs []*types.Transaction) int <span class="cov0" title="0">{
        count := 0
        for _, tx := range txs </span><span class="cov0" title="0">{
                if err := pool.AddTransaction(tx); err != nil </span><span class="cov0" title="0">{
                        pool.log.Debug("add transaction failed, %s", err)
                }</span><span class="cov0" title="0"> else {
                        count++
                }</span>
        }

        <span class="cov0" title="0">return count</span>
}

// AddTransaction adds a single transaction into the pool if it is valid and returns nil.
// Otherwise, return the concrete error.
func (pool *TransactionPool) AddTransaction(tx *types.Transaction) error <span class="cov8" title="1">{
        if tx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">statedb, err := pool.chain.GetCurrentState()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get current state db failed, error %s", err)
        }</span>

        <span class="cov8" title="1">return pool.addTransactionWithStateInfo(tx, statedb)</span>
}

func (pool *TransactionPool) addTransactionWithStateInfo(tx *types.Transaction, statedb *state.Statedb) error <span class="cov8" title="1">{
        if err := tx.Validate(statedb); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">pool.mutex.Lock()
        defer pool.mutex.Unlock()

        if pool.hashToTxMap[tx.Hash] != nil </span><span class="cov8" title="1">{
                return errTxHashExists
        }</span>

        <span class="cov8" title="1">if uint(len(pool.hashToTxMap)) &gt;= pool.config.Capacity </span><span class="cov8" title="1">{
                return errTxPoolFull
        }</span>

        <span class="cov8" title="1">if existTx := pool.pendingQueue.get(tx.Data.From, tx.Data.AccountNonce); existTx != nil </span><span class="cov0" title="0">{
                if tx.Data.Fee.Cmp(existTx.Data.Fee) &gt; 0 </span><span class="cov0" title="0">{
                        pool.log.Debug("got a transaction have more fees than before. remove old one. new: %s, old: %s",
                                tx.Hash.ToHex(), existTx.Hash.ToHex())
                        pool.RemoveTransaction(existTx.Hash)
                }</span><span class="cov0" title="0"> else {
                        return errTxNonceUsed
                }</span>
        }

        <span class="cov8" title="1">pool.addTransaction(tx)

        // fire event
        event.TransactionInsertedEventManager.Fire(tx)

        return nil</span>
}

func (pool *TransactionPool) addTransaction(tx *types.Transaction) <span class="cov8" title="1">{
        poolTx := newPooledTx(tx)
        pool.hashToTxMap[tx.Hash] = poolTx
        pool.pendingQueue.add(poolTx)
}</span>

// GetTransaction returns a transaction if it is contained in the pool and nil otherwise.
func (pool *TransactionPool) GetTransaction(txHash common.Hash) *types.Transaction <span class="cov8" title="1">{
        pool.mutex.RLock()
        defer pool.mutex.RUnlock()

        if pooledTx, ok := pool.hashToTxMap[txHash]; ok </span><span class="cov8" title="1">{
                return pooledTx.Transaction
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveTransaction removes a transaction from pool.
func (pool *TransactionPool) RemoveTransaction(txHash common.Hash) <span class="cov8" title="1">{
        if tx := pool.hashToTxMap[txHash]; tx != nil </span><span class="cov8" title="1">{
                pool.pendingQueue.remove(tx.Data.From, tx.Data.AccountNonce)
                delete(pool.processingTxs, txHash)
                delete(pool.hashToTxMap, txHash)
        }</span>
}

// removeTransactions removes finalized and old transactions in hashToTxMap
func (pool *TransactionPool) removeTransactions() <span class="cov8" title="1">{
        pool.mutex.Lock()
        defer pool.mutex.Unlock()

        state, err := pool.chain.GetCurrentState()
        if err != nil </span><span class="cov0" title="0">{
                pool.log.Warn("failed to get current state, err: %s", err)
                return
        }</span>

        <span class="cov8" title="1">nowTimestamp := time.Now()
        for txHash, poolTx := range pool.hashToTxMap </span><span class="cov8" title="1">{
                txIndex, _ := pool.chain.GetStore().GetTxIndex(txHash)
                nonce := state.GetNonce(poolTx.Data.From)
                duration := nowTimestamp.Sub(poolTx.timestamp)

                // Transactions have been processed or are too old need to delete
                if txIndex != nil || poolTx.Data.AccountNonce &lt; nonce || duration &gt; overTimeInterval </span><span class="cov8" title="1">{
                        if txIndex == nil </span><span class="cov8" title="1">{
                                if poolTx.Data.AccountNonce &lt; nonce </span><span class="cov0" title="0">{
                                        pool.log.Debug("remove tx %s because nonce too low, account %s, tx nonce %d, target nonce %d", txHash.ToHex(),
                                                poolTx.Data.From.ToHex(), poolTx.Data.AccountNonce, nonce)
                                }</span><span class="cov8" title="1"> else if duration &gt; overTimeInterval </span><span class="cov8" title="1">{
                                        pool.log.Debug("remove tx %s because not packed for more than three hours", txHash.ToHex())
                                }</span>
                        }
                        <span class="cov8" title="1">pool.RemoveTransaction(txHash)</span>
                }
        }
}

// GetProcessableTransactions retrieves processable transactions from pool.
func (pool *TransactionPool) GetProcessableTransactions(num int) []*types.Transaction <span class="cov0" title="0">{
        pool.mutex.RLock()
        defer pool.mutex.RUnlock()

        txs := pool.pendingQueue.popN(num)
        for _, tx := range txs </span><span class="cov0" title="0">{
                pool.processingTxs[tx.Hash] = struct{}{}
        }</span>

        <span class="cov0" title="0">return txs</span>
}

// GetPendingTxCount return the total number of pending transactions in the transaction pool.
func (pool *TransactionPool) GetPendingTxCount() int <span class="cov0" title="0">{
        pool.mutex.RLock()
        defer pool.mutex.RUnlock()

        return pool.pendingQueue.count()
}</span>

// GetTransactions return the transactions in the transaction pool.
func (pool *TransactionPool) GetTransactions(processing, pending bool) []*types.Transaction <span class="cov0" title="0">{
        pool.mutex.RLock()
        defer pool.mutex.RUnlock()

        var txs []*types.Transaction

        if processing </span><span class="cov0" title="0">{
                for hash := range pool.processingTxs </span><span class="cov0" title="0">{
                        if tx := pool.hashToTxMap[hash]; tx != nil </span><span class="cov0" title="0">{
                                txs = append(txs, tx.Transaction)
                        }</span>
                }
        }

        <span class="cov0" title="0">if pending </span><span class="cov0" title="0">{
                pendingTxs := pool.pendingQueue.list()
                txs = append(txs, pendingTxs...)
        }</span>

        <span class="cov0" title="0">return txs</span>
}

// Stop terminates the transaction pool.
func (pool *TransactionPool) Stop() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

// TransactionPoolConfig is the configuration of the transaction pool.
type TransactionPoolConfig struct {
        Capacity uint // Maximum number of transactions in the pool.
}

// DefaultTxPoolConfig returns the default configuration of the transaction pool.
func DefaultTxPoolConfig() *TransactionPoolConfig <span class="cov8" title="1">{
        return &amp;TransactionPoolConfig{
                // 1 simple transaction is about 152 byte size. So 1000 transactions is about 152kb. And 10000 transaction is about 1.52Mb.
                // We want to use 10MB memory for tx pool. so it is about 520k transactions.
                // So we could cache transactions for about 100 blocks, which means at least 25 minutes block generation consume
                Capacity: 500000,
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package core

import (
        "container/heap"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/types"
)

type txHeapByFee []*txCollection

func (h txHeapByFee) Len() int <span class="cov8" title="1">{
        return len(h)
}</span>

func (h txHeapByFee) Less(i, j int) bool <span class="cov8" title="1">{
        iTx := h[i].peek()
        jTx := h[j].peek()

        r := iTx.Data.Fee.Cmp(jTx.Data.Fee)
        switch r </span>{
        case -1:<span class="cov8" title="1">
                return false</span>
        case 1:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return iTx.timestamp.Before(jTx.timestamp)</span>
        }
}

func (h txHeapByFee) Swap(i, j int) <span class="cov8" title="1">{
        h[i], h[j] = h[j], h[i]
        h[i].heapIndex = i
        h[j].heapIndex = j
}</span>

func (h *txHeapByFee) Push(x interface{}) <span class="cov8" title="1">{
        q := x.(*txCollection)
        q.heapIndex = h.Len()
        *h = append(*h, q)
}</span>

func (h *txHeapByFee) Pop() interface{} <span class="cov8" title="1">{
        old := *h
        n := len(old)
        x := old[n-1]
        *h = old[0 : n-1]
        return x
}</span>

// pendingQueue represents the fee sorted transactions that grouped by account.
type pendingQueue struct {
        txs     map[common.Address]*txCollection
        feeHeap txHeapByFee
}

func newPendingQueue() *pendingQueue <span class="cov8" title="1">{
        return &amp;pendingQueue{
                txs: make(map[common.Address]*txCollection),
        }
}</span>

func (q *pendingQueue) add(tx *pooledTx) <span class="cov8" title="1">{
        if collection := q.txs[tx.Data.From]; collection != nil </span><span class="cov8" title="1">{
                if updated := !collection.add(tx); updated </span><span class="cov0" title="0">{
                        heap.Fix(&amp;q.feeHeap, collection.heapIndex)
                }</span>
        }<span class="cov8" title="1"> else {
                collection := newTxCollection()
                collection.add(tx)

                q.txs[tx.Data.From] = collection
                heap.Push(&amp;q.feeHeap, collection)
        }</span>
}

func (q *pendingQueue) get(addr common.Address, nonce uint64) *pooledTx <span class="cov8" title="1">{
        collection := q.txs[addr]
        if collection == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return collection.get(nonce)</span>
}

func (q *pendingQueue) remove(addr common.Address, nonce uint64) <span class="cov8" title="1">{
        collection := q.txs[addr]
        if collection == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !collection.remove(nonce) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if collection.len() == 0 </span><span class="cov8" title="1">{
                delete(q.txs, addr)
                heap.Remove(&amp;q.feeHeap, collection.heapIndex)
        }</span><span class="cov8" title="1"> else {
                heap.Fix(&amp;q.feeHeap, collection.heapIndex)
        }</span>
}

func (q *pendingQueue) count() int <span class="cov8" title="1">{
        sum := 0

        for _, collection := range q.feeHeap </span><span class="cov8" title="1">{
                sum += collection.len()
        }</span>

        <span class="cov8" title="1">return sum</span>
}

func (q *pendingQueue) peek() *txCollection <span class="cov8" title="1">{
        return q.feeHeap[0]
}</span>

func (q *pendingQueue) popN(n int) []*types.Transaction <span class="cov8" title="1">{
        var txs []*types.Transaction

        for i := 0; i &lt; n &amp;&amp; q.feeHeap.Len() &gt; 0; i++ </span><span class="cov8" title="1">{
                txs = append(txs, q.pop())
        }</span>

        <span class="cov8" title="1">return txs</span>
}

func (q *pendingQueue) pop() *types.Transaction <span class="cov8" title="1">{
        if q.feeHeap.Len() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">collection := q.peek()
        tx := collection.pop().Transaction

        if collection.len() == 0 </span><span class="cov8" title="1">{
                delete(q.txs, tx.Data.From)
                heap.Remove(&amp;q.feeHeap, collection.heapIndex)
        }</span><span class="cov8" title="1"> else {
                heap.Fix(&amp;q.feeHeap, collection.heapIndex)
        }</span>

        <span class="cov8" title="1">return tx</span>
}

func (q *pendingQueue) list() []*types.Transaction <span class="cov0" title="0">{
        var result []*types.Transaction

        for _, collection := range q.feeHeap </span><span class="cov0" title="0">{
                result = append(result, collection.list()...)
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package types

import (
        "math/big"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
)

// BlockHeader represents the header of a block in the blockchain.
type BlockHeader struct {
        PreviousBlockHash common.Hash    // PreviousBlockHash represents the hash of the parent block
        Creator           common.Address // Creator is the coinbase of the miner which mined the block
        StateHash         common.Hash    // StateHash is the root hash of the state trie
        TxHash            common.Hash    // TxHash is the root hash of the transaction merkle tree
        ReceiptHash       common.Hash    // ReceiptHash is the root hash of the receipt merkle tree
        Difficulty        *big.Int       // Difficulty is the difficulty of the block
        Height            uint64         // Height is the number of the block
        CreateTimestamp   *big.Int       // CreateTimestamp is the timestamp when the block is created
        Nonce             uint64         // Nonce is the pow of the block
        ExtraData         []byte         // ExtraData stores the extra info of block header.
}

// Clone returns a clone of the block header.
func (header *BlockHeader) Clone() *BlockHeader <span class="cov8" title="1">{
        clone := *header

        if clone.Difficulty = new(big.Int); header.Difficulty != nil </span><span class="cov8" title="1">{
                clone.Difficulty.Set(header.Difficulty)
        }</span>

        <span class="cov8" title="1">if clone.CreateTimestamp = new(big.Int); header.CreateTimestamp != nil </span><span class="cov8" title="1">{
                clone.CreateTimestamp.Set(header.CreateTimestamp)
        }</span>

        <span class="cov8" title="1">clone.ExtraData = common.CopyBytes(header.ExtraData)

        return &amp;clone</span>
}

// Hash calculates and returns the hash of the bloch header.
func (header *BlockHeader) Hash() common.Hash <span class="cov8" title="1">{
        return crypto.MustHash(header)
}</span>

// Block represents a block in the blockchain.
type Block struct {
        HeaderHash   common.Hash    // HeaderHash is the hash of the RLP encoded header bytes
        Header       *BlockHeader   // Header is the block header, a block header is about 165byte
        Transactions []*Transaction // Transactions is the block payload
}

// NewBlock creates a new block. The input header is copied so that
// any change will not affect the block. The input transaction
// array is copied, but each transaction is not copied.
// So any change of the input transaction will affect the block.
// The input receipt array is the same behavior with transation array.
func NewBlock(header *BlockHeader, txs []*Transaction, receipts []*Receipt) *Block <span class="cov8" title="1">{
        block := &amp;Block{
                Header: header.Clone(),
        }

        // Copy the transactions and update the transaction trie root hash.
        block.Header.TxHash = MerkleRootHash(txs)
        if len(txs) &gt; 0 </span><span class="cov8" title="1">{
                block.Transactions = make([]*Transaction, len(txs))
                copy(block.Transactions, txs)
        }</span>

        <span class="cov8" title="1">block.Header.ReceiptHash = ReceiptMerkleRootHash(receipts)

        // Calculate the block header hash.
        block.HeaderHash = block.Header.Hash()

        return block</span>
}

// GetExcludeRewardTransactions returns all txs of a block except for the reward transaction
func (block *Block) GetExcludeRewardTransactions() []*Transaction <span class="cov8" title="1">{
        if len(block.Transactions) == 0 </span><span class="cov8" title="1">{
                return block.Transactions
        }</span>

        <span class="cov8" title="1">return block.Transactions[1:]</span>
}

// FindTransaction returns the transaction of the specified hash if found. Otherwise, it returns nil.
func (block *Block) FindTransaction(txHash common.Hash) *Transaction <span class="cov8" title="1">{
        for _, tx := range block.Transactions </span><span class="cov8" title="1">{
                if tx.Hash == txHash </span><span class="cov8" title="1">{
                        return tx
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetShardNumber returns the shard number of the block, which means the shard number of the creator.
func (block *Block) GetShardNumber() uint <span class="cov8" title="1">{
        if block.Header == nil </span><span class="cov8" title="1">{
                return common.UndefinedShardNumber
        }</span>

        <span class="cov8" title="1">return block.Header.Creator.Shard()</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package types

import (
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
        "github.com/seeleteam/go-seele/merkle"
)

var emptyReceiptRootHash = crypto.MustHash("empty receipt root hash")

// Receipt represents the transaction processing receipt.
type Receipt struct {
        Result          []byte      // the execution result of the tx
        Failed          bool        // indicates if execution failed
        UsedGas         uint64      // tx used gas
        PostState       common.Hash // the root hash of the state trie after the tx is processed.
        Logs            []*Log      // the log objects
        TxHash          common.Hash // the hash of the executed transaction
        ContractAddress []byte      // Used when the tx (nil To address) is to create a contract.
}

// CalculateHash calculates and returns the receipt hash.
// This is to implement the merkle.Content interface.
func (receipt *Receipt) CalculateHash() common.Hash <span class="cov8" title="1">{
        return crypto.MustHash(receipt)
}</span>

// Equals indicates if the receipt is equal to the specified content.
// This is to implement the merkle.Content interface.
func (receipt *Receipt) Equals(other merkle.Content) bool <span class="cov8" title="1">{
        otherReceipt, ok := other.(*Receipt)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">hash := receipt.CalculateHash()
        otherHash := otherReceipt.CalculateHash()

        return hash.Equal(otherHash)</span>
}

// ReceiptMerkleRootHash calculates and returns the merkle root hash of the specified receipts.
// If the given receipts are empty, return empty hash.
func ReceiptMerkleRootHash(receipts []*Receipt) common.Hash <span class="cov8" title="1">{
        if len(receipts) == 0 </span><span class="cov8" title="1">{
                return emptyReceiptRootHash
        }</span>

        <span class="cov8" title="1">contents := make([]merkle.Content, len(receipts))
        for i, receipt := range receipts </span><span class="cov8" title="1">{
                contents[i] = receipt
        }</span>

        <span class="cov8" title="1">bmt, _ := merkle.NewTree(contents)

        return bmt.MerkleRoot()</span>
}

// MakeRewardReceipt generates the receipt for the specified reward transaction
func MakeRewardReceipt(reward *Transaction) *Receipt <span class="cov8" title="1">{
        return &amp;Receipt{
                TxHash: reward.Hash,
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">/**
* @file
* @copyright defined in go-seele/LICENSE
 */

package types

import (
        "crypto/ecdsa"
        "errors"
        "fmt"
        "math/big"
        "runtime"
        "sync"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
        "github.com/seeleteam/go-seele/merkle"
)

const (
        defaultMaxPayloadSize = 32 * 1024
)

var (
        // ErrAmountNegative is returned when the transaction amount is negative.
        ErrAmountNegative = errors.New("amount is negative")

        // ErrAmountNil is returned when the transation amount is nil.
        ErrAmountNil = errors.New("amount is null")

        // ErrFeeNegative is returned when the transaction fee is negative.
        ErrFeeNegative = errors.New("failed to create tx, fee can't be negative or zero")

        // ErrFeeNil is returned when the transaction fee is nil.
        ErrFeeNil = errors.New("failed to create tx, fee is nil")

        // ErrHashMismatch is returned when the transaction hash and data mismatch.
        ErrHashMismatch = errors.New("hash mismatch")

        // ErrPayloadOversized is returned when the payload size is larger than the MaxPayloadSize.
        ErrPayloadOversized = errors.New("oversized payload")

        // ErrPayloadEmpty is returned when create or call a contract without payload.
        ErrPayloadEmpty = errors.New("empty payload")

        // ErrTimestampMismatch is returned when the timestamp of the miner reward tx doesn't match with the block timestamp.
        ErrTimestampMismatch = errors.New("timestamp mismatch")

        // ErrSigInvalid is returned when the transaction signature is invalid.
        ErrSigInvalid = errors.New("signature is invalid")

        // ErrSigMissing is returned when the transaction signature is missing.
        ErrSigMissing = errors.New("signature missing")

        emptyTxRootHash = common.EmptyHash

        // MaxPayloadSize limits the payload size to prevent malicious transactions.
        MaxPayloadSize = defaultMaxPayloadSize
)

// TransactionData wraps the data in a transaction.
type TransactionData struct {
        From         common.Address // From is the address of the sender
        To           common.Address // To is the receiver address, and empty address is used to create contract
        Amount       *big.Int       // Amount is the amount to be transferred
        AccountNonce uint64         // AccountNonce is the nonce of the sender account
        Fee          *big.Int       // Transaction Fee
        Timestamp    uint64         // Timestamp is used for the miner reward transaction, referring to the block timestamp
        Payload      []byte         // Payload is the extra data of the transaction
}

// Transaction represents a transaction in the blockchain.
type Transaction struct {
        Hash      common.Hash      // Hash is the hash of the transaction data
        Data      TransactionData  // Data is the transaction data
        Signature crypto.Signature // Signature is the signature of the transaction
}

// TxIndex represents an index that used to query block info by tx hash.
type TxIndex struct {
        BlockHash common.Hash
        Index     uint // tx array index in block body
}

type stateDB interface {
        GetBalance(common.Address) *big.Int
        GetNonce(common.Address) uint64
}

// NewTransaction creates a new transaction to transfer asset.
// The transaction data hash is also calculated.
func NewTransaction(from, to common.Address, amount *big.Int, fee *big.Int, nonce uint64) (*Transaction, error) <span class="cov8" title="1">{
        return newTx(from, to, amount, fee, nonce, nil)
}</span>

func newTx(from common.Address, to common.Address, amount *big.Int, fee *big.Int, nonce uint64, payload []byte) (*Transaction, error) <span class="cov8" title="1">{
        txData := TransactionData{
                From:         from,
                To:           to,
                AccountNonce: nonce,
                Payload:      common.CopyBytes(payload),
        }

        if amount != nil </span><span class="cov8" title="1">{
                txData.Amount = new(big.Int).Set(amount)
        }</span>

        <span class="cov8" title="1">if fee != nil </span><span class="cov8" title="1">{
                txData.Fee = new(big.Int).Set(fee)
        }</span>

        <span class="cov8" title="1">if txData.Payload == nil </span><span class="cov8" title="1">{
                txData.Payload = make([]byte, 0)
        }</span>

        <span class="cov8" title="1">tx := &amp;Transaction{
                Data:      txData,
                Signature: crypto.Signature{Sig: make([]byte, 0)},
        }

        if err := tx.ValidateWithoutState(false, true); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tx.Hash = crypto.MustHash(txData)

        return tx, nil</span>
}

// ValidateWithoutState validates state independent fields in tx.
func (tx Transaction) ValidateWithoutState(signNeeded bool, shardNeeded bool) error <span class="cov8" title="1">{
        // validate amount
        if tx.Data.Amount == nil </span><span class="cov8" title="1">{
                return ErrAmountNil
        }</span>

        <span class="cov8" title="1">if tx.Data.Amount.Sign() &lt; 0 </span><span class="cov8" title="1">{
                return ErrAmountNegative
        }</span>

        // validate fee
        <span class="cov8" title="1">if tx.Data.Fee == nil </span><span class="cov8" title="1">{
                return ErrFeeNil
        }</span>

        <span class="cov8" title="1">if tx.Data.Fee.Sign() &lt;= 0 </span><span class="cov8" title="1">{
                return ErrFeeNegative
        }</span>

        // validate payload
        <span class="cov8" title="1">if len(tx.Data.Payload) &gt; MaxPayloadSize </span><span class="cov8" title="1">{
                return ErrPayloadOversized
        }</span>

        <span class="cov8" title="1">if (tx.Data.To.IsEmpty() || tx.Data.To.Type() == common.AddressTypeContract) &amp;&amp; len(tx.Data.Payload) == 0 </span><span class="cov8" title="1">{
                return ErrPayloadEmpty
        }</span>

        // validate shard of from/to address
        <span class="cov8" title="1">if shardNeeded </span><span class="cov8" title="1">{
                if common.IsShardEnabled() </span><span class="cov8" title="1">{
                        if fromShardNum := tx.Data.From.Shard(); fromShardNum != common.LocalShardNumber </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid from address, shard number is [%v], but coinbase shard number is [%v]", fromShardNum, common.LocalShardNumber)
                        }</span>
                }

                <span class="cov8" title="1">if !tx.Data.To.IsEmpty() &amp;&amp; common.IsShardEnabled() </span><span class="cov8" title="1">{
                        if toShardNum := tx.Data.To.Shard(); toShardNum != common.LocalShardNumber </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid to address, shard number is [%v], but coinbase shard number is [%v]", toShardNum, common.LocalShardNumber)
                        }</span>
                }
        }

        // vaildate signature
        <span class="cov8" title="1">if !signNeeded </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if len(tx.Signature.Sig) == 0 </span><span class="cov8" title="1">{
                return ErrSigMissing
        }</span>

        <span class="cov8" title="1">txDataHash := crypto.MustHash(tx.Data)
        if !txDataHash.Equal(tx.Hash) </span><span class="cov8" title="1">{
                return ErrHashMismatch
        }</span>

        <span class="cov8" title="1">if !tx.Signature.Verify(tx.Data.From, txDataHash.Bytes()) </span><span class="cov8" title="1">{
                return ErrSigInvalid
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// NewContractTransaction returns a transaction to create a smart contract.
func NewContractTransaction(from common.Address, amount *big.Int, fee *big.Int, nonce uint64, code []byte) (*Transaction, error) <span class="cov8" title="1">{
        return newTx(from, common.EmptyAddress, amount, fee, nonce, code)
}</span>

// NewMessageTransaction returns a transation with the specified message.
func NewMessageTransaction(from, to common.Address, amount *big.Int, fee *big.Int, nonce uint64, msg []byte) (*Transaction, error) <span class="cov8" title="1">{
        return newTx(from, to, amount, fee, nonce, msg)
}</span>

// NewRewardTransaction creates a reward transaction for the specified miner with the specified reward and block timestamp.
func NewRewardTransaction(miner common.Address, reward *big.Int, timestamp uint64) (*Transaction, error) <span class="cov8" title="1">{
        if reward == nil </span><span class="cov0" title="0">{
                return nil, ErrAmountNil
        }</span>

        <span class="cov8" title="1">if reward.Sign() &lt; 0 </span><span class="cov0" title="0">{
                return nil, ErrAmountNegative
        }</span>

        <span class="cov8" title="1">rewardTxData := TransactionData{
                From:      common.Address{},
                To:        miner,
                Amount:    new(big.Int).Set(reward),
                Fee:       big.NewInt(0),
                Timestamp: timestamp,
                Payload:   make([]byte, 0),
        }

        rewardTx := &amp;Transaction{
                Hash:      crypto.MustHash(rewardTxData),
                Data:      rewardTxData,
                Signature: crypto.Signature{Sig: make([]byte, 0)},
        }

        return rewardTx, nil</span>
}

// Sign signs the transaction with the specified private key.
func (tx *Transaction) Sign(privKey *ecdsa.PrivateKey) <span class="cov8" title="1">{
        tx.Hash = crypto.MustHash(tx.Data)
        tx.Signature = *crypto.MustSign(privKey, tx.Hash.Bytes())
}</span>

// Validate validates all fields in tx.
func (tx *Transaction) Validate(statedb stateDB) error <span class="cov8" title="1">{
        if err := tx.ValidateWithoutState(true, true); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.ValidateState(statedb)</span>
}

// ValidateState validates state dependent fields in tx.
func (tx *Transaction) ValidateState(statedb stateDB) error <span class="cov8" title="1">{
        consumed := new(big.Int).Add(tx.Data.Amount, tx.Data.Fee)
        if balance := statedb.GetBalance(tx.Data.From); consumed.Cmp(balance) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("balance is not enough, account:%s, balance:%v, amount:%v, fee:%v", tx.Data.From.ToHex(), balance, tx.Data.Amount, tx.Data.Fee)
        }</span>

        <span class="cov8" title="1">if accountNonce := statedb.GetNonce(tx.Data.From); tx.Data.AccountNonce &lt; accountNonce </span><span class="cov8" title="1">{
                return fmt.Errorf("nonce is too small, acount:%s, tx nonce:%d, state db nonce:%d", tx.Data.From.ToHex(), tx.Data.AccountNonce, accountNonce)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CalculateHash calculates and returns the transaction hash.
// This is to implement the merkle.Content interface.
func (tx *Transaction) CalculateHash() common.Hash <span class="cov8" title="1">{
        return crypto.MustHash(tx.Data)
}</span>

// Equals indicates if the transaction is equal to the specified content.
// This is to implement the merkle.Content interface.
func (tx *Transaction) Equals(other merkle.Content) bool <span class="cov0" title="0">{
        otherTx, ok := other.(*Transaction)
        return ok &amp;&amp; tx.Hash.Equal(otherTx.Hash)
}</span>

// MerkleRootHash calculates and returns the merkle root hash of the specified transactions.
// If the given transactions are empty, return empty hash.
func MerkleRootHash(txs []*Transaction) common.Hash <span class="cov8" title="1">{
        if len(txs) == 0 </span><span class="cov8" title="1">{
                return emptyTxRootHash
        }</span>

        <span class="cov8" title="1">contents := make([]merkle.Content, len(txs))
        for i, tx := range txs </span><span class="cov8" title="1">{
                contents[i] = tx
        }</span>

        <span class="cov8" title="1">bmt, _ := merkle.NewTree(contents)

        return bmt.MerkleRoot()</span>
}

// BatchValidateTxs validates the state independent fields of specified txs in multiple threads.
// Because the signature verification is time consuming (see test Benchmark_Transaction_ValidateWithoutState),
// once a block includes too many txs (e.g. 5000), the txs validation will consume too much time.
func BatchValidateTxs(txs []*Transaction) error <span class="cov0" title="0">{
        len := len(txs)
        threads := runtime.NumCPU() / 4 // in case of CPU 100%

        // single thread for few CPU kernel or few txs to validate.
        if threads &lt;= 1 || len &lt; threads </span><span class="cov0" title="0">{
                for _, tx := range txs </span><span class="cov0" title="0">{
                        if err := tx.ValidateWithoutState(true, true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        // parallel validates txs
        <span class="cov0" title="0">var err error
        wg := sync.WaitGroup{}

        for i := 0; i &lt; threads; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(offset int) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        for j := offset; j &lt; len &amp;&amp; err == nil; j += threads </span><span class="cov0" title="0">{
                                if e := txs[j].ValidateWithoutState(true, true); e != nil </span><span class="cov0" title="0">{
                                        if err != nil </span><span class="cov0" title="0">{
                                                err = e
                                        }</span>

                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }(i)
        }

        <span class="cov0" title="0">wg.Wait()

        return err</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package crypto

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "encoding/hex"
        "errors"
        "fmt"
        "math/big"

        "github.com/ethereum/go-ethereum/common/math"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/common/hexutil"
        "github.com/seeleteam/go-seele/crypto/secp256k1"
)

const (
        ecdsaPublickKeyPrefix byte = 4
)

// GenerateKey generates and returns an ECDSA private key.
func GenerateKey() (*ecdsa.PrivateKey, error) <span class="cov8" title="1">{
        return ecdsa.GenerateKey(S256(), rand.Reader)
}</span>

// ToECDSAPub creates ecdsa.PublicKey object by the given byte array.
// Pubkey length derived from ecdsa is 65, with constant prefix 4 in the first byte.
// So if pubkey length equals 64, we insert one byte in front
func ToECDSAPub(pub []byte) *ecdsa.PublicKey <span class="cov8" title="1">{
        if len(pub) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var pubNew []byte

        if len(pub) == 65 </span><span class="cov8" title="1">{
                pubNew = pub
        }</span><span class="cov8" title="1"> else {
                pubNew = make([]byte, 65)
                pubNew[0] = ecdsaPublickKeyPrefix
                copy(pubNew[1:], pub[0:])
        }</span>
        <span class="cov8" title="1">x, y := elliptic.Unmarshal(S256(), pubNew)
        return &amp;ecdsa.PublicKey{Curve: S256(), X: x, Y: y}</span>
}

// PubkeyToString returns the string of the given public key, with prefix 0x
func PubkeyToString(pub *ecdsa.PublicKey) string <span class="cov8" title="1">{
        return GetAddress(pub).ToHex()
}</span>

// FromECDSAPub marshals and returns the byte array of the specified ECDSA public key.
func FromECDSAPub(pub *ecdsa.PublicKey) []byte <span class="cov8" title="1">{
        if pub == nil || pub.X == nil || pub.Y == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return elliptic.Marshal(pub.Curve, pub.X, pub.Y)</span>
}

// S256 returns an instance of the secp256k1 curve.
func S256() elliptic.Curve <span class="cov8" title="1">{
        return secp256k1.S256()
}</span>

// LoadECDSAFromString creates ecdsa private key from the given string.
// ecStr should start with 0x or 0X
func LoadECDSAFromString(ecStr string) (*ecdsa.PrivateKey, error) <span class="cov8" title="1">{
        if !hexutil.Has0xPrefix(ecStr) </span><span class="cov8" title="1">{
                return nil, errors.New("Input string not a valid ecdsa string")
        }</span>
        <span class="cov8" title="1">key, err := hex.DecodeString(ecStr[2:])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ToECDSA(key)</span>
}

// ToECDSA creates a private key with the given D value.
func ToECDSA(d []byte) (*ecdsa.PrivateKey, error) <span class="cov8" title="1">{
        return toECDSA(d, true)
}</span>

// toECDSA creates a private key with the given D value. The strict parameter
// controls whether the key's length should be enforced at the curve size or
// it can also accept legacy encodings (0 prefixes).
func toECDSA(d []byte, strict bool) (*ecdsa.PrivateKey, error) <span class="cov8" title="1">{
        priv := new(ecdsa.PrivateKey)
        priv.PublicKey.Curve = S256()
        if strict &amp;&amp; 8*len(d) != priv.Params().BitSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid length, need %d bits", priv.Params().BitSize)
        }</span>
        <span class="cov8" title="1">priv.D = new(big.Int).SetBytes(d)
        priv.PublicKey.X, priv.PublicKey.Y = priv.PublicKey.Curve.ScalarBaseMult(d)
        if priv.PublicKey.X == nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid private key")
        }</span>
        <span class="cov8" title="1">return priv, nil</span>
}

// FromECDSA exports a private key into a binary dump.
func FromECDSA(priv *ecdsa.PrivateKey) []byte <span class="cov8" title="1">{
        if priv == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return math.PaddedBigBytes(priv.D, priv.Params().BitSize/8)</span>
}

// GenerateKeyPair generates public key and private key
func GenerateKeyPair() (*common.Address, *ecdsa.PrivateKey, error) <span class="cov8" title="1">{
        keypair, err := GenerateKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">id := GetAddress(&amp;keypair.PublicKey)
        return id, keypair, err</span>
}

// GetAddress gets an address from the given public key
func GetAddress(key *ecdsa.PublicKey) *common.Address <span class="cov8" title="1">{
        addr := common.PubKeyToAddress(key, MustHash)
        return &amp;addr
}</span>

// GenerateRandomAddress generates and returns a random address.
func GenerateRandomAddress() (*common.Address, error) <span class="cov8" title="1">{
        addr, _, err := GenerateKeyPair()
        return addr, err
}</span>

// MustGenerateRandomAddress generates and returns a random address.
// Panic on any error.
func MustGenerateRandomAddress() *common.Address <span class="cov8" title="1">{
        address, err := GenerateRandomAddress()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return address</span>
}

// MustGenerateShardAddress generates and returns a random address that match the specified shard number.
// Panic on any error.
func MustGenerateShardAddress(shardNum uint) *common.Address <span class="cov8" title="1">{
        addr, _ := MustGenerateShardKeyPair(shardNum)
        return addr
}</span>

// MustGenerateShardKeyPair generates and returns a random address and key.
// Panic on any error.
func MustGenerateShardKeyPair(shard uint) (*common.Address, *ecdsa.PrivateKey) <span class="cov8" title="1">{
        if shard == 0 || shard &gt; common.ShardCount </span><span class="cov0" title="0">{
                panic(fmt.Errorf("invalid shard number, should be between 1 and %v", common.ShardCount))</span>
        }

        <span class="cov8" title="1">for i := 1; ; i++ </span><span class="cov8" title="1">{
                addr, privateKey, err := GenerateKeyPair()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov8" title="1">if addr.Shard() == shard </span><span class="cov8" title="1">{
                        return addr, privateKey
                }</span>
        }
}

// CreateAddress creates a new address with the specified address and nonce.
// Generally, it's used to create a new contract address based on the account
// address and nonce. Note, the new created contract address and the account
// address are in the same shard.
func CreateAddress(addr common.Address, nonce uint64) common.Address <span class="cov8" title="1">{
        return addr.CreateContractAddress(nonce, MustHash)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package ecies

import (
        "bytes"
        "crypto"
        "crypto/elliptic"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "encoding/asn1"
        "encoding/pem"
        "fmt"
        "hash"
        "math/big"
)

var (
        secgScheme     = []int{1, 3, 132, 1}
        shaScheme      = []int{2, 16, 840, 1, 101, 3, 4, 2}
        ansiX962Scheme = []int{1, 2, 840, 10045}
        x963Scheme     = []int{1, 2, 840, 63, 0}
)

var ErrInvalidPrivateKey = fmt.Errorf("ecies: invalid private key")

func doScheme(base, v []int) asn1.ObjectIdentifier <span class="cov8" title="1">{
        var oidInts asn1.ObjectIdentifier
        oidInts = append(oidInts, base...)
        return append(oidInts, v...)
}</span>

// curve OID code taken from crypto/x509, including
//        - oidNameCurve*
//        - namedCurveFromOID
//        - oidFromNamedCurve
// RFC 5480, 2.1.1.1. Named Curve
//
// secp224r1 OBJECT IDENTIFIER ::= {
//   iso(1) identified-organization(3) certicom(132) curve(0) 33 }
//
// secp256r1 OBJECT IDENTIFIER ::= {
//   iso(1) member-body(2) us(840) ansi-X9-62(10045) curves(3)
//   prime(1) 7 }
//
// secp384r1 OBJECT IDENTIFIER ::= {
//   iso(1) identified-organization(3) certicom(132) curve(0) 34 }
//
// secp521r1 OBJECT IDENTIFIER ::= {
//   iso(1) identified-organization(3) certicom(132) curve(0) 35 }
//
// NB: secp256r1 is equivalent to prime256v1
type secgNamedCurve asn1.ObjectIdentifier

var (
        secgNamedCurveP224 = secgNamedCurve{1, 3, 132, 0, 33}
        secgNamedCurveP256 = secgNamedCurve{1, 2, 840, 10045, 3, 1, 7}
        secgNamedCurveP384 = secgNamedCurve{1, 3, 132, 0, 34}
        secgNamedCurveP521 = secgNamedCurve{1, 3, 132, 0, 35}
        rawCurveP224       = []byte{6, 5, 4, 3, 1, 2, 9, 4, 0, 3, 3}
        rawCurveP256       = []byte{6, 8, 4, 2, 1, 3, 4, 7, 2, 2, 0, 6, 6, 1, 3, 1, 7}
        rawCurveP384       = []byte{6, 5, 4, 3, 1, 2, 9, 4, 0, 3, 4}
        rawCurveP521       = []byte{6, 5, 4, 3, 1, 2, 9, 4, 0, 3, 5}
)

func rawCurve(curve elliptic.Curve) []byte <span class="cov0" title="0">{
        switch curve </span>{
        case elliptic.P224():<span class="cov0" title="0">
                return rawCurveP224</span>
        case elliptic.P256():<span class="cov0" title="0">
                return rawCurveP256</span>
        case elliptic.P384():<span class="cov0" title="0">
                return rawCurveP384</span>
        case elliptic.P521():<span class="cov0" title="0">
                return rawCurveP521</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (curve secgNamedCurve) Equal(curve2 secgNamedCurve) bool <span class="cov8" title="1">{
        if len(curve) != len(curve2) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i, _ := range curve </span><span class="cov8" title="1">{
                if curve[i] != curve2[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func namedCurveFromOID(curve secgNamedCurve) elliptic.Curve <span class="cov8" title="1">{
        switch </span>{
        case curve.Equal(secgNamedCurveP224):<span class="cov0" title="0">
                return elliptic.P224()</span>
        case curve.Equal(secgNamedCurveP256):<span class="cov8" title="1">
                return elliptic.P256()</span>
        case curve.Equal(secgNamedCurveP384):<span class="cov0" title="0">
                return elliptic.P384()</span>
        case curve.Equal(secgNamedCurveP521):<span class="cov0" title="0">
                return elliptic.P521()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func oidFromNamedCurve(curve elliptic.Curve) (secgNamedCurve, bool) <span class="cov8" title="1">{
        switch curve </span>{
        case elliptic.P224():<span class="cov0" title="0">
                return secgNamedCurveP224, true</span>
        case elliptic.P256():<span class="cov8" title="1">
                return secgNamedCurveP256, true</span>
        case elliptic.P384():<span class="cov0" title="0">
                return secgNamedCurveP384, true</span>
        case elliptic.P521():<span class="cov0" title="0">
                return secgNamedCurveP521, true</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}

// asnAlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC
// 5280, section 4.1.1.2.
type asnAlgorithmIdentifier struct {
        Algorithm  asn1.ObjectIdentifier
        Parameters asn1.RawValue `asn1:"optional"`
}

func (a asnAlgorithmIdentifier) Cmp(b asnAlgorithmIdentifier) bool <span class="cov0" title="0">{
        if len(a.Algorithm) != len(b.Algorithm) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i, _ := range a.Algorithm </span><span class="cov0" title="0">{
                if a.Algorithm[i] != b.Algorithm[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

type asnHashFunction asnAlgorithmIdentifier

var (
        oidSHA1   = asn1.ObjectIdentifier{1, 3, 14, 3, 2, 26}
        oidSHA224 = doScheme(shaScheme, []int{4})
        oidSHA256 = doScheme(shaScheme, []int{1})
        oidSHA384 = doScheme(shaScheme, []int{2})
        oidSHA512 = doScheme(shaScheme, []int{3})
)

func hashFromOID(oid asn1.ObjectIdentifier) func() hash.Hash <span class="cov0" title="0">{
        switch </span>{
        case oid.Equal(oidSHA1):<span class="cov0" title="0">
                return sha1.New</span>
        case oid.Equal(oidSHA224):<span class="cov0" title="0">
                return sha256.New224</span>
        case oid.Equal(oidSHA256):<span class="cov0" title="0">
                return sha256.New</span>
        case oid.Equal(oidSHA384):<span class="cov0" title="0">
                return sha512.New384</span>
        case oid.Equal(oidSHA512):<span class="cov0" title="0">
                return sha512.New</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func oidFromHash(hash crypto.Hash) (asn1.ObjectIdentifier, bool) <span class="cov0" title="0">{
        switch hash </span>{
        case crypto.SHA1:<span class="cov0" title="0">
                return oidSHA1, true</span>
        case crypto.SHA224:<span class="cov0" title="0">
                return oidSHA224, true</span>
        case crypto.SHA256:<span class="cov0" title="0">
                return oidSHA256, true</span>
        case crypto.SHA384:<span class="cov0" title="0">
                return oidSHA384, true</span>
        case crypto.SHA512:<span class="cov0" title="0">
                return oidSHA512, true</span>
        default:<span class="cov0" title="0">
                return nil, false</span>
        }
}

var (
        asnAlgoSHA1 = asnHashFunction{
                Algorithm: oidSHA1,
        }
        asnAlgoSHA224 = asnHashFunction{
                Algorithm: oidSHA224,
        }
        asnAlgoSHA256 = asnHashFunction{
                Algorithm: oidSHA256,
        }
        asnAlgoSHA384 = asnHashFunction{
                Algorithm: oidSHA384,
        }
        asnAlgoSHA512 = asnHashFunction{
                Algorithm: oidSHA512,
        }
)

// type ASNasnSubjectPublicKeyInfo struct {
//
// }
//

type asnSubjectPublicKeyInfo struct {
        Algorithm   asn1.ObjectIdentifier
        PublicKey   asn1.BitString
        Supplements ecpksSupplements `asn1:"optional"`
}

type asnECPKAlgorithms struct {
        Type asn1.ObjectIdentifier
}

var idPublicKeyType = doScheme(ansiX962Scheme, []int{2})
var idEcPublicKey = doScheme(idPublicKeyType, []int{1})
var idEcPublicKeySupplemented = doScheme(idPublicKeyType, []int{0})

func curveToRaw(curve elliptic.Curve) (rv asn1.RawValue, ok bool) <span class="cov0" title="0">{
        switch curve </span>{
        case elliptic.P224(), elliptic.P256(), elliptic.P384(), elliptic.P521():<span class="cov0" title="0">
                raw := rawCurve(curve)
                return asn1.RawValue{
                        Tag:       30,
                        Bytes:     raw[2:],
                        FullBytes: raw,
                }, true</span>
        default:<span class="cov0" title="0">
                return rv, false</span>
        }
}

func asnECPublicKeyType(curve elliptic.Curve) (algo asnAlgorithmIdentifier, ok bool) <span class="cov0" title="0">{
        raw, ok := curveToRaw(curve)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0"> else {
                return asnAlgorithmIdentifier{Algorithm: idEcPublicKey,
                        Parameters: raw}, true
        }</span>
}

type asnECPrivKeyVer int

var asnECPrivKeyVer1 asnECPrivKeyVer = 1

type asnPrivateKey struct {
        Version asnECPrivKeyVer
        Private []byte
        Curve   secgNamedCurve `asn1:"optional"`
        Public  asn1.BitString
}

var asnECDH = doScheme(secgScheme, []int{12})

type asnECDHAlgorithm asnAlgorithmIdentifier

var (
        dhSinglePass_stdDH_sha1kdf = asnECDHAlgorithm{
                Algorithm: doScheme(x963Scheme, []int{2}),
        }
        dhSinglePass_stdDH_sha256kdf = asnECDHAlgorithm{
                Algorithm: doScheme(secgScheme, []int{11, 1}),
        }
        dhSinglePass_stdDH_sha384kdf = asnECDHAlgorithm{
                Algorithm: doScheme(secgScheme, []int{11, 2}),
        }
        dhSinglePass_stdDH_sha224kdf = asnECDHAlgorithm{
                Algorithm: doScheme(secgScheme, []int{11, 0}),
        }
        dhSinglePass_stdDH_sha512kdf = asnECDHAlgorithm{
                Algorithm: doScheme(secgScheme, []int{11, 3}),
        }
)

func (a asnECDHAlgorithm) Cmp(b asnECDHAlgorithm) bool <span class="cov8" title="1">{
        if len(a.Algorithm) != len(b.Algorithm) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, _ := range a.Algorithm </span><span class="cov8" title="1">{
                if a.Algorithm[i] != b.Algorithm[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// asnNISTConcatenation is the only supported KDF at this time.
type asnKeyDerivationFunction asnAlgorithmIdentifier

var asnNISTConcatenationKDF = asnKeyDerivationFunction{
        Algorithm: doScheme(secgScheme, []int{17, 1}),
}

func (a asnKeyDerivationFunction) Cmp(b asnKeyDerivationFunction) bool <span class="cov8" title="1">{
        if len(a.Algorithm) != len(b.Algorithm) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, _ := range a.Algorithm </span><span class="cov8" title="1">{
                if a.Algorithm[i] != b.Algorithm[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

var eciesRecommendedParameters = doScheme(secgScheme, []int{7})
var eciesSpecifiedParameters = doScheme(secgScheme, []int{8})

type asnECIESParameters struct {
        KDF asnKeyDerivationFunction     `asn1:"optional"`
        Sym asnSymmetricEncryption       `asn1:"optional"`
        MAC asnMessageAuthenticationCode `asn1:"optional"`
}

type asnSymmetricEncryption asnAlgorithmIdentifier

var (
        aes128CTRinECIES = asnSymmetricEncryption{
                Algorithm: doScheme(secgScheme, []int{21, 0}),
        }
        aes192CTRinECIES = asnSymmetricEncryption{
                Algorithm: doScheme(secgScheme, []int{21, 1}),
        }
        aes256CTRinECIES = asnSymmetricEncryption{
                Algorithm: doScheme(secgScheme, []int{21, 2}),
        }
)

func (a asnSymmetricEncryption) Cmp(b asnSymmetricEncryption) bool <span class="cov8" title="1">{
        if len(a.Algorithm) != len(b.Algorithm) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, _ := range a.Algorithm </span><span class="cov8" title="1">{
                if a.Algorithm[i] != b.Algorithm[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

type asnMessageAuthenticationCode asnAlgorithmIdentifier

var (
        hmacFull = asnMessageAuthenticationCode{
                Algorithm: doScheme(secgScheme, []int{22}),
        }
)

func (a asnMessageAuthenticationCode) Cmp(b asnMessageAuthenticationCode) bool <span class="cov8" title="1">{
        if len(a.Algorithm) != len(b.Algorithm) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, _ := range a.Algorithm </span><span class="cov8" title="1">{
                if a.Algorithm[i] != b.Algorithm[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

type ecpksSupplements struct {
        ECDomain      secgNamedCurve
        ECCAlgorithms eccAlgorithmSet
}

type eccAlgorithmSet struct {
        ECDH  asnECDHAlgorithm   `asn1:"optional"`
        ECIES asnECIESParameters `asn1:"optional"`
}

func marshalSubjectPublicKeyInfo(pub *PublicKey) (subj asnSubjectPublicKeyInfo, err error) <span class="cov8" title="1">{
        subj.Algorithm = idEcPublicKeySupplemented
        curve, ok := oidFromNamedCurve(pub.Curve)
        if !ok </span><span class="cov0" title="0">{
                err = ErrInvalidPublicKey
                return
        }</span>
        <span class="cov8" title="1">subj.Supplements.ECDomain = curve
        if pub.Params != nil </span><span class="cov8" title="1">{
                subj.Supplements.ECCAlgorithms.ECDH = paramsToASNECDH(pub.Params)
                subj.Supplements.ECCAlgorithms.ECIES = paramsToASNECIES(pub.Params)
        }</span>
        <span class="cov8" title="1">pubkey := elliptic.Marshal(pub.Curve, pub.X, pub.Y)
        subj.PublicKey = asn1.BitString{
                BitLength: len(pubkey) * 8,
                Bytes:     pubkey,
        }
        return</span>
}

// MarshalPublic encodes a public key to DER format.
func MarshalPublic(pub *PublicKey) ([]byte, error) <span class="cov8" title="1">{
        subj, err := marshalSubjectPublicKeyInfo(pub)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return asn1.Marshal(subj)</span>
}

// UnmarshalPublic decodes a DER-encoded public key.
func UnmarshalPublic(in []byte) (pub *PublicKey, err error) <span class="cov8" title="1">{
        var subj asnSubjectPublicKeyInfo

        if _, err = asn1.Unmarshal(in, &amp;subj); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !subj.Algorithm.Equal(idEcPublicKeySupplemented) </span><span class="cov0" title="0">{
                err = ErrInvalidPublicKey
                return
        }</span>
        <span class="cov8" title="1">pub = new(PublicKey)
        pub.Curve = namedCurveFromOID(subj.Supplements.ECDomain)
        x, y := elliptic.Unmarshal(pub.Curve, subj.PublicKey.Bytes)
        if x == nil </span><span class="cov0" title="0">{
                err = ErrInvalidPublicKey
                return
        }</span>
        <span class="cov8" title="1">pub.X = x
        pub.Y = y
        pub.Params = new(ECIESParams)
        asnECIEStoParams(subj.Supplements.ECCAlgorithms.ECIES, pub.Params)
        asnECDHtoParams(subj.Supplements.ECCAlgorithms.ECDH, pub.Params)
        if pub.Params == nil </span><span class="cov0" title="0">{
                if pub.Params = ParamsFromCurve(pub.Curve); pub.Params == nil </span><span class="cov0" title="0">{
                        err = ErrInvalidPublicKey
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func marshalPrivateKey(prv *PrivateKey) (ecprv asnPrivateKey, err error) <span class="cov8" title="1">{
        ecprv.Version = asnECPrivKeyVer1
        ecprv.Private = prv.D.Bytes()

        var ok bool
        ecprv.Curve, ok = oidFromNamedCurve(prv.PublicKey.Curve)
        if !ok </span><span class="cov0" title="0">{
                err = ErrInvalidPrivateKey
                return
        }</span>

        <span class="cov8" title="1">var pub []byte
        if pub, err = MarshalPublic(&amp;prv.PublicKey); err != nil </span><span class="cov0" title="0">{
                return
        }</span><span class="cov8" title="1"> else {
                ecprv.Public = asn1.BitString{
                        BitLength: len(pub) * 8,
                        Bytes:     pub,
                }
        }</span>
        <span class="cov8" title="1">return</span>
}

// MarshalPrivate encodes a private key to DER format.
func MarshalPrivate(prv *PrivateKey) ([]byte, error) <span class="cov8" title="1">{
        ecprv, err := marshalPrivateKey(prv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return asn1.Marshal(ecprv)</span>
}

// UnmarshalPrivate decodes a private key from a DER-encoded format.
func UnmarshalPrivate(in []byte) (prv *PrivateKey, err error) <span class="cov8" title="1">{
        var ecprv asnPrivateKey

        if _, err = asn1.Unmarshal(in, &amp;ecprv); err != nil </span><span class="cov0" title="0">{
                return
        }</span><span class="cov8" title="1"> else if ecprv.Version != asnECPrivKeyVer1 </span><span class="cov0" title="0">{
                err = ErrInvalidPrivateKey
                return
        }</span>

        <span class="cov8" title="1">privateCurve := namedCurveFromOID(ecprv.Curve)
        if privateCurve == nil </span><span class="cov0" title="0">{
                err = ErrInvalidPrivateKey
                return
        }</span>

        <span class="cov8" title="1">prv = new(PrivateKey)
        prv.D = new(big.Int).SetBytes(ecprv.Private)

        if pub, err := UnmarshalPublic(ecprv.Public.Bytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov8" title="1"> else {
                prv.PublicKey = *pub
        }</span>

        <span class="cov8" title="1">return</span>
}

// ExportPublicPEM exports a public key to PEM format.
func ExportPublicPEM(pub *PublicKey) (out []byte, err error) <span class="cov8" title="1">{
        der, err := MarshalPublic(pub)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var block pem.Block
        block.Type = "ELLIPTIC CURVE PUBLIC KEY"
        block.Bytes = der

        buf := new(bytes.Buffer)
        err = pem.Encode(buf, &amp;block)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span><span class="cov8" title="1"> else {
                out = buf.Bytes()
        }</span>
        <span class="cov8" title="1">return</span>
}

// ExportPrivatePEM exports a private key to PEM format.
func ExportPrivatePEM(prv *PrivateKey) (out []byte, err error) <span class="cov8" title="1">{
        der, err := MarshalPrivate(prv)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var block pem.Block
        block.Type = "ELLIPTIC CURVE PRIVATE KEY"
        block.Bytes = der

        buf := new(bytes.Buffer)
        err = pem.Encode(buf, &amp;block)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span><span class="cov8" title="1"> else {
                out = buf.Bytes()
        }</span>
        <span class="cov8" title="1">return</span>
}

// ImportPublicPEM imports a PEM-encoded public key.
func ImportPublicPEM(in []byte) (pub *PublicKey, err error) <span class="cov8" title="1">{
        p, _ := pem.Decode(in)
        if p == nil || p.Type != "ELLIPTIC CURVE PUBLIC KEY" </span><span class="cov0" title="0">{
                return nil, ErrInvalidPublicKey
        }</span>

        <span class="cov8" title="1">pub, err = UnmarshalPublic(p.Bytes)
        return</span>
}

// ImportPrivatePEM imports a PEM-encoded private key.
func ImportPrivatePEM(in []byte) (prv *PrivateKey, err error) <span class="cov8" title="1">{
        p, _ := pem.Decode(in)
        if p == nil || p.Type != "ELLIPTIC CURVE PRIVATE KEY" </span><span class="cov0" title="0">{
                return nil, ErrInvalidPrivateKey
        }</span>

        <span class="cov8" title="1">prv, err = UnmarshalPrivate(p.Bytes)
        return</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package ecies

import (
        "crypto/cipher"
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/hmac"
        "crypto/subtle"
        "fmt"
        "hash"
        "io"
        "math/big"
)

var (
        ErrImport                     = fmt.Errorf("ecies: failed to import key")
        ErrInvalidCurve               = fmt.Errorf("ecies: invalid elliptic curve")
        ErrInvalidParams              = fmt.Errorf("ecies: invalid ECIES parameters")
        ErrInvalidPublicKey           = fmt.Errorf("ecies: invalid public key")
        ErrSharedKeyIsPointAtInfinity = fmt.Errorf("ecies: shared key is point at infinity")
        ErrSharedKeyTooBig            = fmt.Errorf("ecies: shared key params are too big")
)

// PublicKey is a representation of an elliptic curve public key.
type PublicKey struct {
        X *big.Int
        Y *big.Int
        elliptic.Curve
        Params *ECIESParams
}

// ExportECDSA exports an ECIES public key as an ECDSA public key.
func (pub *PublicKey) ExportECDSA() *ecdsa.PublicKey <span class="cov8" title="1">{
        return &amp;ecdsa.PublicKey{pub.Curve, pub.X, pub.Y}
}</span>

// ImportECDSAPublic imports an ECDSA public key as an ECIES public key.
func ImportECDSAPublic(pub *ecdsa.PublicKey) *PublicKey <span class="cov8" title="1">{
        return &amp;PublicKey{
                X:      pub.X,
                Y:      pub.Y,
                Curve:  pub.Curve,
                Params: ParamsFromCurve(pub.Curve),
        }
}</span>

// PrivateKey is a representation of an elliptic curve private key.
type PrivateKey struct {
        PublicKey
        D *big.Int
}

// ExportECDSA exports an ECIES private key as an ECDSA private key.
func (prv *PrivateKey) ExportECDSA() *ecdsa.PrivateKey <span class="cov0" title="0">{
        pub := &amp;prv.PublicKey
        pubECDSA := pub.ExportECDSA()
        return &amp;ecdsa.PrivateKey{*pubECDSA, prv.D}
}</span>

// ImportECDSA imports an ECDSA private key as an ECIES private key.
func ImportECDSA(prv *ecdsa.PrivateKey) *PrivateKey <span class="cov0" title="0">{
        pub := ImportECDSAPublic(&amp;prv.PublicKey)
        return &amp;PrivateKey{*pub, prv.D}
}</span>

// GenerateKey generates an elliptic curve public / private keypair. If params is nil,
// the recommended default paramters for the key will be chosen.
func GenerateKey(rand io.Reader, curve elliptic.Curve, params *ECIESParams) (prv *PrivateKey, err error) <span class="cov8" title="1">{
        pb, x, y, err := elliptic.GenerateKey(curve, rand)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">prv = new(PrivateKey)
        prv.PublicKey.X = x
        prv.PublicKey.Y = y
        prv.PublicKey.Curve = curve
        prv.D = new(big.Int).SetBytes(pb)
        if params == nil </span><span class="cov8" title="1">{
                params = ParamsFromCurve(curve)
        }</span>
        <span class="cov8" title="1">prv.PublicKey.Params = params
        return</span>
}

// MaxSharedKeyLength returns the maximum length of the shared key the
// public key can produce.
func MaxSharedKeyLength(pub *PublicKey) int <span class="cov8" title="1">{
        return (pub.Curve.Params().BitSize + 7) / 8
}</span>

// GenerateShared is an ECDH key agreement method used to establish secret keys for encryption.
func (prv *PrivateKey) GenerateShared(pub *PublicKey, skLen, macLen int) (sk []byte, err error) <span class="cov8" title="1">{
        if prv.PublicKey.Curve != pub.Curve </span><span class="cov0" title="0">{
                return nil, ErrInvalidCurve
        }</span>
        <span class="cov8" title="1">if skLen+macLen &gt; MaxSharedKeyLength(pub) </span><span class="cov8" title="1">{
                return nil, ErrSharedKeyTooBig
        }</span>
        <span class="cov8" title="1">x, _ := pub.Curve.ScalarMult(pub.X, pub.Y, prv.D.Bytes())
        if x == nil </span><span class="cov0" title="0">{
                return nil, ErrSharedKeyIsPointAtInfinity
        }</span>

        <span class="cov8" title="1">sk = make([]byte, skLen+macLen)
        skBytes := x.Bytes()
        copy(sk[len(sk)-len(skBytes):], skBytes)
        return sk, nil</span>
}

var (
        ErrKeyDataTooLong = fmt.Errorf("ecies: can't supply requested key data")
        ErrSharedTooLong  = fmt.Errorf("ecies: shared secret is too long")
        ErrInvalidMessage = fmt.Errorf("ecies: invalid message")
)

var (
        big2To32   = new(big.Int).Exp(big.NewInt(2), big.NewInt(32), nil)
        big2To32M1 = new(big.Int).Sub(big2To32, big.NewInt(1))
)

func incCounter(ctr []byte) <span class="cov8" title="1">{
        if ctr[3]++; ctr[3] != 0 </span><span class="cov8" title="1">{
                return
        }</span><span class="cov0" title="0"> else if ctr[2]++; ctr[2] != 0 </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0"> else if ctr[1]++; ctr[1] != 0 </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0"> else if ctr[0]++; ctr[0] != 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

// concatKDF is a NIST SP 800-56 Concatenation Key Derivation Function (see section 5.8.1).
func concatKDF(hash hash.Hash, z, s1 []byte, kdLen int) (k []byte, err error) <span class="cov8" title="1">{
        if s1 == nil </span><span class="cov8" title="1">{
                s1 = make([]byte, 0)
        }</span>

        <span class="cov8" title="1">reps := ((kdLen + 7) * 8) / (hash.BlockSize() * 8)
        if big.NewInt(int64(reps)).Cmp(big2To32M1) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println(big2To32M1)
                return nil, ErrKeyDataTooLong
        }</span>

        <span class="cov8" title="1">counter := []byte{0, 0, 0, 1}
        k = make([]byte, 0)

        for i := 0; i &lt;= reps; i++ </span><span class="cov8" title="1">{
                hash.Write(counter)
                hash.Write(z)
                hash.Write(s1)
                k = append(k, hash.Sum(nil)...)
                hash.Reset()
                incCounter(counter)
        }</span>

        <span class="cov8" title="1">k = k[:kdLen]
        return</span>
}

// messageTag computes the MAC of a message (called the tag) as per
// SEC 1, 3.5.
func messageTag(hash func() hash.Hash, km, msg, shared []byte) []byte <span class="cov8" title="1">{
        if shared == nil </span><span class="cov8" title="1">{
                shared = make([]byte, 0)
        }</span>
        <span class="cov8" title="1">mac := hmac.New(hash, km)
        mac.Write(msg)
        tag := mac.Sum(nil)
        return tag</span>
}

// generateIV generates an initialisation vector for CTR mode.
func generateIV(params *ECIESParams, rand io.Reader) (iv []byte, err error) <span class="cov8" title="1">{
        iv = make([]byte, params.BlockSize)
        _, err = io.ReadFull(rand, iv)
        return
}</span>

// symEncrypt carries out CTR encryption using the block cipher specified in the
// parameters.
func symEncrypt(rand io.Reader, params *ECIESParams, key, m []byte) (ct []byte, err error) <span class="cov8" title="1">{
        c, err := params.Cipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">iv, err := generateIV(params, rand)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">ctr := cipher.NewCTR(c, iv)

        ct = make([]byte, len(m)+params.BlockSize)
        copy(ct, iv)
        ctr.XORKeyStream(ct[params.BlockSize:], m)
        return</span>
}

// symDecrypt carries out CTR decryption using the block cipher specified in
// the parameters
func symDecrypt(rand io.Reader, params *ECIESParams, key, ct []byte) (m []byte, err error) <span class="cov8" title="1">{
        c, err := params.Cipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">ctr := cipher.NewCTR(c, ct[:params.BlockSize])

        m = make([]byte, len(ct)-params.BlockSize)
        ctr.XORKeyStream(m, ct[params.BlockSize:])
        return</span>
}

// Encrypt encrypts a message using ECIES as specified in SEC 1, 5.1. If
// the shared information parameters aren't being used, they should be
// nil.
func Encrypt(rand io.Reader, pub *PublicKey, m, s1, s2 []byte) (ct []byte, err error) <span class="cov8" title="1">{
        params := pub.Params
        if params == nil </span><span class="cov0" title="0">{
                if params = ParamsFromCurve(pub.Curve); params == nil </span><span class="cov0" title="0">{
                        err = ErrUnsupportedECIESParameters
                        return
                }</span>
        }
        <span class="cov8" title="1">R, err := GenerateKey(rand, pub.Curve, params)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">hash := params.Hash()
        z, err := R.GenerateShared(pub, params.KeyLen, params.KeyLen)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">K, err := concatKDF(hash, z, s1, params.KeyLen+params.KeyLen)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">Ke := K[:params.KeyLen]
        Km := K[params.KeyLen:]
        hash.Write(Km)
        Km = hash.Sum(nil)
        hash.Reset()

        em, err := symEncrypt(rand, params, Ke, m)
        if err != nil || len(em) &lt;= params.BlockSize </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">d := messageTag(params.Hash, Km, em, s2)

        Rb := elliptic.Marshal(pub.Curve, R.PublicKey.X, R.PublicKey.Y)
        ct = make([]byte, len(Rb)+len(em)+len(d))
        copy(ct, Rb)
        copy(ct[len(Rb):], em)
        copy(ct[len(Rb)+len(em):], d)
        return</span>
}

// Decrypt decrypts an ECIES ciphertext.
func (prv *PrivateKey) Decrypt(rand io.Reader, c, s1, s2 []byte) (m []byte, err error) <span class="cov8" title="1">{
        if c == nil || len(c) == 0 </span><span class="cov0" title="0">{
                err = ErrInvalidMessage
                return
        }</span>
        <span class="cov8" title="1">params := prv.PublicKey.Params
        if params == nil </span><span class="cov0" title="0">{
                if params = ParamsFromCurve(prv.PublicKey.Curve); params == nil </span><span class="cov0" title="0">{
                        err = ErrUnsupportedECIESParameters
                        return
                }</span>
        }
        <span class="cov8" title="1">hash := params.Hash()

        var (
                rLen   int
                hLen   int = hash.Size()
                mStart int
                mEnd   int
        )

        switch c[0] </span>{
        case 2, 3, 4:<span class="cov8" title="1">
                rLen = ((prv.PublicKey.Curve.Params().BitSize + 7) / 4)
                if len(c) &lt; (rLen + hLen + 1) </span><span class="cov0" title="0">{
                        err = ErrInvalidMessage
                        return
                }</span>
        default:<span class="cov8" title="1">
                err = ErrInvalidPublicKey
                return</span>
        }

        <span class="cov8" title="1">mStart = rLen
        mEnd = len(c) - hLen

        R := new(PublicKey)
        R.Curve = prv.PublicKey.Curve
        R.X, R.Y = elliptic.Unmarshal(R.Curve, c[:rLen])
        if R.X == nil </span><span class="cov0" title="0">{
                err = ErrInvalidPublicKey
                return
        }</span>

        <span class="cov8" title="1">z, err := prv.GenerateShared(R, params.KeyLen, params.KeyLen)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">K, err := concatKDF(hash, z, s1, params.KeyLen+params.KeyLen)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">Ke := K[:params.KeyLen]
        Km := K[params.KeyLen:]
        hash.Write(Km)
        Km = hash.Sum(nil)
        hash.Reset()

        d := messageTag(params.Hash, Km, c[mStart:mEnd], s2)
        if subtle.ConstantTimeCompare(c[mEnd:], d) != 1 </span><span class="cov8" title="1">{
                err = ErrInvalidMessage
                return
        }</span>

        <span class="cov8" title="1">m, err = symDecrypt(rand, params, Ke, c[mStart:mEnd])
        return</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package ecies

// This file contains parameters for ECIES encryption, specifying the
// symmetric encryption and HMAC parameters.

import (
        "crypto"
        "crypto/aes"
        "crypto/cipher"
        "crypto/elliptic"
        "crypto/sha256"
        "crypto/sha512"
        "fmt"
        "hash"

        seelecrypto "github.com/seeleteam/go-seele/crypto"
)

// The default curve for this package is the NIST P256 curve, which
// provides security equivalent to AES-128.
var DefaultCurve = elliptic.P256()

var (
        ErrUnsupportedECDHAlgorithm   = fmt.Errorf("ecies: unsupported ECDH algorithm")
        ErrUnsupportedECIESParameters = fmt.Errorf("ecies: unsupported ECIES parameters")
)

type ECIESParams struct {
        Hash      func() hash.Hash // hash function
        hashAlgo  crypto.Hash
        Cipher    func([]byte) (cipher.Block, error) // symmetric cipher
        BlockSize int                                // block size of symmetric cipher
        KeyLen    int                                // length of symmetric key
}

// Standard ECIES parameters:
// * ECIES using AES128 and HMAC-SHA-256-16
// * ECIES using AES256 and HMAC-SHA-256-32
// * ECIES using AES256 and HMAC-SHA-384-48
// * ECIES using AES256 and HMAC-SHA-512-64

var (
        ECIES_AES128_SHA256 = &amp;ECIESParams{
                Hash:      sha256.New,
                hashAlgo:  crypto.SHA256,
                Cipher:    aes.NewCipher,
                BlockSize: aes.BlockSize,
                KeyLen:    16,
        }

        ECIES_AES256_SHA256 = &amp;ECIESParams{
                Hash:      sha256.New,
                hashAlgo:  crypto.SHA256,
                Cipher:    aes.NewCipher,
                BlockSize: aes.BlockSize,
                KeyLen:    32,
        }

        ECIES_AES256_SHA384 = &amp;ECIESParams{
                Hash:      sha512.New384,
                hashAlgo:  crypto.SHA384,
                Cipher:    aes.NewCipher,
                BlockSize: aes.BlockSize,
                KeyLen:    32,
        }

        ECIES_AES256_SHA512 = &amp;ECIESParams{
                Hash:      sha512.New,
                hashAlgo:  crypto.SHA512,
                Cipher:    aes.NewCipher,
                BlockSize: aes.BlockSize,
                KeyLen:    32,
        }
)

var paramsFromCurve = map[elliptic.Curve]*ECIESParams{
        seelecrypto.S256(): ECIES_AES128_SHA256, // add item for crypto.secp256k1
        elliptic.P256():    ECIES_AES128_SHA256,
        elliptic.P384():    ECIES_AES256_SHA384,
        elliptic.P521():    ECIES_AES256_SHA512,
}

func AddParamsForCurve(curve elliptic.Curve, params *ECIESParams) <span class="cov0" title="0">{
        paramsFromCurve[curve] = params
}</span>

// ParamsFromCurve selects parameters optimal for the selected elliptic curve.
// Only the curves P256, P384, and P512 are supported.
func ParamsFromCurve(curve elliptic.Curve) (params *ECIESParams) <span class="cov8" title="1">{
        return paramsFromCurve[curve]

        /*
                switch curve {
                case elliptic.P256():
                        return ECIES_AES128_SHA256
                case elliptic.P384():
                        return ECIES_AES256_SHA384
                case elliptic.P521():
                        return ECIES_AES256_SHA512
                default:
                        return nil
                }
        */
}</span>

// ASN.1 encode the ECIES parameters relevant to the encryption operations.
func paramsToASNECIES(params *ECIESParams) (asnParams asnECIESParameters) <span class="cov8" title="1">{
        if nil == params </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">asnParams.KDF = asnNISTConcatenationKDF
        asnParams.MAC = hmacFull
        switch params.KeyLen </span>{
        case 16:<span class="cov8" title="1">
                asnParams.Sym = aes128CTRinECIES</span>
        case 24:<span class="cov0" title="0">
                asnParams.Sym = aes192CTRinECIES</span>
        case 32:<span class="cov0" title="0">
                asnParams.Sym = aes256CTRinECIES</span>
        }
        <span class="cov8" title="1">return</span>
}

// ASN.1 encode the ECIES parameters relevant to ECDH.
func paramsToASNECDH(params *ECIESParams) (algo asnECDHAlgorithm) <span class="cov8" title="1">{
        switch params.hashAlgo </span>{
        case crypto.SHA224:<span class="cov0" title="0">
                algo = dhSinglePass_stdDH_sha224kdf</span>
        case crypto.SHA256:<span class="cov8" title="1">
                algo = dhSinglePass_stdDH_sha256kdf</span>
        case crypto.SHA384:<span class="cov0" title="0">
                algo = dhSinglePass_stdDH_sha384kdf</span>
        case crypto.SHA512:<span class="cov0" title="0">
                algo = dhSinglePass_stdDH_sha512kdf</span>
        }
        <span class="cov8" title="1">return</span>
}

// ASN.1 decode the ECIES parameters relevant to the encryption stage.
func asnECIEStoParams(asnParams asnECIESParameters, params *ECIESParams) <span class="cov8" title="1">{
        if !asnParams.KDF.Cmp(asnNISTConcatenationKDF) </span><span class="cov0" title="0">{
                params = nil
                return
        }</span><span class="cov8" title="1"> else if !asnParams.MAC.Cmp(hmacFull) </span><span class="cov0" title="0">{
                params = nil
                return
        }</span>

        <span class="cov8" title="1">switch </span>{
        case asnParams.Sym.Cmp(aes128CTRinECIES):<span class="cov8" title="1">
                params.KeyLen = 16
                params.BlockSize = 16
                params.Cipher = aes.NewCipher</span>
        case asnParams.Sym.Cmp(aes192CTRinECIES):<span class="cov0" title="0">
                params.KeyLen = 24
                params.BlockSize = 16
                params.Cipher = aes.NewCipher</span>
        case asnParams.Sym.Cmp(aes256CTRinECIES):<span class="cov0" title="0">
                params.KeyLen = 32
                params.BlockSize = 16
                params.Cipher = aes.NewCipher</span>
        default:<span class="cov0" title="0">
                params = nil</span>
        }
}

// ASN.1 decode the ECIES parameters relevant to ECDH.
func asnECDHtoParams(asnParams asnECDHAlgorithm, params *ECIESParams) <span class="cov8" title="1">{
        if asnParams.Cmp(dhSinglePass_stdDH_sha224kdf) </span><span class="cov0" title="0">{
                params.hashAlgo = crypto.SHA224
                params.Hash = sha256.New224
        }</span><span class="cov8" title="1"> else if asnParams.Cmp(dhSinglePass_stdDH_sha256kdf) </span><span class="cov8" title="1">{
                params.hashAlgo = crypto.SHA256
                params.Hash = sha256.New
        }</span><span class="cov0" title="0"> else if asnParams.Cmp(dhSinglePass_stdDH_sha384kdf) </span><span class="cov0" title="0">{
                params.hashAlgo = crypto.SHA384
                params.Hash = sha512.New384
        }</span><span class="cov0" title="0"> else if asnParams.Cmp(dhSinglePass_stdDH_sha512kdf) </span><span class="cov0" title="0">{
                params.hashAlgo = crypto.SHA512
                params.Hash = sha512.New
        }</span><span class="cov0" title="0"> else {
                params = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Copyright 2011 ThePiachu. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
//   copyright notice, this list of conditions and the following disclaimer
//   in the documentation and/or other materials provided with the
//   distribution.
// * Neither the name of Google Inc. nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
// * The name of ThePiachu may not be used to endorse or promote products
//   derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package secp256k1

import (
        "crypto/elliptic"
        "math/big"
        "unsafe"

        "github.com/ethereum/go-ethereum/common/math"
)

/*
#include "libsecp256k1/include/secp256k1.h"
extern int secp256k1_ext_scalar_mul(const secp256k1_context* ctx, const unsigned char *point, const unsigned char *scalar);
*/
import "C"

// This code is from https://github.com/ThePiachu/GoBit and implements
// several Koblitz elliptic curves over prime fields.
//
// The curve methods, internally, on Jacobian coordinates. For a given
// (x, y) position on the curve, the Jacobian coordinates are (x1, y1,
// z1) where x = x1/z1 and y = y1/z1. The greatest speedups come
// when the whole calculation can be performed within the transform
// (as in ScalarMult and ScalarBaseMult). But even for Add and Double,
// it's faster to apply and reverse the transform than to operate in
// affine coordinates.

// A BitCurve represents a Koblitz Curve with a=0.
// See http://www.hyperelliptic.org/EFD/g1p/auto-shortw.html
type BitCurve struct {
        P       *big.Int // the order of the underlying field
        N       *big.Int // the order of the base point
        B       *big.Int // the constant of the BitCurve equation
        Gx, Gy  *big.Int // (x,y) of the base point
        BitSize int      // the size of the underlying field
}

func (BitCurve *BitCurve) Params() *elliptic.CurveParams <span class="cov8" title="1">{
        return &amp;elliptic.CurveParams{
                P:       BitCurve.P,
                N:       BitCurve.N,
                B:       BitCurve.B,
                Gx:      BitCurve.Gx,
                Gy:      BitCurve.Gy,
                BitSize: BitCurve.BitSize,
        }
}</span>

// IsOnBitCurve returns true if the given (x,y) lies on the BitCurve.
func (BitCurve *BitCurve) IsOnCurve(x, y *big.Int) bool <span class="cov0" title="0">{
        // y = x + b
        y2 := new(big.Int).Mul(y, y) //y
        y2.Mod(y2, BitCurve.P)       //y%P

        x3 := new(big.Int).Mul(x, x) //x
        x3.Mul(x3, x)                //x

        x3.Add(x3, BitCurve.B) //x+B
        x3.Mod(x3, BitCurve.P) //(x+B)%P

        return x3.Cmp(y2) == 0
}</span>

//TODO: double check if the function is okay
// affineFromJacobian reverses the Jacobian transform. See the comment at the
// top of the file.
func (BitCurve *BitCurve) affineFromJacobian(x, y, z *big.Int) (xOut, yOut *big.Int) <span class="cov0" title="0">{
        zinv := new(big.Int).ModInverse(z, BitCurve.P)
        zinvsq := new(big.Int).Mul(zinv, zinv)

        xOut = new(big.Int).Mul(x, zinvsq)
        xOut.Mod(xOut, BitCurve.P)
        zinvsq.Mul(zinvsq, zinv)
        yOut = new(big.Int).Mul(y, zinvsq)
        yOut.Mod(yOut, BitCurve.P)
        return
}</span>

// Add returns the sum of (x1,y1) and (x2,y2)
func (BitCurve *BitCurve) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int) <span class="cov0" title="0">{
        z := new(big.Int).SetInt64(1)
        return BitCurve.affineFromJacobian(BitCurve.addJacobian(x1, y1, z, x2, y2, z))
}</span>

// addJacobian takes two points in Jacobian coordinates, (x1, y1, z1) and
// (x2, y2, z2) and returns their sum, also in Jacobian form.
func (BitCurve *BitCurve) addJacobian(x1, y1, z1, x2, y2, z2 *big.Int) (*big.Int, *big.Int, *big.Int) <span class="cov0" title="0">{
        // See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl
        z1z1 := new(big.Int).Mul(z1, z1)
        z1z1.Mod(z1z1, BitCurve.P)
        z2z2 := new(big.Int).Mul(z2, z2)
        z2z2.Mod(z2z2, BitCurve.P)

        u1 := new(big.Int).Mul(x1, z2z2)
        u1.Mod(u1, BitCurve.P)
        u2 := new(big.Int).Mul(x2, z1z1)
        u2.Mod(u2, BitCurve.P)
        h := new(big.Int).Sub(u2, u1)
        if h.Sign() == -1 </span><span class="cov0" title="0">{
                h.Add(h, BitCurve.P)
        }</span>
        <span class="cov0" title="0">i := new(big.Int).Lsh(h, 1)
        i.Mul(i, i)
        j := new(big.Int).Mul(h, i)

        s1 := new(big.Int).Mul(y1, z2)
        s1.Mul(s1, z2z2)
        s1.Mod(s1, BitCurve.P)
        s2 := new(big.Int).Mul(y2, z1)
        s2.Mul(s2, z1z1)
        s2.Mod(s2, BitCurve.P)
        r := new(big.Int).Sub(s2, s1)
        if r.Sign() == -1 </span><span class="cov0" title="0">{
                r.Add(r, BitCurve.P)
        }</span>
        <span class="cov0" title="0">r.Lsh(r, 1)
        v := new(big.Int).Mul(u1, i)

        x3 := new(big.Int).Set(r)
        x3.Mul(x3, x3)
        x3.Sub(x3, j)
        x3.Sub(x3, v)
        x3.Sub(x3, v)
        x3.Mod(x3, BitCurve.P)

        y3 := new(big.Int).Set(r)
        v.Sub(v, x3)
        y3.Mul(y3, v)
        s1.Mul(s1, j)
        s1.Lsh(s1, 1)
        y3.Sub(y3, s1)
        y3.Mod(y3, BitCurve.P)

        z3 := new(big.Int).Add(z1, z2)
        z3.Mul(z3, z3)
        z3.Sub(z3, z1z1)
        if z3.Sign() == -1 </span><span class="cov0" title="0">{
                z3.Add(z3, BitCurve.P)
        }</span>
        <span class="cov0" title="0">z3.Sub(z3, z2z2)
        if z3.Sign() == -1 </span><span class="cov0" title="0">{
                z3.Add(z3, BitCurve.P)
        }</span>
        <span class="cov0" title="0">z3.Mul(z3, h)
        z3.Mod(z3, BitCurve.P)

        return x3, y3, z3</span>
}

// Double returns 2*(x,y)
func (BitCurve *BitCurve) Double(x1, y1 *big.Int) (*big.Int, *big.Int) <span class="cov0" title="0">{
        z1 := new(big.Int).SetInt64(1)
        return BitCurve.affineFromJacobian(BitCurve.doubleJacobian(x1, y1, z1))
}</span>

// doubleJacobian takes a point in Jacobian coordinates, (x, y, z), and
// returns its double, also in Jacobian form.
func (BitCurve *BitCurve) doubleJacobian(x, y, z *big.Int) (*big.Int, *big.Int, *big.Int) <span class="cov0" title="0">{
        // See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l

        a := new(big.Int).Mul(x, x) //X1
        b := new(big.Int).Mul(y, y) //Y1
        c := new(big.Int).Mul(b, b) //B

        d := new(big.Int).Add(x, b) //X1+B
        d.Mul(d, d)                 //(X1+B)
        d.Sub(d, a)                 //(X1+B)-A
        d.Sub(d, c)                 //(X1+B)-A-C
        d.Mul(d, big.NewInt(2))     //2*((X1+B)-A-C)

        e := new(big.Int).Mul(big.NewInt(3), a) //3*A
        f := new(big.Int).Mul(e, e)             //E

        x3 := new(big.Int).Mul(big.NewInt(2), d) //2*D
        x3.Sub(f, x3)                            //F-2*D
        x3.Mod(x3, BitCurve.P)

        y3 := new(big.Int).Sub(d, x3)                  //D-X3
        y3.Mul(e, y3)                                  //E*(D-X3)
        y3.Sub(y3, new(big.Int).Mul(big.NewInt(8), c)) //E*(D-X3)-8*C
        y3.Mod(y3, BitCurve.P)

        z3 := new(big.Int).Mul(y, z) //Y1*Z1
        z3.Mul(big.NewInt(2), z3)    //3*Y1*Z1
        z3.Mod(z3, BitCurve.P)

        return x3, y3, z3
}</span>

func (BitCurve *BitCurve) ScalarMult(Bx, By *big.Int, scalar []byte) (*big.Int, *big.Int) <span class="cov8" title="1">{
        // Ensure scalar is exactly 32 bytes. We pad always, even if
        // scalar is 32 bytes long, to avoid a timing side channel.
        if len(scalar) &gt; 32 </span><span class="cov0" title="0">{
                panic("can't handle scalars &gt; 256 bits")</span>
        }
        // NOTE: potential timing issue
        <span class="cov8" title="1">padded := make([]byte, 32)
        copy(padded[32-len(scalar):], scalar)
        scalar = padded

        // Do the multiplication in C, updating point.
        point := make([]byte, 64)
        math.ReadBits(Bx, point[:32])
        math.ReadBits(By, point[32:])
        pointPtr := (*C.uchar)(unsafe.Pointer(&amp;point[0]))
        scalarPtr := (*C.uchar)(unsafe.Pointer(&amp;scalar[0]))
        res := C.secp256k1_ext_scalar_mul(context, pointPtr, scalarPtr)

        // Unpack the result and clear temporaries.
        x := new(big.Int).SetBytes(point[:32])
        y := new(big.Int).SetBytes(point[32:])
        for i := range point </span><span class="cov8" title="1">{
                point[i] = 0
        }</span>
        <span class="cov8" title="1">for i := range padded </span><span class="cov8" title="1">{
                scalar[i] = 0
        }</span>
        <span class="cov8" title="1">if res != 1 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return x, y</span>
}

// ScalarBaseMult returns k*G, where G is the base point of the group and k is
// an integer in big-endian form.
func (BitCurve *BitCurve) ScalarBaseMult(k []byte) (*big.Int, *big.Int) <span class="cov8" title="1">{
        return BitCurve.ScalarMult(BitCurve.Gx, BitCurve.Gy, k)
}</span>

// Marshal converts a point into the form specified in section 4.3.6 of ANSI
// X9.62.
func (BitCurve *BitCurve) Marshal(x, y *big.Int) []byte <span class="cov0" title="0">{
        byteLen := (BitCurve.BitSize + 7) &gt;&gt; 3
        ret := make([]byte, 1+2*byteLen)
        ret[0] = 4 // uncompressed point flag
        math.ReadBits(x, ret[1:1+byteLen])
        math.ReadBits(y, ret[1+byteLen:])
        return ret
}</span>

// Unmarshal converts a point, serialised by Marshal, into an x, y pair. On
// error, x = nil.
func (BitCurve *BitCurve) Unmarshal(data []byte) (x, y *big.Int) <span class="cov0" title="0">{
        byteLen := (BitCurve.BitSize + 7) &gt;&gt; 3
        if len(data) != 1+2*byteLen </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if data[0] != 4 </span><span class="cov0" title="0">{ // uncompressed form
                return
        }</span>
        <span class="cov0" title="0">x = new(big.Int).SetBytes(data[1 : 1+byteLen])
        y = new(big.Int).SetBytes(data[1+byteLen:])
        return</span>
}

var theCurve = new(BitCurve)

func init() <span class="cov8" title="1">{
        // See SEC 2 section 2.7.1
        // curve parameters taken from:
        // http://www.secg.org/collateral/sec2_final.pdf
        theCurve.P, _ = new(big.Int).SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", 16)
        theCurve.N, _ = new(big.Int).SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16)
        theCurve.B, _ = new(big.Int).SetString("0000000000000000000000000000000000000000000000000000000000000007", 16)
        theCurve.Gx, _ = new(big.Int).SetString("79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", 16)
        theCurve.Gy, _ = new(big.Int).SetString("483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", 16)
        theCurve.BitSize = 256
}</span>

// S256 returns a BitCurve which implements secp256k1.
func S256() *BitCurve <span class="cov8" title="1">{
        return theCurve
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package secp256k1

import "C"
import "unsafe"

// Callbacks for converting libsecp256k1 internal faults into
// recoverable Go panics.

//export secp256k1GoPanicIllegal
func secp256k1GoPanicIllegal(msg *C.char, data unsafe.Pointer) <span class="cov0" title="0">{
        panic("illegal argument: " + C.GoString(msg))</span>
}

//export secp256k1GoPanicError
func secp256k1GoPanicError(msg *C.char, data unsafe.Pointer) <span class="cov0" title="0">{
        panic("internal error: " + C.GoString(msg))</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

// Package secp256k1 wraps the bitcoin secp256k1 C library.
package secp256k1

/*
#cgo CFLAGS: -I./libsecp256k1
#cgo CFLAGS: -I./libsecp256k1/src/
#define USE_NUM_NONE
#define USE_FIELD_10X26
#define USE_FIELD_INV_BUILTIN
#define USE_SCALAR_8X32
#define USE_SCALAR_INV_BUILTIN
#define NDEBUG
#include "./libsecp256k1/src/secp256k1.c"
#include "./libsecp256k1/src/modules/recovery/main_impl.h"
#include "ext.h"

typedef void (*callbackFunc) (const char* msg, void* data);
extern void secp256k1GoPanicIllegal(const char* msg, void* data);
extern void secp256k1GoPanicError(const char* msg, void* data);
*/
import "C"

import (
        "errors"
        "math/big"
        "unsafe"
)

var context *C.secp256k1_context

func init() <span class="cov8" title="1">{
        // around 20 ms on a modern CPU.
        context = C.secp256k1_context_create_sign_verify()
        C.secp256k1_context_set_illegal_callback(context, C.callbackFunc(C.secp256k1GoPanicIllegal), nil)
        C.secp256k1_context_set_error_callback(context, C.callbackFunc(C.secp256k1GoPanicError), nil)
}</span>

var (
        ErrInvalidMsgLen       = errors.New("invalid message length, need 32 bytes")
        ErrInvalidSignatureLen = errors.New("invalid signature length")
        ErrInvalidRecoveryID   = errors.New("invalid signature recovery id")
        ErrInvalidKey          = errors.New("invalid private key")
        ErrInvalidPubkey       = errors.New("invalid public key")
        ErrSignFailed          = errors.New("signing failed")
        ErrRecoverFailed       = errors.New("recovery failed")
)

// Sign creates a recoverable ECDSA signature.
// The produced signature is in the 65-byte [R || S || V] format where V is 0 or 1.
//
// The caller is responsible for ensuring that msg cannot be chosen
// directly by an attacker. It is usually preferable to use a cryptographic
// hash function on any input before handing it to this function.
func Sign(msg []byte, seckey []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(msg) != 32 </span><span class="cov0" title="0">{
                return nil, ErrInvalidMsgLen
        }</span>
        <span class="cov8" title="1">if len(seckey) != 32 </span><span class="cov0" title="0">{
                return nil, ErrInvalidKey
        }</span>
        <span class="cov8" title="1">seckeydata := (*C.uchar)(unsafe.Pointer(&amp;seckey[0]))
        if C.secp256k1_ec_seckey_verify(context, seckeydata) != 1 </span><span class="cov0" title="0">{
                return nil, ErrInvalidKey
        }</span>

        <span class="cov8" title="1">var (
                msgdata   = (*C.uchar)(unsafe.Pointer(&amp;msg[0]))
                noncefunc = C.secp256k1_nonce_function_rfc6979
                sigstruct C.secp256k1_ecdsa_recoverable_signature
        )
        if C.secp256k1_ecdsa_sign_recoverable(context, &amp;sigstruct, msgdata, seckeydata, noncefunc, nil) == 0 </span><span class="cov0" title="0">{
                return nil, ErrSignFailed
        }</span>

        <span class="cov8" title="1">var (
                sig     = make([]byte, 65)
                sigdata = (*C.uchar)(unsafe.Pointer(&amp;sig[0]))
                recid   C.int
        )
        C.secp256k1_ecdsa_recoverable_signature_serialize_compact(context, sigdata, &amp;recid, &amp;sigstruct)
        sig[64] = byte(recid) // add back recid to get 65 bytes sig
        return sig, nil</span>
}

// RecoverPubkey returns the the public key of the signer.
// msg must be the 32-byte hash of the message to be signed.
// sig must be a 65-byte compact ECDSA signature containing the
// recovery id as the last element.
func RecoverPubkey(msg []byte, sig []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(msg) != 32 </span><span class="cov0" title="0">{
                return nil, ErrInvalidMsgLen
        }</span>
        <span class="cov8" title="1">if err := checkSignature(sig); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                pubkey  = make([]byte, 65)
                sigdata = (*C.uchar)(unsafe.Pointer(&amp;sig[0]))
                msgdata = (*C.uchar)(unsafe.Pointer(&amp;msg[0]))
        )
        if C.secp256k1_ext_ecdsa_recover(context, (*C.uchar)(unsafe.Pointer(&amp;pubkey[0])), sigdata, msgdata) == 0 </span><span class="cov8" title="1">{
                return nil, ErrRecoverFailed
        }</span>
        <span class="cov8" title="1">return pubkey, nil</span>
}

// VerifySignature checks that the given pubkey created signature over message.
// The signature should be in [R || S] format.
func VerifySignature(pubkey, msg, signature []byte) bool <span class="cov0" title="0">{
        if len(msg) != 32 || len(signature) != 64 || len(pubkey) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">sigdata := (*C.uchar)(unsafe.Pointer(&amp;signature[0]))
        msgdata := (*C.uchar)(unsafe.Pointer(&amp;msg[0]))
        keydata := (*C.uchar)(unsafe.Pointer(&amp;pubkey[0]))
        return C.secp256k1_ext_ecdsa_verify(context, sigdata, msgdata, keydata, C.size_t(len(pubkey))) != 0</span>
}

// DecompressPubkey parses a public key in the 33-byte compressed format.
// It returns non-nil coordinates if the public key is valid.
func DecompressPubkey(pubkey []byte) (x, y *big.Int) <span class="cov0" title="0">{
        if len(pubkey) != 33 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">var (
                pubkeydata = (*C.uchar)(unsafe.Pointer(&amp;pubkey[0]))
                pubkeylen  = C.size_t(len(pubkey))
                out        = make([]byte, 65)
                outdata    = (*C.uchar)(unsafe.Pointer(&amp;out[0]))
                outlen     = C.size_t(len(out))
        )
        if C.secp256k1_ext_reencode_pubkey(context, outdata, outlen, pubkeydata, pubkeylen) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return new(big.Int).SetBytes(out[1:33]), new(big.Int).SetBytes(out[33:])</span>
}

// CompressPubkey encodes a public key to 33-byte compressed format.
func CompressPubkey(x, y *big.Int) []byte <span class="cov0" title="0">{
        var (
                pubkey     = S256().Marshal(x, y)
                pubkeydata = (*C.uchar)(unsafe.Pointer(&amp;pubkey[0]))
                pubkeylen  = C.size_t(len(pubkey))
                out        = make([]byte, 33)
                outdata    = (*C.uchar)(unsafe.Pointer(&amp;out[0]))
                outlen     = C.size_t(len(out))
        )
        if C.secp256k1_ext_reencode_pubkey(context, outdata, outlen, pubkeydata, pubkeylen) == 0 </span><span class="cov0" title="0">{
                panic("libsecp256k1 error")</span>
        }
        <span class="cov0" title="0">return out</span>
}

func checkSignature(sig []byte) error <span class="cov8" title="1">{
        if len(sig) != 65 </span><span class="cov0" title="0">{
                return ErrInvalidSignatureLen
        }</span>
        <span class="cov8" title="1">if sig[64] &gt;= 4 </span><span class="cov8" title="1">{
                return ErrInvalidRecoveryID
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package crypto

import (
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto/sha3"
)

// keccak256Hash calculates and returns the Keccak256 hash of the input data,
// converting it to an internal Hash data structure.
func keccak256Hash(data ...[]byte) []byte <span class="cov8" title="1">{
        d := sha3.NewKeccak256()
        for _, b := range data </span><span class="cov8" title="1">{
                d.Write(b)
        }</span>

        <span class="cov8" title="1">h := make([]byte, common.HashLength)
        d.Sum(h[:0])
        return h</span>
}

// HashBytes returns the hash of the input data.
func HashBytes(data ...[]byte) common.Hash <span class="cov8" title="1">{
        return common.BytesToHash(keccak256Hash(data...))
}</span>

// MustHash returns the hash of the specified value.
// Panic on any error, e.g. unsupported data type for encoding.
func MustHash(v interface{}) common.Hash <span class="cov8" title="1">{
        return HashBytes(common.SerializePanic(v))
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package sha3

// This file provides functions for creating instances of the SHA-3
// and SHAKE hash functions, as well as utility functions for hashing
// bytes.

import (
        "hash"
)

// NewKeccak256 creates a new Keccak-256 hash.
func NewKeccak256() hash.Hash <span class="cov8" title="1">{ return &amp;state{rate: 136, outputLen: 32, dsbyte: 0x01} }</span>

// NewKeccak512 creates a new Keccak-512 hash.
func NewKeccak512() hash.Hash <span class="cov8" title="1">{ return &amp;state{rate: 72, outputLen: 64, dsbyte: 0x01} }</span>

// New224 creates a new SHA3-224 hash.
// Its generic security strength is 224 bits against preimage attacks,
// and 112 bits against collision attacks.
func New224() hash.Hash <span class="cov8" title="1">{ return &amp;state{rate: 144, outputLen: 28, dsbyte: 0x06} }</span>

// New256 creates a new SHA3-256 hash.
// Its generic security strength is 256 bits against preimage attacks,
// and 128 bits against collision attacks.
func New256() hash.Hash <span class="cov8" title="1">{ return &amp;state{rate: 136, outputLen: 32, dsbyte: 0x06} }</span>

// New384 creates a new SHA3-384 hash.
// Its generic security strength is 384 bits against preimage attacks,
// and 192 bits against collision attacks.
func New384() hash.Hash <span class="cov8" title="1">{ return &amp;state{rate: 104, outputLen: 48, dsbyte: 0x06} }</span>

// New512 creates a new SHA3-512 hash.
// Its generic security strength is 512 bits against preimage attacks,
// and 256 bits against collision attacks.
func New512() hash.Hash <span class="cov8" title="1">{ return &amp;state{rate: 72, outputLen: 64, dsbyte: 0x06} }</span>

// Sum224 returns the SHA3-224 digest of the data.
func Sum224(data []byte) (digest [28]byte) <span class="cov8" title="1">{
        h := New224()
        h.Write(data)
        h.Sum(digest[:0])
        return
}</span>

// Sum256 returns the SHA3-256 digest of the data.
func Sum256(data []byte) (digest [32]byte) <span class="cov8" title="1">{
        h := New256()
        h.Write(data)
        h.Sum(digest[:0])
        return
}</span>

// Sum384 returns the SHA3-384 digest of the data.
func Sum384(data []byte) (digest [48]byte) <span class="cov8" title="1">{
        h := New384()
        h.Write(data)
        h.Sum(digest[:0])
        return
}</span>

// Sum512 returns the SHA3-512 digest of the data.
func Sum512(data []byte) (digest [64]byte) <span class="cov8" title="1">{
        h := New512()
        h.Write(data)
        h.Sum(digest[:0])
        return
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build go1.4

package sha3

import (
        "crypto"
)

func init() <span class="cov8" title="1">{
        crypto.RegisterHash(crypto.SHA3_224, New224)
        crypto.RegisterHash(crypto.SHA3_256, New256)
        crypto.RegisterHash(crypto.SHA3_384, New384)
        crypto.RegisterHash(crypto.SHA3_512, New512)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package sha3

// spongeDirection indicates the direction bytes are flowing through the sponge.
type spongeDirection int

const (
        // spongeAbsorbing indicates that the sponge is absorbing input.
        spongeAbsorbing spongeDirection = iota
        // spongeSqueezing indicates that the sponge is being squeezed.
        spongeSqueezing
)

const (
        // maxRate is the maximum size of the internal buffer. SHAKE-256
        // currently needs the largest buffer.
        maxRate = 168
)

type state struct {
        // Generic sponge components.
        a    [25]uint64 // main state of the hash
        buf  []byte     // points into storage
        rate int        // the number of bytes of state to use

        // dsbyte contains the "domain separation" bits and the first bit of
        // the padding. Sections 6.1 and 6.2 of [1] separate the outputs of the
        // SHA-3 and SHAKE functions by appending bitstrings to the message.
        // Using a little-endian bit-ordering convention, these are "01" for SHA-3
        // and "1111" for SHAKE, or 00000010b and 00001111b, respectively. Then the
        // padding rule from section 5.1 is applied to pad the message to a multiple
        // of the rate, which involves adding a "1" bit, zero or more "0" bits, and
        // a final "1" bit. We merge the first "1" bit from the padding into dsbyte,
        // giving 00000110b (0x06) and 00011111b (0x1f).
        // [1] http://csrc.nist.gov/publications/drafts/fips-202/fips_202_draft.pdf
        //     "Draft FIPS 202: SHA-3 Standard: Permutation-Based Hash and
        //      Extendable-Output Functions (May 2014)"
        dsbyte  byte
        storage [maxRate]byte

        // Specific to SHA-3 and SHAKE.
        outputLen int             // the default output size in bytes
        state     spongeDirection // whether the sponge is absorbing or squeezing
}

// BlockSize returns the rate of sponge underlying this hash function.
func (d *state) BlockSize() int <span class="cov8" title="1">{ return d.rate }</span>

// Size returns the output size of the hash function in bytes.
func (d *state) Size() int <span class="cov8" title="1">{ return d.outputLen }</span>

// Reset clears the internal state by zeroing the sponge state and
// the byte buffer, and setting Sponge.state to absorbing.
func (d *state) Reset() <span class="cov8" title="1">{
        // Zero the permutation's state.
        for i := range d.a </span><span class="cov8" title="1">{
                d.a[i] = 0
        }</span>
        <span class="cov8" title="1">d.state = spongeAbsorbing
        d.buf = d.storage[:0]</span>
}

func (d *state) clone() *state <span class="cov8" title="1">{
        ret := *d
        if ret.state == spongeAbsorbing </span><span class="cov8" title="1">{
                ret.buf = ret.storage[:len(ret.buf)]
        }</span><span class="cov0" title="0"> else {
                ret.buf = ret.storage[d.rate-cap(d.buf) : d.rate]
        }</span>

        <span class="cov8" title="1">return &amp;ret</span>
}

// permute applies the KeccakF-1600 permutation. It handles
// any input-output buffering.
func (d *state) permute() <span class="cov8" title="1">{
        switch d.state </span>{
        case spongeAbsorbing:<span class="cov8" title="1">
                // If we're absorbing, we need to xor the input into the state
                // before applying the permutation.
                xorIn(d, d.buf)
                d.buf = d.storage[:0]
                keccakF1600(&amp;d.a)</span>
        case spongeSqueezing:<span class="cov8" title="1">
                // If we're squeezing, we need to apply the permutatin before
                // copying more output.
                keccakF1600(&amp;d.a)
                d.buf = d.storage[:d.rate]
                copyOut(d, d.buf)</span>
        }
}

// pads appends the domain separation bits in dsbyte, applies
// the multi-bitrate 10..1 padding rule, and permutes the state.
func (d *state) padAndPermute(dsbyte byte) <span class="cov8" title="1">{
        if d.buf == nil </span><span class="cov0" title="0">{
                d.buf = d.storage[:0]
        }</span>
        // Pad with this instance's domain-separator bits. We know that there's
        // at least one byte of space in d.buf because, if it were full,
        // permute would have been called to empty it. dsbyte also contains the
        // first one bit for the padding. See the comment in the state struct.
        <span class="cov8" title="1">d.buf = append(d.buf, dsbyte)
        zerosStart := len(d.buf)
        d.buf = d.storage[:d.rate]
        for i := zerosStart; i &lt; d.rate; i++ </span><span class="cov8" title="1">{
                d.buf[i] = 0
        }</span>
        // This adds the final one bit for the padding. Because of the way that
        // bits are numbered from the LSB upwards, the final bit is the MSB of
        // the last byte.
        <span class="cov8" title="1">d.buf[d.rate-1] ^= 0x80
        // Apply the permutation
        d.permute()
        d.state = spongeSqueezing
        d.buf = d.storage[:d.rate]
        copyOut(d, d.buf)</span>
}

// Write absorbs more data into the hash's state. It produces an error
// if more data is written to the ShakeHash after writing
func (d *state) Write(p []byte) (written int, err error) <span class="cov8" title="1">{
        if d.state != spongeAbsorbing </span><span class="cov0" title="0">{
                panic("sha3: write to sponge after read")</span>
        }
        <span class="cov8" title="1">if d.buf == nil </span><span class="cov8" title="1">{
                d.buf = d.storage[:0]
        }</span>
        <span class="cov8" title="1">written = len(p)

        for len(p) &gt; 0 </span><span class="cov8" title="1">{
                if len(d.buf) == 0 &amp;&amp; len(p) &gt;= d.rate </span><span class="cov8" title="1">{
                        // The fast path; absorb a full "rate" bytes of input and apply the permutation.
                        xorIn(d, p[:d.rate])
                        p = p[d.rate:]
                        keccakF1600(&amp;d.a)
                }</span><span class="cov8" title="1"> else {
                        // The slow path; buffer the input until we can fill the sponge, and then xor it in.
                        todo := d.rate - len(d.buf)
                        if todo &gt; len(p) </span><span class="cov8" title="1">{
                                todo = len(p)
                        }</span>
                        <span class="cov8" title="1">d.buf = append(d.buf, p[:todo]...)
                        p = p[todo:]

                        // If the sponge is full, apply the permutation.
                        if len(d.buf) == d.rate </span><span class="cov8" title="1">{
                                d.permute()
                        }</span>
                }
        }

        <span class="cov8" title="1">return</span>
}

// Read squeezes an arbitrary number of bytes from the sponge.
func (d *state) Read(out []byte) (n int, err error) <span class="cov8" title="1">{
        // If we're still absorbing, pad and apply the permutation.
        if d.state == spongeAbsorbing </span><span class="cov8" title="1">{
                d.padAndPermute(d.dsbyte)
        }</span>

        <span class="cov8" title="1">n = len(out)

        // Now, do the squeezing.
        for len(out) &gt; 0 </span><span class="cov8" title="1">{
                n := copy(out, d.buf)
                d.buf = d.buf[n:]
                out = out[n:]

                // Apply the permutation if we've squeezed the sponge dry.
                if len(d.buf) == 0 </span><span class="cov8" title="1">{
                        d.permute()
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

// Sum applies padding to the hash state and then squeezes out the desired
// number of output bytes.
func (d *state) Sum(in []byte) []byte <span class="cov8" title="1">{
        // Make a copy of the original hash so that caller can keep writing
        // and summing.
        dup := d.clone()
        hash := make([]byte, dup.outputLen)
        dup.Read(hash)
        return append(in, hash...)
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package sha3

// This file defines the ShakeHash interface, and provides
// functions for creating SHAKE instances, as well as utility
// functions for hashing bytes to arbitrary-length output.

import (
        "io"
)

// ShakeHash defines the interface to hash functions that
// support arbitrary-length output.
type ShakeHash interface {
        // Write absorbs more data into the hash's state. It panics if input is
        // written to it after output has been read from it.
        io.Writer

        // Read reads more output from the hash; reading affects the hash's
        // state. (ShakeHash.Read is thus very different from Hash.Sum)
        // It never returns an error.
        io.Reader

        // Clone returns a copy of the ShakeHash in its current state.
        Clone() ShakeHash

        // Reset resets the ShakeHash to its initial state.
        Reset()
}

func (d *state) Clone() ShakeHash <span class="cov0" title="0">{
        return d.clone()
}</span>

// NewShake128 creates a new SHAKE128 variable-output-length ShakeHash.
// Its generic security strength is 128 bits against all attacks if at
// least 32 bytes of its output are used.
func NewShake128() ShakeHash <span class="cov8" title="1">{ return &amp;state{rate: 168, dsbyte: 0x1f} }</span>

// NewShake256 creates a new SHAKE128 variable-output-length ShakeHash.
// Its generic security strength is 256 bits against all attacks if
// at least 64 bytes of its output are used.
func NewShake256() ShakeHash <span class="cov8" title="1">{ return &amp;state{rate: 136, dsbyte: 0x1f} }</span>

// ShakeSum128 writes an arbitrary-length digest of data into hash.
func ShakeSum128(hash, data []byte) <span class="cov0" title="0">{
        h := NewShake128()
        h.Write(data)
        h.Read(hash)
}</span>

// ShakeSum256 writes an arbitrary-length digest of data into hash.
func ShakeSum256(hash, data []byte) <span class="cov0" title="0">{
        h := NewShake256()
        h.Write(data)
        h.Read(hash)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package sha3

import "encoding/binary"

// xorInGeneric xors the bytes in buf into the state; it
// makes no non-portable assumptions about memory layout
// or alignment.
func xorInGeneric(d *state, buf []byte) <span class="cov8" title="1">{
        n := len(buf) / 8

        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                a := binary.LittleEndian.Uint64(buf)
                d.a[i] ^= a
                buf = buf[8:]
        }</span>
}

// copyOutGeneric copies ulint64s to a byte buffer.
func copyOutGeneric(d *state, b []byte) <span class="cov8" title="1">{
        for i := 0; len(b) &gt;= 8; i++ </span><span class="cov8" title="1">{
                binary.LittleEndian.PutUint64(b, d.a[i])
                b = b[8:]
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64 386 ppc64le
// +build !appengine

package sha3

import "unsafe"

func xorInUnaligned(d *state, buf []byte) <span class="cov8" title="1">{
        bw := (*[maxRate / 8]uint64)(unsafe.Pointer(&amp;buf[0]))
        n := len(buf)
        if n &gt;= 72 </span><span class="cov8" title="1">{
                d.a[0] ^= bw[0]
                d.a[1] ^= bw[1]
                d.a[2] ^= bw[2]
                d.a[3] ^= bw[3]
                d.a[4] ^= bw[4]
                d.a[5] ^= bw[5]
                d.a[6] ^= bw[6]
                d.a[7] ^= bw[7]
                d.a[8] ^= bw[8]
        }</span>
        <span class="cov8" title="1">if n &gt;= 104 </span><span class="cov8" title="1">{
                d.a[9] ^= bw[9]
                d.a[10] ^= bw[10]
                d.a[11] ^= bw[11]
                d.a[12] ^= bw[12]
        }</span>
        <span class="cov8" title="1">if n &gt;= 136 </span><span class="cov8" title="1">{
                d.a[13] ^= bw[13]
                d.a[14] ^= bw[14]
                d.a[15] ^= bw[15]
                d.a[16] ^= bw[16]
        }</span>
        <span class="cov8" title="1">if n &gt;= 144 </span><span class="cov8" title="1">{
                d.a[17] ^= bw[17]
        }</span>
        <span class="cov8" title="1">if n &gt;= 168 </span><span class="cov8" title="1">{
                d.a[18] ^= bw[18]
                d.a[19] ^= bw[19]
                d.a[20] ^= bw[20]
        }</span>
}

func copyOutUnaligned(d *state, buf []byte) <span class="cov8" title="1">{
        ab := (*[maxRate]uint8)(unsafe.Pointer(&amp;d.a[0]))
        copy(buf, ab[:])
}</span>

var (
        xorIn   = xorInUnaligned
        copyOut = copyOutUnaligned
)

const xorImplementationUnaligned = "unaligned"
</pre>
		
		<pre class="file" id="file51" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package crypto

import (
        "crypto/ecdsa"
        "crypto/elliptic"

        "github.com/ethereum/go-ethereum/common/math"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto/secp256k1"
)

// Signature is a wrapper for the signed message and it is serializable.
type Signature struct {
        Sig []byte // [R || S || V] format signature in 65 bytes.
}

// MustSign signs the specified hash with private key and returns a signature.
// Panic if failed to sign the hash.
func MustSign(privKey *ecdsa.PrivateKey, hash []byte) *Signature <span class="cov8" title="1">{
        sig, err := Sign(privKey, hash)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return sig</span>
}

// Sign signs the specified bytes with private key and returns a signature.
func Sign(privKey *ecdsa.PrivateKey, buff []byte) (*Signature, error) <span class="cov8" title="1">{
        secKey := math.PaddedBigBytes(privKey.D, privKey.Params().BitSize/8)
        defer func(bytes []byte) </span><span class="cov8" title="1">{
                for i := range bytes </span><span class="cov8" title="1">{
                        bytes[i] = 0
                }</span>
        }(secKey)

        <span class="cov8" title="1">sig, err := secp256k1.Sign(buff, secKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Signature{sig}, nil</span>
}

// Verify verifies the signature against the specified hash.
// Return true if the signature is valid, otherwise false.
func (s Signature) Verify(signer common.Address, hash []byte) bool <span class="cov8" title="1">{
        if len(s.Sig) != 65 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">pubKey, err := s.recoverPubKey(hash)
        if err != nil </span><span class="cov0" title="0">{
                return false // Signature was modified
        }</span>

        <span class="cov8" title="1">if !GetAddress(pubKey).Equal(signer) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">compressed := secp256k1.CompressPubkey(pubKey.X, pubKey.Y)
        return secp256k1.VerifySignature(compressed, hash, s.Sig[:64])</span>
}

func (s Signature) recoverPubKey(msg []byte) (*ecdsa.PublicKey, error) <span class="cov8" title="1">{
        pubKey, err := secp256k1.RecoverPubkey(msg, s.Sig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">curve := secp256k1.S256()
        x, y := elliptic.Unmarshal(curve, pubKey)
        return &amp;ecdsa.PublicKey{curve, x, y}, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package leveldb

import (
        "github.com/syndtr/goleveldb/leveldb"
)

// Batch implements batch for leveldb
type Batch struct {
        leveldb *leveldb.DB
        batch   *leveldb.Batch
}

// Put sets the value for the given key
func (b *Batch) Put(key []byte, value []byte) <span class="cov8" title="1">{
        b.batch.Put(key, value)
}</span>

// Delete deletes the value for the given key.
func (b *Batch) Delete(key []byte) <span class="cov8" title="1">{
        b.batch.Delete(key)
}</span>

// Commit commits batch operation.
func (b *Batch) Commit() error <span class="cov8" title="1">{
        return b.leveldb.Write(b.batch, nil)
}</span>

// Rollback rollbacks batch operation.
func (b *Batch) Rollback() <span class="cov8" title="1">{
        b.batch.Reset()
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package leveldb

import (
        "io/ioutil"
        "os"

        "github.com/seeleteam/go-seele/database"
        "github.com/syndtr/goleveldb/leveldb"
        "github.com/syndtr/goleveldb/leveldb/errors"
)

var (
        // ErrEmptyKey key is empty
        ErrEmptyKey = errors.New("key could not be empty")
)

// LevelDB wraps the leveldb
type LevelDB struct {
        db       *leveldb.DB
        quitChan chan struct{} // used by metrics
}

// NewLevelDB constructs and returns a LevelDB instance
func NewLevelDB(path string) (database.Database, error) <span class="cov8" title="1">{
        db, err := leveldb.OpenFile(path, nil)

        if _, corrupted := err.(*errors.ErrCorrupted); corrupted </span><span class="cov0" title="0">{
                db, err = leveldb.RecoverFile(path, nil)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;LevelDB{
                db:       db,
                quitChan: make(chan struct{}),
        }

        return result, nil</span>
}

// Close is used to close the db when not used
func (db *LevelDB) Close() <span class="cov8" title="1">{
        close(db.quitChan)
        db.db.Close()
}</span>

// GetString gets the value for the given key
func (db *LevelDB) GetString(key string) (string, error) <span class="cov8" title="1">{
        value, err := db.Get([]byte(key))

        return string(value), err
}</span>

// Get gets the value for the given key
func (db *LevelDB) Get(key []byte) ([]byte, error) <span class="cov8" title="1">{
        return db.db.Get(key, nil)
}</span>

// Put sets the value for the given key
func (db *LevelDB) Put(key []byte, value []byte) error <span class="cov8" title="1">{
        if len(key) &lt; 1 </span><span class="cov8" title="1">{
                return ErrEmptyKey
        }</span>

        <span class="cov8" title="1">return db.db.Put(key, value, nil)</span>
}

// PutString sets the value for the given key
func (db *LevelDB) PutString(key string, value string) error <span class="cov8" title="1">{
        return db.Put([]byte(key), []byte(value))
}</span>

// Has returns true if the DB does contain the given key.
func (db *LevelDB) Has(key []byte) (ret bool, err error) <span class="cov8" title="1">{
        return db.db.Has(key, nil)
}</span>

// HasString returns true if the DB does contain the given key.
func (db *LevelDB) HasString(key string) (ret bool, err error) <span class="cov8" title="1">{
        return db.Has([]byte(key))
}</span>

// Delete deletes the value for the given key.
func (db *LevelDB) Delete(key []byte) error <span class="cov8" title="1">{
        return db.db.Delete(key, nil)
}</span>

// DeleteSring deletes the value for the given key.
func (db *LevelDB) DeleteSring(key string) error <span class="cov8" title="1">{
        return db.Delete([]byte(key))
}</span>

// NewBatch constructs and returns a batch object
func (db *LevelDB) NewBatch() database.Batch <span class="cov8" title="1">{
        batch := &amp;Batch{
                leveldb: db.db,
                batch:   new(leveldb.Batch),
        }
        return batch
}</span>

// NewTestDatabase creates a database instance under temp folder.
func NewTestDatabase() (db database.Database, dispose func()) <span class="cov0" title="0">{
        dir, err := ioutil.TempDir("", "Seele-LevelDB-")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">db, err = NewLevelDB(dir)
        if err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(dir)
                panic(err)</span>
        }

        <span class="cov0" title="0">return db, func() </span><span class="cov0" title="0">{
                db.Close()
                os.RemoveAll(dir)
        }</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package leveldb

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        metrics "github.com/rcrowley/go-metrics"
        "github.com/seeleteam/go-seele/database"
        "github.com/seeleteam/go-seele/log"
)

const (
        writeDelayNThreshold       = 200
        writeDelayThreshold        = 350 * time.Millisecond
        writeDelayWarningThrottler = 1 * time.Minute
)

// DBMetrics defines the metrics used by leveldb
type DBMetrics struct {
        metricsCompTimeMeter    metrics.Meter // Meter for measuring the total time spent in database compaction
        metricsCompReadMeter    metrics.Meter // Meter for measuring the data read during compaction
        metricsCompWriteMeter   metrics.Meter // Meter for measuring the data written during compaction
        metricsWriteDelayNMeter metrics.Meter // Meter for measuring the write delay number due to database compaction
        metricsWriteDelayMeter  metrics.Meter // Meter for measuring the write delay duration due to database compaction
}

// StartMetrics create metrics and run a goroutine to collect
func StartMetrics(db database.Database, dbname string, log *log.SeeleLog) <span class="cov8" title="1">{
        m := DBMetrics{
                metricsCompTimeMeter:    metrics.GetOrRegisterMeter(dbname+".compact.time", nil),
                metricsCompReadMeter:    metrics.GetOrRegisterMeter(dbname+".compact.input", nil),
                metricsCompWriteMeter:   metrics.GetOrRegisterMeter(dbname+".compact.output", nil),
                metricsWriteDelayMeter:  metrics.GetOrRegisterMeter(dbname+".writedelay.duration", nil),
                metricsWriteDelayNMeter: metrics.GetOrRegisterMeter(dbname+".writedelay.counter", nil),
        }

        if lvdb, ok := db.(*LevelDB); ok </span><span class="cov8" title="1">{
                go collectDBMetrics(lvdb, &amp;m, log)
        }</span><span class="cov0" title="0"> else {
                log.Error(dbname, ": Error db type ! Expect type 'LevelDB'")
        }</span>
}

func collectDBMetrics(db *LevelDB, m *DBMetrics, log *log.SeeleLog) <span class="cov8" title="1">{
        if metrics.UseNilMetrics </span><span class="cov0" title="0">{
                return
        }</span>

        // Create the counters to store current and previous compaction values
        <span class="cov8" title="1">compactions := make([][]float64, 2)
        for i := 0; i &lt; 2; i++ </span><span class="cov8" title="1">{
                compactions[i] = make([]float64, 3)
        }</span>

        // Create storage and warning log tracer for write delay.
        <span class="cov8" title="1">var (
                delaystats      [2]int64
                lastWriteDelay  time.Time
                lastWriteDelayN time.Time
        )

        // Iterate ad infinitum and collect the stats
MetricsLoop:
        for i := 1; ; i++ </span><span class="cov8" title="1">{
                // Retrieve the database stats
                stats, err := db.db.GetProperty("leveldb.stats")
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to read database stats", "err", err)
                        break MetricsLoop</span>
                }
                // Find the compaction table, skip the header
                <span class="cov8" title="1">lines := strings.Split(stats, "\n")
                for len(lines) &gt; 0 &amp;&amp; strings.TrimSpace(lines[0]) != "Compactions" </span><span class="cov0" title="0">{
                        lines = lines[1:]
                }</span>
                <span class="cov8" title="1">if len(lines) &lt;= 3 </span><span class="cov0" title="0">{
                        log.Error("Compaction table not found")
                        break MetricsLoop</span>
                }
                <span class="cov8" title="1">lines = lines[3:]

                // Iterate over all the table rows, and accumulate the entries
                for j := 0; j &lt; len(compactions[i%2]); j++ </span><span class="cov8" title="1">{
                        compactions[i%2][j] = 0
                }</span>
                <span class="cov8" title="1">for _, line := range lines </span><span class="cov8" title="1">{
                        parts := strings.Split(line, "|")
                        if len(parts) != 6 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">for idx, counter := range parts[3:] </span><span class="cov0" title="0">{
                                value, err := strconv.ParseFloat(strings.TrimSpace(counter), 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error("Compaction entry parsing failed", "err", err)
                                        break MetricsLoop</span>
                                }
                                <span class="cov0" title="0">compactions[i%2][idx] += value</span>
                        }
                }
                // Update all the requested meters
                <span class="cov8" title="1">m.metricsCompTimeMeter.Mark(int64((compactions[i%2][0] - compactions[(i-1)%2][0]) * 1000 * 1000 * 1000))
                m.metricsCompReadMeter.Mark(int64((compactions[i%2][1] - compactions[(i-1)%2][1]) * 1024 * 1024))
                m.metricsCompWriteMeter.Mark(int64((compactions[i%2][2] - compactions[(i-1)%2][2]) * 1024 * 1024))

                // Retrieve the write delay statistic
                writedelay, err := db.db.GetProperty("leveldb.writedelay")
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to read database write delay statistic", "err", err)
                        break MetricsLoop</span>
                }
                <span class="cov8" title="1">var (
                        delayN        int64
                        delayDuration string
                        duration      time.Duration
                )
                if n, err := fmt.Sscanf(writedelay, "DelayN:%d Delay:%s", &amp;delayN, &amp;delayDuration); n != 2 || err != nil </span><span class="cov0" title="0">{
                        log.Error("Write delay statistic not found")
                        break MetricsLoop</span>
                }
                <span class="cov8" title="1">duration, err = time.ParseDuration(delayDuration)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse delay duration", "err", err)
                        break MetricsLoop</span>
                }

                <span class="cov8" title="1">m.metricsWriteDelayNMeter.Mark(delayN - delaystats[0])
                // If the write delay number been collected in the last minute exceeds the predefined threshold,
                // print a warning log here.
                // If a warning that db performance is laggy has been displayed,
                // any subsequent warnings will be withhold for 1 minute to don't overwhelm the user.
                if int(m.metricsWriteDelayNMeter.Rate1()) &gt; writeDelayNThreshold &amp;&amp;
                        time.Now().After(lastWriteDelayN.Add(writeDelayWarningThrottler)) </span><span class="cov0" title="0">{
                        log.Warn("Write delay number exceeds the threshold (200 per second) in the last minute")
                        lastWriteDelayN = time.Now()
                }</span>

                <span class="cov8" title="1">m.metricsWriteDelayMeter.Mark(duration.Nanoseconds() - delaystats[1])
                // If the write delay duration been collected in the last minute exceeds the predefined threshold,
                // print a warning log here.
                // If a warning that db performance is laggy has been displayed,
                // any subsequent warnings will be withhold for 1 minute to don't overwhelm the user.
                if int64(m.metricsWriteDelayMeter.Rate1()) &gt; writeDelayThreshold.Nanoseconds() &amp;&amp;
                        time.Now().After(lastWriteDelay.Add(writeDelayWarningThrottler)) </span><span class="cov0" title="0">{
                        log.Warn("Write delay duration exceeds the threshold (35% of the time) in the last minute")
                        lastWriteDelay = time.Now()
                }</span>

                <span class="cov8" title="1">delaystats[0], delaystats[1] = delayN, duration.Nanoseconds()

                // Sleep a bit, then repeat the stats collection
                select </span>{
                case &lt;-db.quitChan:<span class="cov8" title="1">
                        return</span>
                case &lt;-time.After(time.Second * 3):</span><span class="cov0" title="0"> // wait 3 seconds
                }
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package event

import (
        "reflect"
        "sync"
)

// EventManager is an interface which defines the event manager behaviors
// Note that it is thread safe
type EventManager struct {
        lock      sync.RWMutex
        listeners []eventListener
}

// Fire triggers all listeners with the specified event and removes listeners which run only once.
func (h *EventManager) Fire(e Event) <span class="cov8" title="1">{
        h.lock.Lock()
        defer h.lock.Unlock()
        
        for _, l := range h.listeners </span><span class="cov8" title="1">{
                if l.IsAsyncListener </span><span class="cov8" title="1">{
                        go l.Callable(e)
                }</span><span class="cov8" title="1"> else {
                        l.Callable(e)
                }</span>
        }

        <span class="cov8" title="1">h.removeOnceListener()</span>
}

// AddListener registers a listener.
// If there is already a same listener (same method pointer), we will not add it
func (h *EventManager) AddListener(callback EventHandleMethod) <span class="cov8" title="1">{
        listener := eventListener{
                Callable: callback,
        }

        h.addEventListener(listener)
}</span>

// AddOnceListener registers a listener which only runs once
func (h *EventManager) AddOnceListener(callback EventHandleMethod) <span class="cov8" title="1">{
        listener := eventListener{
                Callable:       callback,
                IsOnceListener: true,
        }

        h.addEventListener(listener)
}</span>

// AddOnceListener registers a listener which only runs once and async
func (h *EventManager) AddAsyncOnceListener(callback EventHandleMethod) <span class="cov8" title="1">{
        listener := eventListener{
                Callable:        callback,
                IsOnceListener:  true,
                IsAsyncListener: true,
        }

        h.addEventListener(listener)
}</span>

// AddOnceListener registers a listener which runs async
func (h *EventManager) AddAsyncListener(callback EventHandleMethod) <span class="cov8" title="1">{
        listener := eventListener{
                Callable:        callback,
                IsAsyncListener: true,
        }

        h.addEventListener(listener)
}</span>

// addEventListener registers a event listener.
// If there is already a same listener (same method pointer), we will not add it
func (h *EventManager) addEventListener(listener eventListener) <span class="cov8" title="1">{
        h.lock.Lock()
        defer h.lock.Unlock()
        if index := h.find(listener.Callable); index != -1 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">h.listeners = append(h.listeners, listener)</span>
}

// RemoveListener removes the registered event listener for given event name.
func (h *EventManager) RemoveListener(callback EventHandleMethod) <span class="cov8" title="1">{
        h.lock.Lock()
        defer h.lock.Unlock()
        index := h.find(callback)
        if index == -1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">h.listeners = append(h.listeners[:index], h.listeners[index+1:]...)</span>
}

// removeOnceListener removes all listeners which run only once
func (h *EventManager) removeOnceListener() <span class="cov8" title="1">{        
        listeners := make([]eventListener, 0, len(h.listeners))
        for _, l := range h.listeners </span><span class="cov8" title="1">{
                if !l.IsOnceListener </span><span class="cov8" title="1">{
                        listeners = append(listeners, l)
                }</span>
        }

        <span class="cov8" title="1">h.listeners = listeners</span>
}

// find finds listener existing in the manager
// returns -1 if not found, otherwise the index of the listener
func (h *EventManager) find(callback EventHandleMethod) int <span class="cov8" title="1">{
        p := reflect.ValueOf(callback).Pointer()

        for i, l := range h.listeners </span><span class="cov8" title="1">{
                lp := reflect.ValueOf(l.Callable).Pointer()
                if lp == p </span><span class="cov8" title="1">{
                        return i
                }</span>
        }

        <span class="cov8" title="1">return -1</span>
}

// NewEventManager creates a new instance of event manager
func NewEventManager() *EventManager <span class="cov8" title="1">{
        return &amp;EventManager{
                listeners: make([]eventListener, 0),
        }
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package log

import (
        "path/filepath"
        "runtime"
        "strconv"
        "strings"

        "github.com/sirupsen/logrus"
)

const (
        depth = 9 // Once log invocation stack has changed, depth needs to change as well.
)

// CallerHook a caller hook of logrus
type CallerHook struct {
        module string
}

// Fire adds a caller field in logger instance
func (hook *CallerHook) Fire(entry *logrus.Entry) error <span class="cov8" title="1">{
        entry.Data["caller"] = hook.caller()
        entry.Data["module"] = hook.module
        return nil
}</span>

// Levels returns supported levels
func (hook *CallerHook) Levels() []logrus.Level <span class="cov8" title="1">{
        return logrus.AllLevels
}</span>

// caller returns the invoker which is being executed
func (hook *CallerHook) caller() string <span class="cov8" title="1">{
        if _, file, line, ok := runtime.Caller(depth); ok </span><span class="cov8" title="1">{
                return strings.Join([]string{filepath.Base(file), strconv.Itoa(line)}, ":")
        }</span>

        // not sure what the convention should be here
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package log

import (
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/lestrrat-go/file-rotatelogs"
        "github.com/seeleteam/go-seele/common"
        "github.com/sirupsen/logrus"
)

var (
        // LogFolder the default folder to write logs
        LogFolder = filepath.Join(common.GetTempFolder(), "log")
)

// SeeleLog wraps log class
type SeeleLog struct {
        log *logrus.Logger
}

var logMap map[string]*SeeleLog
var getLogMutex sync.Mutex

// Panic Level, highest level of severity. Panic logs and then calls panic with the
// message passed to Debug, Info, ...
func (p *SeeleLog) Panic(format string, args ...interface{}) <span class="cov0" title="0">{
        p.log.Panicf(format, args...)
}</span>

// Fatal Level. Fatal logs and then calls `os.Exit(1)`. It will exit even if the
// logging level is set to Panic.
func (p *SeeleLog) Fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        p.log.Fatalf(format, args...)
}</span>

// Error Level. Error logs and is used for errors that should be definitely noted.
// Commonly used for hooks to send errors to an error tracking service.
func (p *SeeleLog) Error(format string, args ...interface{}) <span class="cov8" title="1">{
        p.log.Errorf(format, args...)
}</span>

// Warn Level. Non-critical entries that deserve eyes.
func (p *SeeleLog) Warn(format string, args ...interface{}) <span class="cov8" title="1">{
        p.log.Warnf(format, args...)
}</span>

// Info Level. General operational entries about what's going on inside the
// application.
func (p *SeeleLog) Info(format string, args ...interface{}) <span class="cov8" title="1">{
        p.log.Infof(format, args...)
}</span>

// Debug Level. Usually only enabled when debugging. Very verbose logging.
func (p *SeeleLog) Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        p.log.Debugf(format, args...)
}</span>

// SetLevel set the log level
func (p *SeeleLog) SetLevel(level logrus.Level) <span class="cov8" title="1">{
        p.log.SetLevel(level)
}</span>

// GetLevel get the log level
func (p *SeeleLog) GetLevel() logrus.Level <span class="cov8" title="1">{
        return p.log.Level
}</span>

// GetLogger gets logrus.Logger object according to logName
// each module can have its own logger
func GetLogger(logName string, bConsole bool) *SeeleLog <span class="cov8" title="1">{
        getLogMutex.Lock()
        defer getLogMutex.Unlock()
        if logMap == nil </span><span class="cov8" title="1">{
                logMap = make(map[string]*SeeleLog)
        }</span>
        <span class="cov8" title="1">curLog, ok := logMap[logName]
        if ok </span><span class="cov0" title="0">{
                return curLog
        }</span>

        <span class="cov8" title="1">logrus.SetFormatter(&amp;logrus.TextFormatter{})
        log := logrus.New()

        if bConsole </span><span class="cov8" title="1">{
                log.Out = os.Stdout
        }</span><span class="cov8" title="1"> else {
                err := os.MkdirAll(LogFolder, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("creating log dir failed: %s", err.Error()))</span>
                }
                <span class="cov8" title="1">logFullPath := filepath.Join(LogFolder, common.LogFileName)

                writer, err := rotatelogs.New(
                        logFullPath+".%Y%m%d",
                        rotatelogs.WithClock(rotatelogs.Local),
                        rotatelogs.WithMaxAge(24*7*time.Hour),
                        rotatelogs.WithRotationTime(24*time.Hour),
                )

                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("creating log file failed: %s", err))</span>
                }

                <span class="cov8" title="1">log.Out = writer</span>
        }

        <span class="cov8" title="1">if common.LogConfig.IsDebug </span><span class="cov8" title="1">{
                log.SetLevel(logrus.DebugLevel)
        }</span><span class="cov0" title="0"> else {
                log.SetLevel(logrus.InfoLevel)
        }</span>

        <span class="cov8" title="1">log.AddHook(&amp;CallerHook{module: logName}) // add caller hook to print caller's file and line number
        curLog = &amp;SeeleLog{
                log: log,
        }
        logMap[logName] = curLog
        return curLog</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package merkle

import (
        "bytes"
        "errors"
        "fmt"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
)

var (
        errNoContent = errors.New("can not construct the tree with no content.")
)

// Content represents the data that is stored and verified by the tree. A type that
// implements this interface can be used as an item in the tree.
type Content interface {
        CalculateHash() common.Hash
        Equals(other Content) bool
}

// MerkleTree is the container for the tree. It holds a pointer to the root of the tree,
// a list of pointers to the leaf nodes and the merkle root.
// Note, it is not thread safe
type MerkleTree struct {
        Root       *node
        merkleRoot common.Hash
        Leaves     []*node
}

// node represents a node, root or leaf in the tree. It stores pointers to its immediate
// relatives, a hash, the content stored if it is a leaf, and other metadata.
type node struct {
        Parent  *node
        Left    *node
        Right   *node
        dup     bool // dup indicates whether this is a duplicate of the rightmost leaf of the tree.
        Hash    common.Hash
        Content Content
}

func (n *node) isLeaf() bool <span class="cov8" title="1">{
        return n.Content != nil
}</span>

// calculateHashRecursively walks down the tree until hitting a leaf, calculating the hash at each level
// and returning the resulting hash of the node.
func (n *node) calculateHashRecursively() common.Hash <span class="cov8" title="1">{
        if n.isLeaf() </span><span class="cov8" title="1">{
                return n.Content.CalculateHash()
        }</span>
        <span class="cov8" title="1">return crypto.HashBytes(append(n.Left.calculateHashRecursively().Bytes(), n.Right.calculateHashRecursively().Bytes()...))</span>
}

// calculateHash is a helper function that calculates the hash of the node.
func (n *node) calculateHash() common.Hash <span class="cov8" title="1">{
        if n.isLeaf() </span><span class="cov8" title="1">{
                return n.Content.CalculateHash()
        }</span>
        <span class="cov8" title="1">return crypto.HashBytes(append(n.Left.Hash.Bytes(), n.Right.Hash.Bytes()...))</span>
}

// NewTree creates a new Merkle Tree using the specified contents.
func NewTree(contents []Content) (*MerkleTree, error) <span class="cov8" title="1">{
        root, leaves, err := buildWithContent(contents)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">t := &amp;MerkleTree{
                Root:       root,
                merkleRoot: root.Hash,
                Leaves:     leaves,
        }
        return t, nil</span>
}

// buildWithContent is a helper function that generates a corresponding tree for a given set of contents,
// and returns the root node, a list of leaf nodes and a possible error if no contents.
func buildWithContent(contents []Content) (*node, []*node, error) <span class="cov8" title="1">{
        if len(contents) == 0 </span><span class="cov0" title="0">{
                return nil, nil, errNoContent
        }</span>
        <span class="cov8" title="1">var leaves []*node
        for _, c := range contents </span><span class="cov8" title="1">{
                leaves = append(leaves, &amp;node{
                        Hash:    c.CalculateHash(),
                        Content: c,
                })
        }</span>
        <span class="cov8" title="1">if len(leaves)%2 == 1 </span><span class="cov8" title="1">{
                duplicate := &amp;node{
                        Hash:    leaves[len(leaves)-1].Hash,
                        Content: leaves[len(leaves)-1].Content,
                        dup:     true,
                }
                leaves = append(leaves, duplicate)
        }</span>
        <span class="cov8" title="1">root := buildIntermediate(leaves)
        return root, leaves, nil</span>
}

// buildIntermediate is a helper function that constructs the intermediate and
// root levels of the tree for a given list of leaf nodes.
// Return the resulting root node of the tree.
func buildIntermediate(nodeList []*node) *node <span class="cov8" title="1">{
        var nodes []*node
        for i := 0; i &lt; len(nodeList); i += 2 </span><span class="cov8" title="1">{
                var left, right int = i, i + 1
                if i+1 == len(nodeList) </span><span class="cov8" title="1">{
                        right = i
                }</span>
                <span class="cov8" title="1">chash := append(nodeList[left].Hash.Bytes(), nodeList[right].Hash.Bytes()...)
                n := &amp;node{
                        Left:  nodeList[left],
                        Right: nodeList[right],
                        Hash:  crypto.HashBytes(chash),
                }
                nodes = append(nodes, n)
                nodeList[left].Parent = n
                nodeList[right].Parent = n
                if len(nodeList) == 2 </span><span class="cov8" title="1">{
                        return n
                }</span>
        }
        <span class="cov8" title="1">return buildIntermediate(nodes)</span>
}

// MerkleRoot returns the unverified Merkle root (hash of the root node) of the tree.
func (m *MerkleTree) MerkleRoot() common.Hash <span class="cov8" title="1">{
        return m.merkleRoot
}</span>

// RebuildTree is a helper function that will rebuild the tree by only reusing the contents held
// in the leaves.
func (m *MerkleTree) RebuildTree() error <span class="cov8" title="1">{
        var cs []Content
        for _, c := range m.Leaves </span><span class="cov8" title="1">{
                cs = append(cs, c.Content)
        }</span>
        <span class="cov8" title="1">root, leaves, err := buildWithContent(cs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">m.Root = root
        m.Leaves = leaves
        m.merkleRoot = root.Hash
        return nil</span>
}

// RebuildTreeWith replaces the contents of the tree and does a complete rebuilding.
// while the root of the tree will be replaced, the Merkle tree completely survives.
// Return an error if the list of contents contains no entries.
func (m *MerkleTree) RebuildTreeWith(cs []Content) error <span class="cov8" title="1">{
        root, leaves, err := buildWithContent(cs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">m.Root = root
        m.Leaves = leaves
        m.merkleRoot = root.Hash
        return nil</span>
}

// VerifyTree validates the hashes at each level of the tree and returns true if the
// resulting hash at the root of the tree matches the Merkle root hash; otherwise, return false.
func (m *MerkleTree) VerifyTree() bool <span class="cov8" title="1">{
        calculatedMerkleRoot := m.Root.calculateHashRecursively()

        return bytes.Compare(m.merkleRoot.Bytes(), calculatedMerkleRoot.Bytes()) == 0
}</span>

// VerifyContent indicates whether the given content is in the tree and whether the hashes are valid for that content.
// Return false if the specified Merkle root is not equivalent to the Merkle root calculated on the critical path
// for the given content. Return true if valid and false otherwise.
func (m *MerkleTree) VerifyContent(expectedMerkleRoot []byte, content Content) bool <span class="cov8" title="1">{
        if bytes.Compare(m.merkleRoot.Bytes(), expectedMerkleRoot) != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, l := range m.Leaves </span><span class="cov8" title="1">{
                if l.Content.Equals(content) </span><span class="cov8" title="1">{
                        currentParent := l.Parent
                        for currentParent != nil </span><span class="cov8" title="1">{
                                buff := append(currentParent.Left.calculateHash().Bytes(), currentParent.Right.calculateHash().Bytes()...)
                                if bytes.Compare(crypto.HashBytes(buff).Bytes(), currentParent.Hash.Bytes()) != 0 </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">currentParent = currentParent.Parent</span>
                        }
                        <span class="cov8" title="1">return true</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// String returns a string representation of the tree. Only leaf nodes are included
// in the output.
func (m *MerkleTree) String() string <span class="cov8" title="1">{
        s := ""
        for _, l := range m.Leaves </span><span class="cov8" title="1">{
                s += fmt.Sprintln(l)
        }</span>
        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package metrics

import (
        "fmt"
        "time"

        metrics "github.com/rcrowley/go-metrics"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/log"
        influxdb "github.com/seeleteam/go-seele/metrics/go-metrics-influxdb"
)

var MetricsWriteBlockMeter = metrics.GetOrRegisterMeter("core.blockchain.writeBlock.time", nil)

// Config infos for influxdb
type Config struct {
        Addr     string        `json:"address"`
        Database string        `json:"database"`
        Username string        `json:"username"`
        Password string        `json:"password"`
        Duration time.Duration `json:"duration"`
}

// StartMetricsWithConfig start recording metrics with configure
func StartMetricsWithConfig(conf *Config, log *log.SeeleLog, name, version string, networkID uint64, coinBase common.Address) <span class="cov8" title="1">{
        if conf == nil </span><span class="cov0" title="0">{
                log.Error("Starting the metrics failed: the config of metrics is null")
                return
        }</span>

        <span class="cov8" title="1">StartMetrics(
                time.Second*conf.Duration,
                conf.Addr,
                conf.Database,
                conf.Username,
                conf.Password,
                name,
                networkID,
                version,
                coinBase,
                log,
        )</span>
}

// StartMetrics start recording metrics
func StartMetrics(
        d time.Duration, // duration to send metrics datas
        address string, // remote influxdb address
        database string, // database 'influxdb'
        username string, // database username
        password string, // database password
        nodeName string, // name of the node
        networkID uint64,
        version string,
        coinBase common.Address,
        log *log.SeeleLog) <span class="cov8" title="1">{
        log.Info("Start metrics!")

        go influxdb.InfluxDBWithTags(
                metrics.DefaultRegistry,
                d,
                address,
                database,
                username,
                password,
                map[string]string{
                        "nodename":  nodeName,
                        "networkid": fmt.Sprint(networkID),
                        "version":   version,
                        "coinbase":  coinBase.ToHex(),
                        "shardid":   fmt.Sprint(common.LocalShardNumber),
                },
                log,
        )

        go collectRuntimeMetrics()
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package metrics

import (
        "os"
        "time"

        metrics "github.com/rcrowley/go-metrics"
        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/process"
)

var (
        // metricsCpuGauge is the usage rate of the metrics current system
        metricsCpuGauge = metrics.GetOrRegisterGauge("cpu.os", nil)
        // metricsSeeleCpuGauge is the usage rate of the metrics current process
        metricsSeeleCpuGauge = metrics.GetOrRegisterGauge("cpu.seele", nil)
)

func getCPURate(interval time.Duration, percpu bool) (int64, error) <span class="cov8" title="1">{
        out, err := cpu.Percent(interval, percpu)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">var result float64
        for i := 0; i &lt; len(out); i++ </span><span class="cov8" title="1">{
                result = result + out[i]
        }</span>
        <span class="cov8" title="1">return int64(result), nil</span>
}

func getProcessCPURate(interval time.Duration) (int64, error) <span class="cov8" title="1">{
        checkPid := os.Getpid()
        ret, err := process.NewProcess(int32(checkPid))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">result, err := ret.Percent(interval)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return int64(result), nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package metrics

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "runtime"
        "strconv"
        "strings"

        metrics "github.com/rcrowley/go-metrics"
)

var (
        metricsDiskFreeCountGauge  = metrics.GetOrRegisterGauge("disk.free.count", nil)
        metricsDiskReadCountGauge  = metrics.GetOrRegisterGauge("disk.read.count", nil)
        metricsDiskWriteCountGauge = metrics.GetOrRegisterGauge("disk.write.count", nil)
        metricsDiskReadBytesGauge  = metrics.GetOrRegisterGauge("disk.read.bytes", nil)
        metricsDiskWriteBytesGauge = metrics.GetOrRegisterGauge("disk.write.bytes", nil)
)

type DiskStats struct {
        ReadCount  int64
        ReadBytes  int64
        WriteCount int64
        WriteBytes int64
}

func GetDiskInfo() *DiskStats <span class="cov8" title="1">{
        diskStats := DiskStats{}
        if runtime.GOOS == "linux" </span><span class="cov0" title="0">{
                if err := getDiskInfoLinux(&amp;diskStats); err == nil </span><span class="cov0" title="0">{
                        return &amp;diskStats
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// getDiskInfoLinux retrieves the disk IO info belonging to the current process.
func getDiskInfoLinux(stats *DiskStats) error <span class="cov0" title="0">{
        inf, err := os.Open(fmt.Sprintf("/proc/%d/io", os.Getpid()))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer inf.Close()
        in := bufio.NewReader(inf)

        for </span><span class="cov0" title="0">{
                line, err := in.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">parts := strings.Split(line, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value, err := strconv.ParseInt(strings.TrimSpace(parts[1]), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">switch key </span>{
                case "syscr":<span class="cov0" title="0">
                        stats.ReadCount = value</span>
                case "syscw":<span class="cov0" title="0">
                        stats.WriteCount = value</span>
                case "rchar":<span class="cov0" title="0">
                        stats.ReadBytes = value</span>
                case "wchar":<span class="cov0" title="0">
                        stats.WriteBytes = value</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package metrics

import (
        "runtime"
        "time"

        metrics "github.com/rcrowley/go-metrics"
        "github.com/seeleteam/go-seele/common"
        "github.com/shirou/gopsutil/disk"
)

var (
        memAlloc  = metrics.GetOrRegisterGauge("runtime.memory.alloc", metrics.DefaultRegistry)
        memPauses = metrics.GetOrRegisterMeter("runtime.memory.pauses", metrics.DefaultRegistry)
)

// CollectRuntimeMetrics collected runtime datas
func collectRuntimeMetrics() <span class="cov8" title="1">{
        if metrics.UseNilMetrics </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">memStats := new(runtime.MemStats)
        var lastPauseNs uint64
        // collect metrics
        for </span><span class="cov8" title="1">{
                doMark(memStats, lastPauseNs)
                time.Sleep(common.MetricsRefreshTime)
        }</span>
}

func doMark(memStats *runtime.MemStats, lastPauseNs uint64) <span class="cov8" title="1">{
        runtime.ReadMemStats(memStats)
        memAlloc.Update(int64(memStats.Alloc))
        memPauses.Mark(int64(memStats.PauseTotalNs - lastPauseNs))
        lastPauseNs = memStats.PauseTotalNs

        // cpuResult is the cpu info of the current system
        if cpuResult, err := getCPURate(common.CPUMetricsRefreshTime, false); err == nil </span><span class="cov8" title="1">{
                metricsCpuGauge.Update(cpuResult)
        }</span>

        // cpuSeeleResult is the cpu info of the current process
        <span class="cov8" title="1">if cpuSeeleResult, err := getProcessCPURate(common.CPUMetricsRefreshTime); err == nil </span><span class="cov8" title="1">{
                metricsSeeleCpuGauge.Update(cpuSeeleResult)
        }</span>

        // diskResult is the disk info of the current system
        <span class="cov8" title="1">if diskResult, err := disk.Usage(common.GetDefaultDataFolder()); err == nil </span><span class="cov8" title="1">{
                metricsDiskFreeCountGauge.Update(int64(diskResult.Free))
        }</span>

        // diskInfo is the disk info of the current process
        <span class="cov8" title="1">if diskInfo := GetDiskInfo(); diskInfo != nil </span><span class="cov0" title="0">{
                metricsDiskReadCountGauge.Update(int64(diskInfo.ReadCount))
                metricsDiskWriteCountGauge.Update(int64(diskInfo.WriteCount))
                metricsDiskReadBytesGauge.Update(int64(diskInfo.ReadBytes))
                metricsDiskWriteBytesGauge.Update(int64(diskInfo.WriteBytes))
        }</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package miner

import (
        "math/big"
        "sync/atomic"

        metrics "github.com/rcrowley/go-metrics"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/miner/pow"
)

// StartMining starts calculating the nonce for the block.
// seed is the random start value for the nonce
// min is the min number for the nonce per thread
// max is the max number for the nonce per thread
// result represents the founded nonce will be set in the result block
// abort is a channel by closing which you can stop mining
// isNonceFound is a flag to mark nonce is found by other threads
// hashrate is the average hashrate of miner
func StartMining(task *Task, seed uint64, min uint64, max uint64, result chan&lt;- *Result, abort &lt;-chan struct{}, isNonceFound *int32, hashrate metrics.Meter, log *log.SeeleLog) <span class="cov8" title="1">{
        block := task.generateBlock()

        var nonce = seed
        var hashInt big.Int
        var caltimes = int64(0)
        target := pow.GetMiningTarget(block.Header.Difficulty)

miner:
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-abort:<span class="cov8" title="1">
                        logAbort(log)
                        hashrate.Mark(caltimes)
                        break miner</span>

                default:<span class="cov8" title="1">
                        if atomic.LoadInt32(isNonceFound) != 0 </span><span class="cov0" title="0">{
                                log.Info("exist mining as nonce is found in other process")
                                break miner</span>
                        }

                        <span class="cov8" title="1">caltimes++
                        if caltimes == 0x7FFF </span><span class="cov0" title="0">{
                                hashrate.Mark(caltimes)
                                caltimes = 0
                        }</span>

                        <span class="cov8" title="1">block.Header.Nonce = nonce
                        hash := block.Header.Hash()
                        hashInt.SetBytes(hash.Bytes())

                        // found
                        if hashInt.Cmp(target) &lt;= 0 </span><span class="cov8" title="1">{
                                block.HeaderHash = hash
                                found := &amp;Result{
                                        task:  task,
                                        block: block,
                                }

                                select </span>{
                                case &lt;-abort:<span class="cov0" title="0">
                                        logAbort(log)</span>
                                case result &lt;- found:<span class="cov8" title="1">
                                        atomic.StoreInt32(isNonceFound, 1)
                                        log.Debug("nonce finding succeeded")</span>
                                }

                                <span class="cov8" title="1">break miner</span>
                        }

                        // when nonce reached max, nonce traverses in [min, seed-1]
                        <span class="cov8" title="1">if nonce == max </span><span class="cov0" title="0">{
                                nonce = min
                        }</span>
                        // outage
                        <span class="cov8" title="1">if nonce == seed-1 </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-abort:<span class="cov0" title="0">
                                        logAbort(log)</span>
                                case result &lt;- nil:<span class="cov0" title="0">
                                        log.Warn("nonce finding outage")</span>
                                }

                                <span class="cov0" title="0">break miner</span>
                        }

                        <span class="cov8" title="1">nonce++</span>
                }
        }
}

// logAbort logs the info that nonce finding is aborted
func logAbort(log *log.SeeleLog) <span class="cov8" title="1">{
        log.Info("nonce finding aborted")
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package miner

import (
        "errors"
        "fmt"
        "math"
        "math/big"
        "math/rand"
        "runtime"
        "sync"
        "sync/atomic"
        "time"

        metrics "github.com/rcrowley/go-metrics"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/event"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/miner/pow"
)

var (
        // ErrMinerIsRunning is returned when miner is running
        ErrMinerIsRunning = errors.New("miner is running")

        // ErrMinerIsStopped is returned when miner is stopped
        ErrMinerIsStopped = errors.New("miner is stopped")

        // ErrNodeIsSyncing is returned when the node is syncing
        ErrNodeIsSyncing = errors.New("can not start miner when syncing")
)

// SeeleBackend wraps all methods required for minier.
type SeeleBackend interface {
        TxPool() *core.TransactionPool
        BlockChain() *core.Blockchain
}

// Miner defines base elements of miner
type Miner struct {
        coinbase common.Address
        mining   int32
        canStart int32
        stopped  int32

        wg       sync.WaitGroup
        stopChan chan struct{}
        current  *Task
        recv     chan *Result

        seele SeeleBackend
        log   *log.SeeleLog

        isFirstDownloader int32

        threads              int
        isFirstBlockPrepared int32
        hashrate             metrics.Meter // Meter tracking the average hashrate
}

// NewMiner constructs and returns a miner instance
func NewMiner(addr common.Address, seele SeeleBackend) *Miner <span class="cov0" title="0">{
        miner := &amp;Miner{
                coinbase:             addr,
                canStart:             1,
                stopped:              0,
                seele:                seele,
                wg:                   sync.WaitGroup{},
                recv:                 make(chan *Result, 1),
                log:                  log.GetLogger("miner", common.LogConfig.PrintLog),
                isFirstDownloader:    1,
                isFirstBlockPrepared: 0,
                threads:              1,
                hashrate:             metrics.NewMeter(),
        }

        event.BlockDownloaderEventManager.AddAsyncListener(miner.downloaderEventCallback)
        event.TransactionInsertedEventManager.AddAsyncListener(miner.newTxCallback)

        return miner
}</span>

// GetCoinbase returns the coinbase.
func (miner *Miner) GetCoinbase() common.Address <span class="cov0" title="0">{
        return miner.coinbase
}</span>

// SetThreads sets the number of mining threads.
func (miner *Miner) SetThreads(threads int) <span class="cov0" title="0">{
        if threads &lt;= 0 </span><span class="cov0" title="0">{
                threads = runtime.NumCPU()
        }</span>

        <span class="cov0" title="0">miner.threads = threads</span>
}

// GetThreads gets the number of mining threads.
func (miner *Miner) GetThreads() int <span class="cov0" title="0">{
        return miner.threads
}</span>

// SetCoinbase set the coinbase.
func (miner *Miner) SetCoinbase(coinbase common.Address) <span class="cov0" title="0">{
        miner.coinbase = coinbase
}</span>

// Start is used to start the miner
func (miner *Miner) Start() error <span class="cov0" title="0">{
        if atomic.LoadInt32(&amp;miner.mining) == 1 </span><span class="cov0" title="0">{
                miner.log.Info("Miner is running")
                return ErrMinerIsRunning
        }</span>

        <span class="cov0" title="0">if atomic.LoadInt32(&amp;miner.canStart) == 0 </span><span class="cov0" title="0">{
                miner.log.Info("Can not start miner when syncing")
                return ErrNodeIsSyncing
        }</span>

        // CAS to ensure only 1 mining goroutine.
        <span class="cov0" title="0">if !atomic.CompareAndSwapInt32(&amp;miner.mining, 0, 1) </span><span class="cov0" title="0">{
                miner.log.Info("Another goroutine has already started to mine")
                return nil
        }</span>

        <span class="cov0" title="0">miner.log.Info("miner start with %d threads", miner.threads)
        miner.stopChan = make(chan struct{})

        if err := miner.prepareNewBlock(); err != nil </span><span class="cov0" title="0">{ // try to prepare the first block
                miner.log.Warn(err.Error())
                atomic.StoreInt32(&amp;miner.mining, 0)

                return err
        }</span>

        <span class="cov0" title="0">atomic.StoreInt32(&amp;miner.stopped, 0)
        go miner.waitBlock()

        miner.log.Info("Miner is started.")

        return nil</span>
}

// Stop is used to stop the miner
func (miner *Miner) Stop() <span class="cov0" title="0">{
        // set stopped to 1 to prevent restart
        atomic.StoreInt32(&amp;miner.stopped, 1)
        miner.stopMining()
}</span>

func (miner *Miner) stopMining() <span class="cov0" title="0">{
        if !atomic.CompareAndSwapInt32(&amp;miner.mining, 1, 0) </span><span class="cov0" title="0">{
                return
        }</span>

        // notify all threads to terminate
        <span class="cov0" title="0">if miner.stopChan != nil </span><span class="cov0" title="0">{
                close(miner.stopChan)
                miner.stopChan = nil
        }</span>

        // wait for all threads to terminate
        <span class="cov0" title="0">miner.wg.Wait()

        miner.log.Info("Miner is stopped.")</span>
}

// Close closes the miner.
func (miner *Miner) Close() <span class="cov0" title="0">{
        if miner.stopChan != nil </span><span class="cov0" title="0">{
                close(miner.stopChan)
                miner.stopChan = nil
        }</span>

        <span class="cov0" title="0">if miner.recv != nil </span><span class="cov0" title="0">{
                close(miner.recv)
                miner.recv = nil
        }</span>
}

// IsMining returns true if the miner is started, otherwise false
func (miner *Miner) IsMining() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;miner.mining) == 1
}</span>

// downloaderEventCallback handles events which indicate the downloader state
func (miner *Miner) downloaderEventCallback(e event.Event) <span class="cov0" title="0">{
        if atomic.LoadInt32(&amp;miner.isFirstDownloader) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch e.(int) </span>{
        case event.DownloaderStartEvent:<span class="cov0" title="0">
                miner.log.Info("got download start event, stop miner")
                atomic.StoreInt32(&amp;miner.canStart, 0)
                if miner.IsMining() </span><span class="cov0" title="0">{
                        miner.stopMining()
                }</span>
        case event.DownloaderDoneEvent, event.DownloaderFailedEvent:<span class="cov0" title="0">
                atomic.StoreInt32(&amp;miner.canStart, 1)
                atomic.StoreInt32(&amp;miner.isFirstDownloader, 0)

                if atomic.LoadInt32(&amp;miner.stopped) == 0 </span><span class="cov0" title="0">{
                        miner.log.Info("got download end event, start miner")
                        miner.Start()
                }</span>
        }
}

// newTxCallback handles the new tx event
func (miner *Miner) newTxCallback(e event.Event) <span class="cov0" title="0">{
        if common.PrintExplosionLog </span><span class="cov0" title="0">{
                miner.log.Debug("got the new tx event")
        }</span>

        // if not mining, start mining
        <span class="cov0" title="0">if atomic.LoadInt32(&amp;miner.stopped) == 0 &amp;&amp; atomic.LoadInt32(&amp;miner.canStart) == 1 &amp;&amp; atomic.CompareAndSwapInt32(&amp;miner.mining, 0, 1) </span><span class="cov0" title="0">{
                if err := miner.prepareNewBlock(); err != nil </span><span class="cov0" title="0">{
                        miner.log.Warn(err.Error())
                        atomic.StoreInt32(&amp;miner.mining, 0)
                }</span>
        }
}

// waitBlock waits for blocks to be mined continuously
func (miner *Miner) waitBlock() <span class="cov0" title="0">{
out:
        for </span><span class="cov0" title="0">{
                select </span>{
                case result := &lt;-miner.recv:<span class="cov0" title="0">
                        for </span><span class="cov0" title="0">{
                                if result == nil || result.task != miner.current </span><span class="cov0" title="0">{
                                        break</span>
                                }

                                <span class="cov0" title="0">miner.log.Info("found a new mined block, block height:%d, hash:%s", result.block.Header.Height, result.block.HeaderHash.ToHex())
                                ret := miner.saveBlock(result)
                                if ret != nil </span><span class="cov0" title="0">{
                                        miner.log.Error("saving the block failed, for %s", ret.Error())
                                        break</span>
                                }

                                <span class="cov0" title="0">miner.log.Info("saving block succeeded and notify p2p")
                                event.BlockMinedEventManager.Fire(result.block) // notify p2p to broadcast the block
                                break</span>
                        }

                        <span class="cov0" title="0">atomic.StoreInt32(&amp;miner.mining, 0)
                        // loop mining after mining completed
                        miner.newTxCallback(event.EmptyEvent)</span>
                case &lt;-miner.stopChan:<span class="cov0" title="0">
                        break out</span>
                }
        }
}

// prepareNewBlock prepares a new block to be mined
func (miner *Miner) prepareNewBlock() error <span class="cov0" title="0">{
        miner.log.Debug("starting mining the new block")

        timestamp := time.Now().Unix()
        parent, stateDB, err := miner.seele.BlockChain().GetCurrentInfo()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get current info failed, %s", err)
        }</span>

        <span class="cov0" title="0">if parent.Header.CreateTimestamp.Cmp(new(big.Int).SetInt64(timestamp)) &gt;= 0 </span><span class="cov0" title="0">{
                timestamp = parent.Header.CreateTimestamp.Int64() + 1
        }</span>

        // this will ensure we're not going off too far in the future
        <span class="cov0" title="0">if now := time.Now().Unix(); timestamp &gt; now+1 </span><span class="cov0" title="0">{
                wait := time.Duration(timestamp-now) * time.Second
                miner.log.Info("Mining too far in the future, waiting for %s", wait)
                time.Sleep(wait)
        }</span>

        <span class="cov0" title="0">height := parent.Header.Height
        difficult := pow.GetDifficult(uint64(timestamp), parent.Header)
        header := &amp;types.BlockHeader{
                PreviousBlockHash: parent.HeaderHash,
                Creator:           miner.coinbase,
                Height:            height + 1,
                CreateTimestamp:   big.NewInt(timestamp),
                Difficulty:        difficult,
        }

        miner.log.Debug("miner a block with coinbase %s", miner.coinbase.ToHex())
        miner.current = &amp;Task{
                header:    header,
                createdAt: time.Now(),
                coinbase:  miner.coinbase,
        }

        err = miner.current.applyTransactions(miner.seele, stateDB, miner.log)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("apply transaction failed %s", err)
        }</span>

        <span class="cov0" title="0">miner.log.Info("committing a new task to engine, height:%d, difficult:%d", header.Height, header.Difficulty)
        miner.commitTask(miner.current)

        return nil</span>
}

// saveBlock saves the block in the given result to the blockchain
func (miner *Miner) saveBlock(result *Result) error <span class="cov0" title="0">{
        ret := miner.seele.BlockChain().WriteBlock(result.block)
        return ret
}</span>

// commitTask commits the given task to the miner
func (miner *Miner) commitTask(task *Task) <span class="cov0" title="0">{
        if atomic.LoadInt32(&amp;miner.mining) != 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">threads := miner.threads
        miner.log.Debug("miner threads num:%d", threads)

        var step uint64
        var seed uint64
        if threads != 0 </span><span class="cov0" title="0">{
                step = math.MaxUint64 / uint64(threads)
        }</span>

        <span class="cov0" title="0">var isNonceFound int32 = 0
        r := rand.New(rand.NewSource(time.Now().UnixNano()))
        for i := 0; i &lt; threads; i++ </span><span class="cov0" title="0">{
                if threads == 1 </span><span class="cov0" title="0">{
                        seed = r.Uint64()
                }</span><span class="cov0" title="0"> else {
                        seed = uint64(r.Int63n(int64(step)))
                }</span>
                <span class="cov0" title="0">tSeed := seed + uint64(i)*step
                var min uint64
                var max uint64
                min = uint64(i) * step

                if i != threads-1 </span><span class="cov0" title="0">{
                        max = min + step - 1
                }</span><span class="cov0" title="0"> else {
                        max = math.MaxUint64
                }</span>

                <span class="cov0" title="0">miner.wg.Add(1)
                go func(tseed uint64, tmin uint64, tmax uint64) </span><span class="cov0" title="0">{
                        defer miner.wg.Done()
                        StartMining(task, tseed, tmin, tmax, miner.recv, miner.stopChan, &amp;isNonceFound, miner.hashrate, miner.log)
                }</span>(tSeed, min, max)
        }
}

// Hashrate returns the rate of the POW search invocations per second in the last minute.
func (miner *Miner) Hashrate() float64 <span class="cov0" title="0">{
        return miner.hashrate.Rate1()
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package pow

import (
        "errors"
        "fmt"
        "math/big"

        "github.com/seeleteam/go-seele/core/types"
)

var (
        // maxUint256 is a big integer representing 2^256
        maxUint256 = new(big.Int).Exp(big.NewInt(2), big.NewInt(256), big.NewInt(0))

        errBlockNonceInvalid = errors.New("invalid block nonce")
)

// Engine provides the consensus operations based on POW.
type Engine struct{}

// ValidateHeader validates the specified header and returns error if validation failed.
func (engine Engine) ValidateHeader(blockHeader *types.BlockHeader) error <span class="cov8" title="1">{
        headerHash := blockHeader.Hash()
        var hashInt big.Int
        hashInt.SetBytes(headerHash.Bytes())

        target := GetMiningTarget(blockHeader.Difficulty)

        if hashInt.Cmp(target) &gt; 0 </span><span class="cov8" title="1">{
                return errBlockNonceInvalid
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateRewardAmount validates the specified amount and returns error if validation failed.
func (engine Engine) ValidateRewardAmount(blockHeight uint64, amount *big.Int) error <span class="cov8" title="1">{
        reward := GetReward(blockHeight)

        if amount == nil || amount.Cmp(reward) != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid reward amount, block height %d, want %s, got %s", blockHeight, reward, amount)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetMiningTarget returns the mining target for the specified difficulty.
func GetMiningTarget(difficulty *big.Int) *big.Int <span class="cov8" title="1">{
        return new(big.Int).Div(maxUint256, difficulty)
}</span>

// GetDifficult adjust difficult by parent info
func GetDifficult(time uint64, parentHeader *types.BlockHeader) *big.Int <span class="cov8" title="1">{
        // algorithm:
        // diff = parentDiff + parentDiff / 2048 * max (1 - (blockTime - parentTime) / 10, -99)
        // target block time is 10 seconds
        parentDifficult := parentHeader.Difficulty
        parentTime := parentHeader.CreateTimestamp.Uint64()
        if parentHeader.Height == 0 </span><span class="cov0" title="0">{
                return parentDifficult
        }</span>

        <span class="cov8" title="1">big1 := big.NewInt(1)
        big99 := big.NewInt(-99)
        big2048 := big.NewInt(2048)

        interval := (time - parentTime) / 10
        var x *big.Int
        x = big.NewInt(int64(interval))
        x.Sub(big1, x)
        if x.Cmp(big99) &lt; 0 </span><span class="cov8" title="1">{
                x = big99
        }</span>

        <span class="cov8" title="1">var y = new(big.Int).Set(parentDifficult)
        y.Div(parentDifficult, big2048)

        var result = big.NewInt(0)
        result.Mul(x, y)
        result.Add(parentDifficult, result)

        return result</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package pow

import (
        "math/big"

        "github.com/seeleteam/go-seele/common"
)

var (
        // rewardTable the reward value is per year. Which means the first value is for first year, second value is for second year, etc...
        rewardTableCoin []*big.Int

        // tailReward it is used when out of the reward table. we use a constant reward value.
        tailRewardCoin *big.Int

        // blockNumberPerEra block number per reward era. It is approximation of block number generated per year.
        blockNumberPerEra uint64 = 63000000
)

func init() <span class="cov8" title="1">{
        rewardTable := [...]float64{1.5, 1, 0.4, 0.4, 0.25}
        tailReward := float64(0.25)

        rewardTableCoin = make([]*big.Int, len(rewardTable))
        for i, r := range rewardTable </span><span class="cov8" title="1">{
                rewardTableCoin[i] = convertSeeleToFan(r)
        }</span>

        <span class="cov8" title="1">tailRewardCoin = convertSeeleToFan(tailReward)</span>
}

func convertSeeleToFan(seele float64) *big.Int <span class="cov8" title="1">{
        unit := common.SeeleToFan.Int64()
        f := uint64(seele * float64(unit))

        return big.NewInt(0).SetUint64(f)
}</span>

// GetReward get reward amount according to block height
func GetReward(blockHeight uint64) *big.Int <span class="cov8" title="1">{
        era := int(blockHeight / blockNumberPerEra)

        var result *big.Int
        if era &lt; len(rewardTableCoin) </span><span class="cov8" title="1">{
                result = rewardTableCoin[era]
        }</span><span class="cov8" title="1"> else {
                result = tailRewardCoin
        }</span>

        <span class="cov8" title="1">return big.NewInt(0).Set(result)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package miner

import (
        "math/big"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core"
        "github.com/seeleteam/go-seele/core/state"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/miner/pow"
)

// Task is a mining work for engine, containing block header, transactions, and transaction receipts.
type Task struct {
        header   *types.BlockHeader
        txs      []*types.Transaction
        receipts []*types.Receipt

        createdAt time.Time
        coinbase  common.Address
}

// applyTransactions TODO need to check more about the transactions, such as gas limit
func (task *Task) applyTransactions(seele SeeleBackend, statedb *state.Statedb, log *log.SeeleLog) error <span class="cov0" title="0">{
        // the reward tx will always be at the first of the block's transactions
        reward, err := task.handleMinerRewardTx(statedb)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // choose transactions from the given txs
        <span class="cov0" title="0">task.chooseTransactions(seele, statedb, log)

        log.Info("mining block height:%d, reward:%s, transaction number:%d", task.header.Height, reward, len(task.txs))

        root, err := statedb.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">task.header.StateHash = root

        return nil</span>
}

// handleMinerRewardTx handles the miner reward transaction.
func (task *Task) handleMinerRewardTx(statedb *state.Statedb) (*big.Int, error) <span class="cov0" title="0">{
        reward := pow.GetReward(task.header.Height)
        rewardTx, err := types.NewRewardTransaction(task.coinbase, reward, task.header.CreateTimestamp.Uint64())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rewardTxReceipt, err := core.ApplyRewardTx(rewardTx, statedb)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">task.txs = append(task.txs, rewardTx)

        // add the receipt of the reward tx
        task.receipts = append(task.receipts, rewardTxReceipt)

        return reward, nil</span>
}

func (task *Task) chooseTransactions(seele SeeleBackend, statedb *state.Statedb, log *log.SeeleLog) <span class="cov0" title="0">{
        for i := 0; i &lt; core.BlockTransactionNumberLimit-1; </span><span class="cov0" title="0">{
                txs := seele.TxPool().GetProcessableTransactions(core.BlockTransactionNumberLimit - 1 - i)
                if len(txs) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, tx := range txs </span><span class="cov0" title="0">{
                        if err := tx.Validate(statedb); err != nil </span><span class="cov0" title="0">{
                                seele.TxPool().RemoveTransaction(tx.Hash)
                                log.Error("validate tx %s failed, for %s", tx.Hash.ToHex(), err)
                                continue</span>
                        }

                        <span class="cov0" title="0">receipt, err := seele.BlockChain().ApplyTransaction(tx, i+1, task.coinbase, statedb, task.header)
                        if err != nil </span><span class="cov0" title="0">{
                                seele.TxPool().RemoveTransaction(tx.Hash)
                                log.Error("apply tx %s failed, %s", tx.Hash.ToHex(), err)
                                continue</span>
                        }

                        <span class="cov0" title="0">task.txs = append(task.txs, tx)
                        task.receipts = append(task.receipts, receipt)

                        i++</span>
                }
        }
}

// generateBlock builds a block from task
func (task *Task) generateBlock() *types.Block <span class="cov8" title="1">{
        return types.NewBlock(task.header, task.txs, task.receipts)
}</span>

// Result is the result mined by engine. It contains the raw task and mined block.
type Result struct {
        task  *Task
        block *types.Block // mined block, with good nonce
}
</pre>
		
		<pre class="file" id="file68" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package monitor

import (
        "errors"
        "runtime"

        "github.com/seeleteam/go-seele/common"
)

// error infos
var (
        ErrBlockchainInfoFailed = errors.New("getting blockchain info failed")
        ErrMinerInfoFailed      = errors.New("getting miner info failed")
        ErrNodeInfoFailed       = errors.New("getting node info failed")
        ErrP2PServerInfoFailed  = errors.New("getting p2p server info failed")
)

// PublicMonitorAPI provides an API to the monitor service
type PublicMonitorAPI struct {
        s *MonitorService
}

// NewPublicMonitorAPI create new PublicMonitorAPI
func NewPublicMonitorAPI(s *MonitorService) *PublicMonitorAPI <span class="cov8" title="1">{
        return &amp;PublicMonitorAPI{s}
}</span>

// NodeInfo returns the NodeInfo struct of the local node
func (api *PublicMonitorAPI) NodeInfo(arg int, result *NodeInfo) error <span class="cov8" title="1">{
        *result = NodeInfo{
                Name:       api.s.name,
                Node:       api.s.node,
                Port:       0, //api.s.p2pServer.ListenAddr,
                NetVersion: api.s.seele.NetVersion(),
                Protocol:   "1.0",
                API:        "No",
                Os:         runtime.GOOS,
                OsVer:      runtime.GOARCH,
                Client:     api.s.version,
                History:    true,
                Shard:      common.LocalShardNumber,
        }

        return nil
}</span>

// NodeStats returns the information about the local node.
func (api *PublicMonitorAPI) NodeStats(arg int, result *NodeStats) error <span class="cov8" title="1">{
        if api.s.p2pServer == nil </span><span class="cov8" title="1">{
                return ErrP2PServerInfoFailed
        }</span>

        <span class="cov8" title="1">if api.s.seeleNode == nil </span><span class="cov0" title="0">{
                return ErrNodeInfoFailed
        }</span>

        <span class="cov8" title="1">if api.s.seele.Miner() == nil </span><span class="cov0" title="0">{
                return ErrMinerInfoFailed
        }</span>

        <span class="cov8" title="1">mining := api.s.seele.Miner().IsMining()

        *result = NodeStats{
                Active:  true,
                Syncing: true,
                Mining:  mining,
                Peers:   api.s.p2pServer.PeerCount(),
        }

        return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package monitor

import (
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/node"
        "github.com/seeleteam/go-seele/p2p"
        rpc "github.com/seeleteam/go-seele/rpc2"
        "github.com/seeleteam/go-seele/seele"
)

// MonitorService implements some rpc interfaces provided by a monitor server
type MonitorService struct {
        p2pServer *p2p.Server         // Peer-to-Peer server infos
        seele     *seele.SeeleService // seele full node service
        seeleNode *node.Node          // seele node
        log       *log.SeeleLog

        rpcAddr string // listening port
        name    string // name displayed on the moitor
        node    string // node name
        version string // version
}

// NewMonitorService returns a MonitorService instance
func NewMonitorService(seeleService *seele.SeeleService, seeleNode *node.Node, conf *node.Config, slog *log.SeeleLog, name string) (*MonitorService, error) <span class="cov8" title="1">{
        return &amp;MonitorService{
                seele:     seeleService,
                seeleNode: seeleNode,
                log:       slog,
                name:      name,
                rpcAddr:   conf.BasicConfig.RPCAddr,
                node:      conf.BasicConfig.Name,
                version:   conf.BasicConfig.Version,
        }, nil
}</span>

// Protocols implements node.Service, return nil as it dosn't use the p2p service
func (s *MonitorService) Protocols() []p2p.Protocol <span class="cov8" title="1">{ return nil }</span>

// Start implements node.Service, starting goroutines needed by SeeleService.
func (s *MonitorService) Start(srvr *p2p.Server) error <span class="cov8" title="1">{
        s.p2pServer = srvr

        s.log.Info("monitor rpc service start")

        return nil
}</span>

// Stop implements node.Service, terminating all internal goroutines.
func (s *MonitorService) Stop() error <span class="cov0" title="0">{

        return nil
}</span>

// APIs implements node.Service, returning the collection of RPC services the seele package offers.
func (s *MonitorService) APIs() (apis []rpc.API) <span class="cov8" title="1">{
        return append(apis, []rpc.API{
                {
                        Namespace: "monitor",
                        Version:   "1.0",
                        Service:   NewPublicMonitorAPI(s),
                        Public:    true,
                },
        }...)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package node

import (
        "errors"
        "fmt"
        "math/rand"
        "net"
        "reflect"
        "sync"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/p2p"
        rpc "github.com/seeleteam/go-seele/rpc2"
)

// error infos
var (
        ErrConfigIsNull       = errors.New("config info is null")
        ErrLogIsNull          = errors.New("SeeleLog is null")
        ErrNodeRunning        = errors.New("node is already running")
        ErrNodeStopped        = errors.New("node is not started")
        ErrServiceStartFailed = errors.New("node service starting failed")
        ErrServiceStopFailed  = errors.New("node service stopping failed")
)

// StopError represents an error which is returned when a node fails to stop any registered service
type StopError struct {
        Services map[reflect.Type]error // Services is a container mapping the type of services which fail to stop to error
}

// Error returns a string representation of the stop error.
func (se *StopError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("services: %v", se.Services)
}</span>

// Node is a container for registering services.
type Node struct {
        config *Config

        server   *p2p.Server
        services []Service

        log  *log.SeeleLog
        lock sync.RWMutex

        rpcListener net.Listener // IPC RPC listener socket to serve API requests
        rpcHandler  *rpc.Server  // IPC RPC request handler to process the API requests

        httpEndpoint string       // HTTP endpoint (interface + port) to listen at (empty = HTTP disabled)
        httpListener net.Listener // HTTP RPC listener socket to server API requests
        httpHandler  *rpc.Server  // HTTP RPC request handler to process the API requests

        wsEndpoint string       // Websocket endpoint (interface + port) to listen at (empty = websocket disabled)
        wsListener net.Listener // Websocket RPC listener socket to server API requests
        wsHandler  *rpc.Server  // Websocket RPC request handler to process the API requests
}

// New creates a new P2P node.
func New(conf *Config) (*Node, error) <span class="cov8" title="1">{
        confCopy := *conf
        conf = &amp;confCopy
        nlog := log.GetLogger("node", conf.LogConfig.PrintLog)

        return &amp;Node{
                config:   conf,
                services: []Service{},
                log:      nlog,
        }, nil
}</span>

// Register appends a new service into the node's stack.
func (n *Node) Register(service Service) error <span class="cov8" title="1">{
        n.lock.Lock()
        defer n.lock.Unlock()

        if n.server != nil </span><span class="cov0" title="0">{
                return ErrNodeRunning
        }</span>
        <span class="cov8" title="1">n.services = append(n.services, service)

        return nil</span>
}

// Start starts the p2p node.
func (n *Node) Start() error <span class="cov8" title="1">{
        n.lock.Lock()
        defer n.lock.Unlock()

        if n.server != nil </span><span class="cov0" title="0">{
                return ErrNodeRunning
        }</span>

        //check config
        <span class="cov8" title="1">specificShard := n.config.SeeleConfig.GenesisConfig.ShardNumber
        if specificShard == 0 </span><span class="cov8" title="1">{
                // select a shard randomly
                specificShard = uint(rand.Intn(common.ShardCount) + 1)
        }</span>

        <span class="cov8" title="1">if specificShard &gt; common.ShardCount </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported shard number, it must be in range [0, %d]", common.ShardCount)
        }</span>

        <span class="cov8" title="1">common.LocalShardNumber = specificShard
        n.log.Info("local shard number is %d", common.LocalShardNumber)

        if !n.config.SeeleConfig.Coinbase.Equal(common.Address{}) </span><span class="cov0" title="0">{
                coinbaseShard := n.config.SeeleConfig.Coinbase.Shard()
                n.log.Info("coinbase is %s", n.config.SeeleConfig.Coinbase.ToHex())

                if coinbaseShard != specificShard </span><span class="cov0" title="0">{
                        return fmt.Errorf("coinbase does not match with specific shard number, "+
                                "coinbase shard:%d, specific shard number:%d", coinbaseShard, specificShard)
                }</span>
        }

        <span class="cov8" title="1">protocols := make([]p2p.Protocol, 0)
        for _, service := range n.services </span><span class="cov8" title="1">{
                protocols = append(protocols, service.Protocols()...)
        }</span>

        <span class="cov8" title="1">p2pSever := p2p.NewServer(n.config.SeeleConfig.GenesisConfig, n.config.P2PConfig, protocols)
        if err := p2pSever.Start(n.config.BasicConfig.DataDir, n.config.SeeleConfig.GenesisConfig.ShardNumber); err != nil </span><span class="cov0" title="0">{
                return ErrServiceStartFailed
        }</span>

        // Start services
        <span class="cov8" title="1">for i, service := range n.services </span><span class="cov8" title="1">{
                if err := service.Start(p2pSever); err != nil </span><span class="cov0" title="0">{
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                n.services[j].Stop()
                        }</span>

                        // stop the p2p server
                        <span class="cov0" title="0">p2pSever.Stop()

                        return err</span>
                }
        }

        // Start RPC server
        <span class="cov8" title="1">if err := n.startRPC(n.services); err != nil </span><span class="cov0" title="0">{
                for _, service := range n.services </span><span class="cov0" title="0">{
                        service.Stop()
                }</span>

                // stop the p2p server
                <span class="cov0" title="0">p2pSever.Stop()

                return err</span>
        }

        <span class="cov8" title="1">n.server = p2pSever

        return nil</span>
}

// Stop terminates the running node and services registered.
func (n *Node) Stop() error <span class="cov8" title="1">{
        n.lock.Lock()
        defer n.lock.Unlock()

        if n.server == nil </span><span class="cov0" title="0">{
                return ErrNodeStopped
        }</span>

        // stopErr is intended for possible stop errors
        <span class="cov8" title="1">stopErr := &amp;StopError{
                Services: make(map[reflect.Type]error),
        }

        for _, service := range n.services </span><span class="cov8" title="1">{
                if err := service.Stop(); err != nil </span><span class="cov0" title="0">{
                        stopErr.Services[reflect.TypeOf(service)] = err
                }</span>
        }

        // stop the p2p server
        <span class="cov8" title="1">n.server.Stop()

        n.services = nil
        n.server = nil

        // return the stop errors if any
        if len(stopErr.Services) &gt; 0 </span><span class="cov0" title="0">{
                return stopErr
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package node

import (
        "net"
        "strings"

        rpc "github.com/seeleteam/go-seele/rpc2"
)

// startRPC is a helper method to start all the various RPC endpoint during node
// startup. It's not meant to be called at any time afterwards as it makes certain
// assumptions about the state of the node.
func (n *Node) startRPC(services []Service) error <span class="cov8" title="1">{
        // Gather all the possible APIs to surface
        apis := []rpc.API{}
        for _, service := range services </span><span class="cov8" title="1">{
                apis = append(apis, service.APIs()...)
        }</span>

        // Start the various API endpoints, terminating all in case of errors
        <span class="cov8" title="1">if err := n.startPRC(apis); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := n.startHTTP(apis); err != nil </span><span class="cov0" title="0">{
                n.stopRPC()
                return err
        }</span>

        <span class="cov8" title="1">if err := n.startWS(apis); err != nil </span><span class="cov0" title="0">{
                n.stopHTTP()
                n.stopRPC()
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// startIPC initializes and starts the IPC RPC endpoint.
func (n *Node) startPRC(apis []rpc.API) error <span class="cov8" title="1">{
        endpoint := n.config.BasicConfig.RPCAddr
        // Short circuit if the IPC endpoint isn't being exposed
        if endpoint == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Register all the APIs exposed by the services
        <span class="cov0" title="0">handler := rpc.NewServer()
        for _, api := range apis </span><span class="cov0" title="0">{
                if err := handler.RegisterName(api.Namespace, api.Service); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">n.log.Debug("registered RPC service %s namespace %s", api.Service, api.Namespace)</span>
        }

        // All APIs registered, start the IPC listener
        <span class="cov0" title="0">var (
                listener net.Listener
                err      error
        )
        if listener, err = net.Listen("tcp", endpoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                n.log.Info("RPC opened at address %s", endpoint)

                for </span><span class="cov0" title="0">{
                        conn, err := listener.Accept()
                        if err != nil </span><span class="cov0" title="0">{
                                // Terminate if the listener was closed
                                n.lock.RLock()
                                closed := n.rpcListener == nil
                                n.lock.RUnlock()
                                if closed </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                // Not closed, just some error; report and continue
                                <span class="cov0" title="0">n.log.Error("RPC accept failed. err %s", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">go handler.ServeCodec(rpc.NewJSONCodec(conn), rpc.OptionMethodInvocation|rpc.OptionSubscriptions)</span>
                }
        }()

        // All listeners booted successfully
        <span class="cov0" title="0">n.rpcListener = listener
        n.rpcHandler = handler

        return nil</span>
}

// stopRPC terminates the IPC RPC endpoint.
func (n *Node) stopRPC() <span class="cov0" title="0">{
        if n.rpcListener != nil </span><span class="cov0" title="0">{
                n.rpcListener.Close()
                n.rpcListener = nil

                n.log.Info("RPC closed")
        }</span>
        <span class="cov0" title="0">if n.rpcHandler != nil </span><span class="cov0" title="0">{
                n.rpcHandler.Stop()
                n.rpcHandler = nil
        }</span>
}

// startHTTP initializes and starts the HTTP RPC endpoint.
func (n *Node) startHTTP(apis []rpc.API) error <span class="cov8" title="1">{
        endpoint := n.config.HTTPServer.HTTPAddr
        cors := n.config.HTTPServer.HTTPCors
        vhosts := n.config.HTTPServer.HTTPWhiteHost

        // Short circuit if the HTTP endpoint isn't being exposed
        if endpoint == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Register all the APIs exposed by the services
        <span class="cov0" title="0">handler := rpc.NewServer()
        for _, api := range apis </span><span class="cov0" title="0">{
                if api.Public </span><span class="cov0" title="0">{
                        if err := handler.RegisterName(api.Namespace, api.Service); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">n.log.Debug("HTTP registered service %s namespace %s", api.Service, api.Namespace)</span>
                }
        }

        // All APIs registered, start the HTTP listener
        <span class="cov0" title="0">var (
                listener net.Listener
                err      error
        )
        if listener, err = net.Listen("tcp", endpoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">go rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)
        n.log.Info("HTTP endpoint opened. url http://%s, cors %s, whitehost %s", endpoint, strings.Join(cors, ","), strings.Join(vhosts, ","))

        // All listeners booted successfully
        n.httpEndpoint = endpoint
        n.httpListener = listener
        n.httpHandler = handler

        return nil</span>
}

// stopHTTP terminates the HTTP RPC endpoint.
func (n *Node) stopHTTP() <span class="cov0" title="0">{
        if n.httpListener != nil </span><span class="cov0" title="0">{
                n.httpListener.Close()
                n.httpListener = nil

                n.log.Info("HTTP endpoint closed. url http://%s", n.httpEndpoint)
        }</span>
        <span class="cov0" title="0">if n.httpHandler != nil </span><span class="cov0" title="0">{
                n.httpHandler.Stop()
                n.httpHandler = nil
        }</span>
}

// startWS initializes and starts the websocket RPC endpoint.
func (n *Node) startWS(apis []rpc.API) error <span class="cov8" title="1">{
        endpoint := n.config.WSServerConfig.Address
        wsOrigins := n.config.WSServerConfig.CrossOrigins

        // Short circuit if the WS endpoint isn't being exposed
        if endpoint == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Register all the APIs exposed by the services
        <span class="cov8" title="1">handler := rpc.NewServer()
        for _, api := range apis </span><span class="cov0" title="0">{
                if api.Public </span><span class="cov0" title="0">{
                        if err := handler.RegisterName(api.Namespace, api.Service); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">n.log.Debug("WebSocket registered. service %s namespace %s", api.Service, api.Namespace)</span>
                }
        }

        // All APIs registered, start the HTTP listener
        <span class="cov8" title="1">var (
                listener net.Listener
                err      error
        )
        if listener, err = net.Listen("tcp", endpoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">go rpc.NewWSServer(wsOrigins, handler).Serve(listener)
        n.log.Info("WebSocket endpoint opened. url ws://%s", listener.Addr())

        // All listeners booted successfully
        n.wsEndpoint = endpoint
        n.wsListener = listener
        n.wsHandler = handler

        return nil</span>
}

// stopWS terminates the websocket RPC endpoint.
func (n *Node) stopWS() <span class="cov0" title="0">{
        if n.wsListener != nil </span><span class="cov0" title="0">{
                n.wsListener.Close()
                n.wsListener = nil

                n.log.Info("WebSocket endpoint closed. url ws://%s", n.wsEndpoint)
        }</span>
        <span class="cov0" title="0">if n.wsHandler != nil </span><span class="cov0" title="0">{
                n.wsHandler.Stop()
                n.wsHandler = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package p2p

import (
        "encoding/binary"
        "errors"
        "net"
        "sync"
        "time"
)

const (
        headBuffLength    = 6
        headBuffSizeStart = 0
        headBuffSizeEnd   = 4
        headBuffCodeStart = 4
        headBuffCodeEnd   = 6
)

var (
        errConnWriteTimeout = errors.New("Connection writes timeout")
)

// connection TODO add bandwidth meter for connection
type connection struct {
        fd net.Conn // tcp connection

        rmutux sync.Mutex // read msg lock
        wmutux sync.Mutex // write msg lock
}

// readFull receive from fd till outBuf is full
func (c *connection) readFull(outBuf []byte) (err error) <span class="cov0" title="0">{
        needLen, curPos := len(outBuf), 0
        c.fd.SetReadDeadline(time.Now().Add(frameReadTimeout))
        for needLen &gt; 0 &amp;&amp; err == nil </span><span class="cov0" title="0">{
                var nRead int
                nRead, err = c.fd.Read(outBuf[curPos:])
                needLen -= nRead
                curPos += nRead
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // discard the input data
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// writeFull write to fd till all outBuf is sended,
// if no data is writed (with deadline of connWriteTimeout), returns errConnWriteTimeout.
func (c *connection) writeFull(outBuf []byte) (err error) <span class="cov0" title="0">{
        needLen, curPos := len(outBuf), 0
        for needLen &gt; 0 </span><span class="cov0" title="0">{
                c.fd.SetWriteDeadline(time.Now().Add(connWriteTimeout))
                var curSend int
                curSend, err = c.fd.Write(outBuf[curPos:])
                if err != nil </span><span class="cov0" title="0">{
                        if opErr, ok := err.(*net.OpError); ok &amp;&amp; opErr.Timeout() </span><span class="cov0" title="0">{
                                if curSend == 0 </span><span class="cov0" title="0">{
                                        err = errConnWriteTimeout
                                        break</span>
                                }
                                <span class="cov0" title="0">needLen -= curSend
                                curPos += curSend
                                continue</span>
                        }
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">needLen -= curSend
                curPos += curSend</span>
        }

        <span class="cov0" title="0">return err</span>
}

func (c *connection) close() <span class="cov0" title="0">{
        c.fd.Close()
}</span>

// ReadMsg read msg with a full Message block
func (c *connection) ReadMsg() (msgRecv Message, err error) <span class="cov0" title="0">{
        c.rmutux.Lock()
        defer c.rmutux.Unlock()

        headbuff := make([]byte, headBuffLength)
        if err = c.readFull(headbuff); err != nil </span><span class="cov0" title="0">{
                return Message{}, err
        }</span>

        <span class="cov0" title="0">msgRecv = Message{
                Code: binary.BigEndian.Uint16(headbuff[headBuffCodeStart:headBuffCodeEnd]),
        }

        size := binary.BigEndian.Uint32(headbuff[headBuffSizeStart:headBuffSizeEnd])
        if size &gt; 0 </span><span class="cov0" title="0">{
                msgRecv.Payload = make([]byte, size)
                if err = c.readFull(msgRecv.Payload); err != nil </span><span class="cov0" title="0">{
                        return Message{}, err
                }</span>
        }
        <span class="cov0" title="0">metricsReceiveMessageCountMeter.Mark(1)
        metricsReceivePortSpeedMeter.Mark(headBuffLength + int64(size))
        return msgRecv, nil</span>
}

// WriteMsg message can be any data type
func (c *connection) WriteMsg(msg Message) error <span class="cov0" title="0">{
        c.wmutux.Lock()
        defer c.wmutux.Unlock()

        b := make([]byte, headBuffLength)
        binary.BigEndian.PutUint32(b[headBuffSizeStart:headBuffSizeEnd], uint32(len(msg.Payload)))
        binary.BigEndian.PutUint16(b[headBuffCodeStart:headBuffCodeEnd], msg.Code)

        err := c.writeFull(b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(msg.Payload) &gt; 0 </span><span class="cov0" title="0">{
                err = c.writeFull(msg.Payload)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">metricsSendMessageCountMeter.Mark(1)
        metricsSendPortSpeedMeter.Mark(headBuffLength + int64(len(msg.Payload)))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package discovery

import (
        "sync"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/common/hexutil"
        "github.com/seeleteam/go-seele/crypto"
        log2 "github.com/seeleteam/go-seele/log"
)

const (
        bucketSize = 16 // Kademlia bucket size
)

type bucket struct {
        peers []*Node
        lock  sync.RWMutex //used for peers change

        log *log2.SeeleLog
}

func newBuckets(log *log2.SeeleLog) *bucket <span class="cov8" title="1">{
        return &amp;bucket{
                peers: make([]*Node, 0),
                lock:  sync.RWMutex{},
                log:   log,
        }
}</span>

// addNode add node to bucket, if bucket is full, will remove an old one
func (b *bucket) addNode(node *Node) <span class="cov8" title="1">{
        index := b.findNode(node)

        if index != -1 </span>{<span class="cov8" title="1">
                // do nothing for now
                // TODO lru
        }</span><span class="cov8" title="1"> else {
                b.lock.Lock()
                defer b.lock.Unlock()

                if len(b.peers) &lt; bucketSize </span><span class="cov8" title="1">{
                        b.peers = append(b.peers, node)
                }</span><span class="cov8" title="1"> else {
                        copy(b.peers[:], b.peers[1:])
                        b.peers[len(b.peers)-1] = node
                }</span>
        }
}

// findNode check if the bucket already have this node, if so, return its index, otherwise, return -1
func (b *bucket) findNode(node *Node) int <span class="cov8" title="1">{
        b.lock.RLock()
        defer b.lock.RUnlock()
        for index, n := range b.peers </span><span class="cov8" title="1">{
                if n.ID == node.ID </span><span class="cov8" title="1">{
                        return index
                }</span>
        }

        <span class="cov8" title="1">return -1</span>
}

func (b *bucket) deleteNode(target common.Hash) <span class="cov8" title="1">{
        b.lock.Lock()
        defer b.lock.Unlock()

        index := -1
        for i, n := range b.peers </span><span class="cov8" title="1">{
                sha := crypto.HashBytes(n.ID.Bytes())
                if sha == target </span><span class="cov8" title="1">{
                        index = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if index == -1 </span><span class="cov0" title="0">{
                b.log.Error("Failed to find the node to delete")
                return
        }</span>

        <span class="cov8" title="1">b.log.Info("delete node: %s", hexutil.BytesToHex(b.peers[index].ID.Bytes()))

        b.peers = append(b.peers[:index], b.peers[index+1:]...)</span>
}

func (b *bucket) getRandNodes(number int) []*Node <span class="cov0" title="0">{
        b.lock.RLock()
        defer b.lock.RUnlock()

        var result []*Node
        if len(b.peers) &gt; number </span><span class="cov0" title="0">{
                result = make([]*Node, number)
                // @TODO use random selection
                for i := 0; i &lt; number; i++ </span><span class="cov0" title="0">{
                        result[i] = &amp;Node{}
                        *result[i] = *b.peers[i]
                }</span>
        }<span class="cov0" title="0"> else {
                result = make([]*Node, len(b.peers))
                for i := 0; i &lt; len(result); i++ </span><span class="cov0" title="0">{
                        result[i] = &amp;Node{}
                        *(result[i]) = *(b.peers[i])
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (b *bucket) get(index int) *Node <span class="cov0" title="0">{
        b.lock.RLock()
        defer b.lock.RUnlock()

        if index &lt; len(b.peers) </span><span class="cov0" title="0">{
                return b.peers[index]
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b *bucket) size() int <span class="cov8" title="1">{
        b.lock.RLock()
        defer b.lock.RUnlock()

        return len(b.peers)
}</span>

// printNodeList only use for debug test
func (b *bucket) printNodeList() <span class="cov0" title="0">{
        b.log.Debug("bucket size %d", len(b.peers))

        for _, n := range b.peers </span><span class="cov0" title="0">{
                b.log.Debug("%s", hexutil.BytesToHex(n.ID.Bytes()))
        }</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package discovery

import (
        "encoding/json"
        "io/ioutil"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
        "github.com/seeleteam/go-seele/log"
)

type NodeHook func(node *Node)

type Database struct {
        m              map[common.Hash]*Node
        log            *log.SeeleLog
        mutex          sync.RWMutex
        addNodeHook    NodeHook
        deleteNodeHook NodeHook
}

const (
        // NodesBackupInterval is the nodes info of backup interval time
        NodesBackupInterval = time.Minute * 20

        // NodesBackupFileName is the nodes info of backup file name
        NodesBackupFileName = "nodes.json"
)

// StartSaveNodes will save to a file and open a timer to backup the nodes info
func (db *Database) StartSaveNodes(nodeDir string, done chan struct{}) <span class="cov0" title="0">{
        ticker := time.NewTicker(NodesBackupInterval)
        defer ticker.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        go db.SaveNodes(nodeDir)</span>
                case &lt;-done:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (db *Database) SaveNodes(nodeDir string) <span class="cov8" title="1">{
        db.mutex.RLock()
        defer db.mutex.RUnlock()
        if db.m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">fileFullPath := filepath.Join(nodeDir, NodesBackupFileName)

        nodeStr := make([]string, len(db.m))
        i := 0
        for _, v := range db.m </span><span class="cov8" title="1">{
                nodeStr[i] = v.String()
                i++
        }</span>

        <span class="cov8" title="1">nodeByte, err := json.MarshalIndent(nodeStr, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                db.log.Error("json marshal occur error, for:[%s]", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if !common.FileOrFolderExists(fileFullPath) </span><span class="cov8" title="1">{
                if err := os.MkdirAll(nodeDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        db.log.Error("filePath:[%s] create folder failed, for:[%s]", nodeDir, err.Error())
                        return
                }</span>
        }

        <span class="cov8" title="1">db.log.Info("backups nodes. node length %d", len(db.m))
        if err = ioutil.WriteFile(fileFullPath, nodeByte, 0666); err != nil </span><span class="cov0" title="0">{
                db.log.Error("nodes info backup failed, for:[%s]", err.Error())
                return
        }</span>

        <span class="cov8" title="1">db.log.Debug("nodes:%s info backup success\n", string(nodeByte))</span>
}

func NewDatabase(log *log.SeeleLog) *Database <span class="cov8" title="1">{
        return &amp;Database{
                m:   make(map[common.Hash]*Node),
                log: log,
        }
}</span>

func (db *Database) add(value *Node, notify bool) <span class="cov8" title="1">{
        db.mutex.Lock()
        defer db.mutex.Unlock()

        sha := value.getSha()
        if notify &amp;&amp; db.addNodeHook != nil </span><span class="cov0" title="0">{
                go db.addNodeHook(value)
        }</span>

        <span class="cov8" title="1">db.m[sha] = value</span>
}

func (db *Database) FindByNodeID(id common.Address) (*Node, bool) <span class="cov0" title="0">{
        db.mutex.RLock()
        defer db.mutex.RUnlock()

        sha := crypto.HashBytes(id.Bytes())
        val, ok := db.m[sha]

        return val, ok
}</span>

func (db *Database) delete(id common.Hash) <span class="cov0" title="0">{
        db.mutex.Lock()
        defer db.mutex.Unlock()

        if val, ok := db.m[id]; ok &amp;&amp; db.deleteNodeHook != nil </span><span class="cov0" title="0">{
                go db.deleteNodeHook(val)
        }</span>

        <span class="cov0" title="0">delete(db.m, id)</span>
}

func (db *Database) getRandNodes(number int) []*Node <span class="cov0" title="0">{
        db.mutex.RLock()
        defer db.mutex.RUnlock()

        nodes := make([]*Node, 0)
        count := 0
        for _, value := range db.m </span><span class="cov0" title="0">{
                if count == number </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">nodes = append(nodes, value)
                count++</span>
        }

        <span class="cov0" title="0">return nodes</span>
}

func (db *Database) getRandNode() *Node <span class="cov0" title="0">{
        nodes := db.getRandNodes(1)
        if len(nodes) != 1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return nodes[0]</span>
}

func (db *Database) size() int <span class="cov8" title="1">{
        db.mutex.RLock()
        defer db.mutex.RUnlock()

        return len(db.m)
}</span>

func (db *Database) GetCopy() map[common.Hash]*Node <span class="cov0" title="0">{
        db.mutex.RLock()
        defer db.mutex.RUnlock()

        copyMap := make(map[common.Hash]*Node)
        for key, value := range db.m </span><span class="cov0" title="0">{
                copyMap[key] = value
        }</span>

        <span class="cov0" title="0">return copyMap</span>
}

// SetHookForNewNode this hook will be called when find new Node
// Note it will run in a new go routine
func (db *Database) SetHookForNewNode(hook NodeHook) <span class="cov0" title="0">{
        db.addNodeHook = hook
}</span>

// SetHookForDeleteNode this hook will be called when we lost a Node's connection
// Note it will run in a new go routine
func (db *Database) SetHookForDeleteNode(hook NodeHook) <span class="cov0" title="0">{
        db.deleteNodeHook = hook
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package discovery

import (
        "github.com/seeleteam/go-seele/common"
)

// logDist returns the logarithmic distance between a and b, log2(a ^ b).
// return value is [0, 256]
func logDist(a, b common.Hash) int <span class="cov8" title="1">{
        lz := 0
        for i := range a </span><span class="cov8" title="1">{
                x := a[i] ^ b[i]
                if x == 0 </span><span class="cov8" title="1">{
                        lz += 8
                }</span><span class="cov8" title="1"> else {
                        lz += lzcount[x]
                        break</span>
                }
        }
        <span class="cov8" title="1">return len(a)*8 - lz</span>
}

// distCmp compares the distances a-&gt;to and b-&gt;to.
// Returns -1 if a is closer to target, 1 if b is closer to target
// and 0 if they are equal.
func distCmp(target, a, b common.Hash) int <span class="cov8" title="1">{
        for i := range target </span><span class="cov8" title="1">{
                da := a[i] ^ target[i]
                db := b[i] ^ target[i]
                if da &gt; db </span><span class="cov8" title="1">{
                        return 1
                }</span><span class="cov8" title="1"> else if da &lt; db </span><span class="cov8" title="1">{
                        return -1
                }</span>
        }
        <span class="cov8" title="1">return 0</span>
}

// lzcount table of leading zero counts for bytes [0..255]
var lzcount = [256]int{
        8, 7, 6, 6, 5, 5, 5, 5,
        4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package discovery

import (
        "net"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
)

type msgType uint8

const (
        // add msg type flag at the first byte of the message
        pingMsgType          msgType = 1
        pongMsgType          msgType = 2
        findNodeMsgType      msgType = 3
        neighborsMsgType     msgType = 4
        findShardNodeMsgType msgType = 5
        shardNodeMsgType     msgType = 6
)

func codeToStr(code msgType) string <span class="cov0" title="0">{
        switch code </span>{
        case pingMsgType:<span class="cov0" title="0">
                return "pingMsgType"</span>
        case pongMsgType:<span class="cov0" title="0">
                return "pongMsgType"</span>
        case findNodeMsgType:<span class="cov0" title="0">
                return "findNodeMsgType"</span>
        case neighborsMsgType:<span class="cov0" title="0">
                return "neighborsMsgType"</span>
        case findShardNodeMsgType:<span class="cov0" title="0">
                return "findShardNodeMsgType"</span>
        case shardNodeMsgType:<span class="cov0" title="0">
                return "shardNodeMsgType"</span>
        default:<span class="cov0" title="0">
                return "unkwown"</span>
        }
}

const (
        discoveryProtocolVersion uint = 1
)

type ping struct {
        Version   uint // TODO add version check
        SelfID    common.Address
        SelfShard uint

        to *Node
}

type pong struct {
        SelfID    common.Address
        SelfShard uint
}

type findNode struct {
        SelfID  common.Address
        QueryID common.Address // the ID we want to query in Kademila

        to *Node // the node that send request to
}

type neighbors struct {
        SelfID common.Address
        Nodes  []*rpcNode
}

type findShardNode struct {
        SelfID       common.Address
        RequestShard uint // request shard info

        to *Node
}

type shardNode struct {
        SelfID       common.Address
        RequestShard uint // request shard info
        Nodes        []*rpcNode
}

type rpcNode struct {
        SelfID  common.Address
        IP      net.IP
        UDPPort uint16
        Shard   uint
}

func (r *rpcNode) ToNode() *Node <span class="cov0" title="0">{
        return NewNode(r.SelfID, r.IP, int(r.UDPPort), r.Shard)
}</span>

func ConvertToRpcNode(n *Node) *rpcNode <span class="cov0" title="0">{
        return &amp;rpcNode{
                SelfID:  n.ID,
                IP:      n.IP,
                UDPPort: uint16(n.UDPPort),
                Shard:   n.Shard,
        }
}</span>

func byteToMsgType(byte byte) msgType <span class="cov0" title="0">{
        return msgType(uint8(byte))
}</span>

func msgTypeToByte(t msgType) byte <span class="cov0" title="0">{
        return byte(t)
}</span>

func generateBuff(code msgType, encoding []byte) []byte <span class="cov0" title="0">{
        buff := []byte{msgTypeToByte(code)}

        return append(buff, encoding...)
}</span>

// handle send pong msg and add pending
func (m *ping) handle(t *udp, from *net.UDPAddr) <span class="cov0" title="0">{
        node := NewNodeWithAddr(m.SelfID, from, m.SelfShard)
        t.addNode(node, false)
        t.timeoutNodesCount.Set(m.SelfID.ToHex(), 0)

        // response with pong
        if m.Version != discoveryProtocolVersion </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp := &amp;pong{
                SelfID:    t.self.ID,
                SelfShard: t.self.Shard,
        }

        t.log.Debug("received [pingMsg] and send [pongMsg] to: %s", node)
        t.sendMsg(pongMsgType, resp, node.ID, node.GetUDPAddr())</span>
}

// send send ping message and handle callback
func (m *ping) send(t *udp) <span class="cov0" title="0">{
        t.log.Debug("send [pingMsg] to: %s", m.to)

        p := &amp;pending{
                from: m.to,
                code: pongMsgType,

                callback: func(resp interface{}, addr *net.UDPAddr) (done bool) </span><span class="cov0" title="0">{
                        r := resp.(*pong)
                        n := NewNodeWithAddr(r.SelfID, addr, r.SelfShard)
                        t.addNode(n, true)
                        t.timeoutNodesCount.Set(n.ID.ToHex(), 0)

                        t.log.Debug("received [pongMsg] from: %s", n)

                        return true
                }</span>,
                errorCallBack: func() <span class="cov0" title="0">{ // delete this node when ping timeout, TODO add time limit
                        t.deleteNode(m.to)
                }</span>,
        }

        <span class="cov0" title="0">t.addPending &lt;- p
        t.sendMsg(pingMsgType, m, m.to.ID, m.to.GetUDPAddr())</span>
}

// handle response find node request
func (m *findNode) handle(t *udp, from *net.UDPAddr) <span class="cov0" title="0">{
        t.log.Debug("received request [findNodeMsg] from: %s, id: %s", from, m.SelfID.ToHex())

        nodes := t.table.findNodeWithTarget(crypto.HashBytes(m.QueryID.Bytes()))

        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rpcs := make([]*rpcNode, len(nodes))
        for index, n := range nodes </span><span class="cov0" title="0">{
                rpcs[index] = ConvertToRpcNode(n)
        }</span>

        <span class="cov0" title="0">response := &amp;neighbors{
                Nodes:  rpcs,
                SelfID: t.self.ID,
        }

        t.sendMsg(neighborsMsgType, response, m.SelfID, from)</span>
}

// send send find node message and handle callback
func (m *findNode) send(t *udp) <span class="cov0" title="0">{
        t.log.Debug("send request [findNodeMsg] to: %s", m.to)

        p := &amp;pending{
                from: m.to,
                code: neighborsMsgType,

                callback: func(resp interface{}, addr *net.UDPAddr) (done bool) </span><span class="cov0" title="0">{
                        r := resp.(*neighbors)

                        t.log.Debug("received [neighborsMsg] from: %s with %d nodes", r.SelfID.ToHex(), len(r.Nodes))
                        if r.Nodes == nil || len(r.Nodes) == 0 </span><span class="cov0" title="0">{
                                return true
                        }</span>

                        <span class="cov0" title="0">for _, n := range r.Nodes </span><span class="cov0" title="0">{
                                t.log.Debug("received node: %s", n.SelfID.ToHex())

                                node := n.ToNode()
                                t.addNode(node, false)
                        }</span>

                        <span class="cov0" title="0">return true</span>
                },
                errorCallBack: func() {<span class="cov0" title="0">
                        // do nothing
                }</span>,
        }

        <span class="cov0" title="0">t.addPending &lt;- p
        t.sendMsg(findNodeMsgType, m, m.to.ID, m.to.GetUDPAddr())</span>
}

func sendFindNodeRequest(u *udp, nodes []*Node, target common.Address) <span class="cov0" title="0">{
        if nodes == nil || len(nodes) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">concurrentCount := 0
        for _, n := range nodes </span><span class="cov0" title="0">{
                f := &amp;findNode{
                        SelfID:  u.self.ID,
                        QueryID: target,
                        to:      n,
                }

                f.send(u)

                concurrentCount++
                if concurrentCount == discoveryConcurrentNumber </span><span class="cov0" title="0">{
                        time.Sleep(discoveryInterval)
                        concurrentCount = 0
                }</span>
        }

        <span class="cov0" title="0">time.Sleep(discoveryInterval)</span>
}

func sendFindShardNodeRequest(u *udp, shard uint, to *Node) <span class="cov0" title="0">{
        query := &amp;findShardNode{
                SelfID:       u.self.ID,
                RequestShard: shard,

                to: to,
        }

        query.send(u)
}</span>

func (m *findShardNode) send(t *udp) <span class="cov0" title="0">{
        t.log.Debug("send request [findShardNodeMsg], shard: %d, to node: %s", m.RequestShard, m.to)

        p := &amp;pending{
                from: m.to,
                code: shardNodeMsgType,

                callback: func(resp interface{}, addr *net.UDPAddr) (done bool) </span><span class="cov0" title="0">{
                        r := resp.(*shardNode)
                        t.log.Debug("got response [shardNodeMsg] with nodes number %d in shard %d from:%s",
                                len(r.Nodes), r.RequestShard, addr)
                        for _, node := range r.Nodes </span><span class="cov0" title="0">{
                                t.addNode(node.ToNode(), false)
                        }</span>

                        <span class="cov0" title="0">return true</span>
                },
                errorCallBack: func() {<span class="cov0" title="0">
                }</span>,
        }

        <span class="cov0" title="0">t.addPending &lt;- p
        t.sendMsg(findShardNodeMsgType, m, m.to.ID, m.to.GetUDPAddr())</span>
}

func (m *findShardNode) handle(t *udp, from *net.UDPAddr) <span class="cov0" title="0">{
        t.log.Debug("got request [findShardNodeMsg] from: %s, find shard %d", from, m.RequestShard)

        var nodes []*Node
        if m.RequestShard == t.self.Shard </span><span class="cov0" title="0">{
                nodes = t.table.GetRandNodes(responseNodeNumber)
        }</span><span class="cov0" title="0"> else {
                bucket := t.table.shardBuckets[m.RequestShard]
                nodes = bucket.getRandNodes(responseNodeNumber)
        }</span>

        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rpcNodes := make([]*rpcNode, len(nodes))
        for i := 0; i &lt; len(nodes); i++ </span><span class="cov0" title="0">{
                rpcNodes[i] = ConvertToRpcNode(nodes[i])
        }</span>

        <span class="cov0" title="0">response := &amp;shardNode{
                SelfID:       t.self.ID,
                RequestShard: m.RequestShard,
                Nodes:        rpcNodes,
        }

        t.sendMsg(shardNodeMsgType, response, m.SelfID, from)</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package discovery

import (
        "net"
)

func getUDPConn(addr *net.UDPAddr) (*net.UDPConn, error) <span class="cov0" title="0">{
        conn, err := net.ListenUDP("udp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return conn, nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package discovery

import (
        "encoding/hex"
        "errors"
        "fmt"
        "net"
        "strconv"
        "strings"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
)

var (
        errInvalidNodeString = errors.New("invalid node string")
        errNodeHeaderInvalid = errors.New("node id should start with snode://")

        nodeHeader = "snode://"
)

// Node the node that contains its public key and network address
type Node struct {
        ID               common.Address //public key actually
        IP               net.IP
        UDPPort, TCPPort int

        Shard uint //node shard number

        // node id for Kademila, which is generated from public key
        // better to get it with getSha()
        sha common.Hash
}

// NewNode new node with its value
func NewNode(id common.Address, ip net.IP, port int, shard uint) *Node <span class="cov8" title="1">{
        return &amp;Node{
                ID:      id,
                IP:      ip,
                UDPPort: port,
                Shard:   shard,
        }
}</span>

// NewNodeWithAddr new node with id and network address
func NewNodeWithAddr(id common.Address, addr *net.UDPAddr, shard uint) *Node <span class="cov8" title="1">{
        return NewNode(id, addr.IP, addr.Port, shard)
}</span>

func NewNodeFromIP(id string) (*Node, error) <span class="cov8" title="1">{
        addr, err := net.ResolveUDPAddr("udp", id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">node := NewNodeWithAddr(common.Address{}, addr, 0)
        return node, nil</span>
}

func NewNodeFromString(id string) (*Node, error) <span class="cov8" title="1">{
        if !strings.HasPrefix(id, nodeHeader) </span><span class="cov0" title="0">{
                return nil, errNodeHeaderInvalid
        }</span>

        // cut prefix header
        <span class="cov8" title="1">id = id[len(nodeHeader):]

        // node id
        idSplit := strings.Split(id, "@")
        if len(idSplit) != 2 </span><span class="cov0" title="0">{
                return nil, errInvalidNodeString
        }</span>

        <span class="cov8" title="1">nodeId, err := hex.DecodeString(idSplit[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">publicKey, err := common.NewAddress(nodeId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // udp address
        <span class="cov8" title="1">addrSplit := strings.Split(idSplit[1], "[")
        if len(addrSplit) != 2 </span><span class="cov0" title="0">{
                return nil, errInvalidNodeString
        }</span>

        <span class="cov8" title="1">addr, err := net.ResolveUDPAddr("udp", addrSplit[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // shard
        <span class="cov8" title="1">if len(addrSplit[1]) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errInvalidNodeString
        }</span>

        <span class="cov8" title="1">shardStr := addrSplit[1][:len(addrSplit[1])-1]
        shard, err := strconv.Atoi(shardStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">node := NewNodeWithAddr(publicKey, addr, uint(shard))
        return node, nil</span>
}

func (n *Node) GetUDPAddr() *net.UDPAddr <span class="cov8" title="1">{
        return &amp;net.UDPAddr{
                IP:   n.IP,
                Port: int(n.UDPPort),
        }
}</span>

func (n *Node) setShard(shard uint) <span class="cov0" title="0">{
        n.Shard = shard
}</span>

func (n *Node) getSha() common.Hash <span class="cov8" title="1">{
        if n.sha == common.EmptyHash </span><span class="cov8" title="1">{
                n.sha = crypto.HashBytes(n.ID.Bytes())
        }</span>

        <span class="cov8" title="1">return n.sha</span>
}

func (n *Node) String() string <span class="cov8" title="1">{
        addr := n.GetUDPAddr().String()
        hex := hex.EncodeToString(n.ID.Bytes())
        return fmt.Sprintf(nodeHeader+"%s@%s[%d]", hex, addr, n.Shard)
}</span>

func (node *Node) UnmarshalText(json []byte) error <span class="cov0" title="0">{
        n, err := NewNodeFromIP(string(json))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*node = *n
        return nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package discovery

import (
        "net"

        "github.com/seeleteam/go-seele/common"
)

func StartService(nodeDir string, myId common.Address, myAddr *net.UDPAddr, bootstrap []*Node, shard uint) *Database <span class="cov0" title="0">{
        udp := newUDP(myId, myAddr, shard)

        if bootstrap != nil </span><span class="cov0" title="0">{
                udp.trustNodes = bootstrap
        }</span>
        <span class="cov0" title="0">udp.loadNodes(nodeDir)
        udp.StartServe(nodeDir)

        return udp.db</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package discovery

import (
        "net"
        "sort"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/log"
)

const (
        alpha                = 3 // Kademlia concurrency factor
        responseNodeNumber   = 5 // TODO with this number for test
        hashBits             = len(common.Hash{}) * 8
        nBuckets             = hashBits + 1 // Number of buckets
        shardTargeNodeNumber = 1            // other shard minimal node number for start
        UndefinedShardNumber = 0            // UndefinedShardNumber indicates the shard number is undefined
)

type Table struct {
        buckets      [nBuckets]*bucket
        shardBuckets [common.ShardCount + 1]*bucket // 0 represents undefined shard number node.
        selfNode     *Node                           //info of local node

        log *log.SeeleLog
}

func newTable(id common.Address, addr *net.UDPAddr, shard uint, log *log.SeeleLog) *Table <span class="cov8" title="1">{
        selfNode := NewNodeWithAddr(id, addr, shard)

        table := &amp;Table{
                selfNode: selfNode,
                log:      log,
        }

        for i := 0; i &lt; nBuckets; i++ </span><span class="cov8" title="1">{
                table.buckets[i] = newBuckets(log)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; common.ShardCount+1; i++ </span><span class="cov8" title="1">{
                table.shardBuckets[i] = newBuckets(log)
        }</span>

        <span class="cov8" title="1">return table</span>
}

func (t *Table) addNode(node *Node) <span class="cov8" title="1">{
        if node.Shard != t.selfNode.Shard </span><span class="cov0" title="0">{
                t.shardBuckets[node.Shard].addNode(node)
        }</span><span class="cov8" title="1"> else {
                dis := logDist(t.selfNode.getSha(), node.getSha())

                t.buckets[dis].addNode(node)
        }</span>
}

func (t *Table) updateNode(node *Node) <span class="cov0" title="0">{
        t.addNode(node)
}</span>

// findNodeWithTarget find nodes that distance of target is less than measure with target
func (t *Table) findNodeWithTarget(target common.Hash) []*Node <span class="cov0" title="0">{
        nodes := t.findMinDisNodes(target, responseNodeNumber)

        minDis := []*Node{}
        for _, e := range nodes </span><span class="cov0" title="0">{
                if distCmp(target, t.selfNode.getSha(), e.getSha()) &gt; 0 </span><span class="cov0" title="0">{
                        minDis = append(minDis, e)
                }</span>
        }

        <span class="cov0" title="0">return minDis</span>
}

func (t *Table) deleteNode(n *Node) <span class="cov0" title="0">{
        sha := n.getSha()
        if n.Shard != t.selfNode.Shard </span><span class="cov0" title="0">{
                t.shardBuckets[n.Shard].deleteNode(sha)
        }</span><span class="cov0" title="0"> else {
                dis := logDist(t.selfNode.getSha(), sha)
                t.buckets[dis].deleteNode(sha)
        }</span>
}

// findNodeForRequest calls when start find node, find the initialize nodes
func (t *Table) findNodeForRequest(target common.Hash) []*Node <span class="cov0" title="0">{
        return t.findMinDisNodes(target, alpha)
}</span>

func (t *Table) findMinDisNodes(target common.Hash, number int) []*Node <span class="cov0" title="0">{
        result := nodesByDistance{
                target:   target,
                maxElems: number,
                entries:  make([]*Node, 0),
        }

        for _, b := range t.buckets </span><span class="cov0" title="0">{
                for _, n := range b.peers </span><span class="cov0" title="0">{
                        result.push(n)
                }</span>
        }

        <span class="cov0" title="0">return result.entries</span>
}

func (t *Table) GetRandNodes(number int) []*Node <span class="cov0" title="0">{
        // TODO get nodes randomly
        nodes := make([]*Node, 0)
        count := 0
        for i := 0; i &lt; nBuckets; i++ </span><span class="cov0" title="0">{
                b := t.buckets[i]
                if b.size() &gt; 0 </span><span class="cov0" title="0">{
                        bnodes := b.getRandNodes(number)

                        for j := 0; j &lt; len(bnodes); j++ </span><span class="cov0" title="0">{
                                nodes = append(nodes, bnodes[j])
                                count++

                                if count == number </span><span class="cov0" title="0">{
                                        return nodes
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nodes</span>
}

// nodesByDistance is a list of nodes, ordered by
// distance to to.
type nodesByDistance struct {
        entries  []*Node
        target   common.Hash
        maxElems int
}

// push adds the given node to the list, keeping the total size below maxElems.
func (h *nodesByDistance) push(n *Node) <span class="cov0" title="0">{
        ix := sort.Search(len(h.entries), func(i int) bool </span><span class="cov0" title="0">{
                return distCmp(h.target, h.entries[i].getSha(), n.getSha()) &gt; 0
        }</span>)
        <span class="cov0" title="0">if len(h.entries) &lt; h.maxElems </span><span class="cov0" title="0">{
                h.entries = append(h.entries, n)
        }</span>
        <span class="cov0" title="0">if ix == len(h.entries) </span>{<span class="cov0" title="0">
                // farther away than all nodes we already have.
                // if there was room for it, the node is now the last element.
        }</span><span class="cov0" title="0"> else {
                // slide existing entries down to make room
                // this will overwrite the entry we just appended.
                copy(h.entries[ix+1:], h.entries[ix:])
                h.entries[ix] = n
        }</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package discovery

import (
        "container/list"
        "encoding/json"
        "fmt"
        "io/ioutil"
        rand2 "math/rand"
        "net"
        "path/filepath"
        "time"

        "github.com/orcaman/concurrent-map"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto"
        "github.com/seeleteam/go-seele/log"
)

const (
        responseTimeout = 20 * time.Second

        pingpongConcurrentNumber = 5
        pingpongInterval         = 30 * time.Second // sleep between ping pong, must big than response time out

        discoveryConcurrentNumber = 5
        discoveryInterval         = 35 * time.Second // sleep between discovery, must big than response time out

        // a node will be delete after n continuous time out.
        timeoutCountForDeleteNode = 8
)

type udp struct {
        conn           *net.UDPConn
        self           *Node
        table          *Table
        trustNodes     []*Node
        bootstrapNodes []*Node

        db        *Database
        localAddr *net.UDPAddr

        gotReply   chan *reply
        addPending chan *pending
        writer     chan *send

        log *log.SeeleLog

        timeoutNodesCount cmap.ConcurrentMap //node id -&gt; count
}

type pending struct {
        from *Node
        code msgType

        deadline time.Time

        callback func(resp interface{}, addr *net.UDPAddr) (done bool)

        errorCallBack func()
}

type send struct {
        toId   common.Address
        toAddr *net.UDPAddr
        buff   []byte
        code   msgType
}

type reply struct {
        fromId   common.Address
        fromAddr *net.UDPAddr
        code     msgType

        err bool // got error when send msg

        data interface{}
}

func newUDP(id common.Address, addr *net.UDPAddr, shard uint) *udp <span class="cov0" title="0">{
        log := log.GetLogger("discovery", common.LogConfig.PrintLog)
        conn, err := getUDPConn(addr)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("listen addr %s failed", addr.String()))</span>
        }

        <span class="cov0" title="0">transport := &amp;udp{
                conn:      conn,
                table:     newTable(id, addr, shard, log),
                self:      NewNodeWithAddr(id, addr, shard),
                localAddr: addr,

                db: NewDatabase(log),

                gotReply:   make(chan *reply, 1),
                addPending: make(chan *pending, 1),
                writer:     make(chan *send, 1),

                log:               log,
                timeoutNodesCount: cmap.New(),
        }

        return transport</span>
}

func (u *udp) sendMsg(t msgType, msg interface{}, toId common.Address, toAddr *net.UDPAddr) <span class="cov0" title="0">{
        encoding, err := common.Serialize(msg)
        if err != nil </span><span class="cov0" title="0">{
                u.log.Info(err.Error())
                return
        }</span>

        <span class="cov0" title="0">buff := generateBuff(t, encoding)
        s := &amp;send{
                buff:   buff,
                toId:   toId,
                toAddr: toAddr,
                code:   t,
        }

        u.writer &lt;- s</span>
}

func (u *udp) sendConnMsg(buff []byte, conn *net.UDPConn, to *net.UDPAddr) bool <span class="cov0" title="0">{
        n, err := conn.WriteToUDP(buff, to)
        if err != nil </span><span class="cov0" title="0">{
                u.log.Warn("discovery send msg to %s failed:%s", to, err)
                return false
        }</span>

        <span class="cov0" title="0">if n != len(buff) </span><span class="cov0" title="0">{
                u.log.Warn("discovery send msg failed to %s, expected length: %d, actual length: %d", to, len(buff), n)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (u *udp) sendLoop() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case s := &lt;-u.writer:<span class="cov0" title="0">
                        success := u.sendConnMsg(s.buff, u.conn, s.toAddr)
                        if !success </span><span class="cov0" title="0">{
                                r := &amp;reply{
                                        fromId:   s.toId,
                                        fromAddr: s.toAddr,
                                        code:     s.code,
                                        err:      true,
                                }

                                u.gotReply &lt;- r
                        }</span>
                }
        }
}

func (u *udp) handleMsg(from *net.UDPAddr, data []byte) <span class="cov0" title="0">{
        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                code := byteToMsgType(data[0])

                if common.PrintExplosionLog </span><span class="cov0" title="0">{
                        u.log.Debug("receive msg type: %s", codeToStr(code))
                }</span>
                <span class="cov0" title="0">switch code </span>{
                case pingMsgType:<span class="cov0" title="0">
                        msg := &amp;ping{}
                        err := common.Deserialize(data[1:], &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                u.log.Warn(err.Error())
                                return
                        }</span>

                        // response ping
                        <span class="cov0" title="0">msg.handle(u, from)</span>
                case pongMsgType:<span class="cov0" title="0">
                        msg := &amp;pong{}
                        err := common.Deserialize(data[1:], &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                u.log.Warn(err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">r := &amp;reply{
                                fromId:   msg.SelfID,
                                fromAddr: from,
                                code:     code,
                                data:     msg,
                                err:      false,
                        }

                        u.gotReply &lt;- r</span>
                case findNodeMsgType:<span class="cov0" title="0">
                        msg := &amp;findNode{}

                        err := common.Deserialize(data[1:], &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                u.log.Warn(err.Error())
                                return
                        }</span>

                        //response find
                        <span class="cov0" title="0">msg.handle(u, from)</span>
                case neighborsMsgType:<span class="cov0" title="0">
                        msg := &amp;neighbors{}
                        err := common.Deserialize(data[1:], &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                u.log.Warn(err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">r := &amp;reply{
                                fromId:   msg.SelfID,
                                fromAddr: from,
                                code:     code,
                                data:     msg,
                                err:      false,
                        }

                        u.gotReply &lt;- r</span>
                case findShardNodeMsgType:<span class="cov0" title="0">
                        msg := &amp;findShardNode{}
                        err := common.Deserialize(data[1:], &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                u.log.Warn(err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">msg.handle(u, from)</span>
                case shardNodeMsgType:<span class="cov0" title="0">
                        msg := &amp;shardNode{}
                        err := common.Deserialize(data[1:], &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                u.log.Warn(err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">r := &amp;reply{
                                fromId:   msg.SelfID,
                                fromAddr: from,
                                code:     code,
                                data:     msg,
                                err:      false,
                        }

                        u.gotReply &lt;- r</span>
                default:<span class="cov0" title="0">
                        u.log.Error("unknown code %d", code)</span>
                }
        }<span class="cov0" title="0"> else {
                u.log.Info("wrong length")
        }</span>
}

func (u *udp) readLoop() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                // 1472 is udp max transfer size for once
                data := make([]byte, 1472)
                n, remoteAddr, err := u.conn.ReadFromUDP(data)
                if err != nil </span><span class="cov0" title="0">{
                        u.log.Warn("discovery read from udp failed. %s", err)
                        continue</span>
                }

                <span class="cov0" title="0">data = data[:n]
                u.handleMsg(remoteAddr, data)</span>
        }
}

func (u *udp) loopReply() <span class="cov0" title="0">{
        pendingList := list.New()

        var timeout = time.NewTimer(0)
        &lt;-timeout.C
        defer timeout.Stop()

        resetTimer := func() </span><span class="cov0" title="0">{
                minTime := responseTimeout
                now := time.Now()
                for el := pendingList.Front(); el != nil; el = el.Next() </span><span class="cov0" title="0">{
                        p := el.Value.(*pending)
                        duration := p.deadline.Sub(now)
                        if duration &lt; 0 </span>{<span class="cov0" title="0">
                        }</span><span class="cov0" title="0"> else {
                                if duration &lt; minTime </span><span class="cov0" title="0">{
                                        minTime = duration
                                }</span>
                        }
                }

                <span class="cov0" title="0">timeout.Reset(minTime)</span>
        }

        <span class="cov0" title="0">resetTimer()

        for </span><span class="cov0" title="0">{
                select </span>{
                case r := &lt;-u.gotReply:<span class="cov0" title="0">
                        for el := pendingList.Front(); el != nil; el = el.Next() </span><span class="cov0" title="0">{
                                p := el.Value.(*pending)

                                if p.code == r.code &amp;&amp; p.from.GetUDPAddr().String() == r.fromAddr.String() </span><span class="cov0" title="0">{
                                        if r.err </span><span class="cov0" title="0">{
                                                p.errorCallBack()
                                                pendingList.Remove(el)
                                        }</span><span class="cov0" title="0"> else {
                                                if p.callback(r.data, r.fromAddr) </span><span class="cov0" title="0">{
                                                        pendingList.Remove(el)
                                                }</span>
                                        }
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                case p := &lt;-u.addPending:<span class="cov0" title="0">
                        p.deadline = time.Now().Add(responseTimeout)
                        pendingList.PushBack(p)</span>
                case &lt;-timeout.C:<span class="cov0" title="0">
                        for el := pendingList.Front(); el != nil; el = el.Next() </span><span class="cov0" title="0">{
                                p := el.Value.(*pending)
                                if p.deadline.Sub(time.Now()) &lt;= 0 </span><span class="cov0" title="0">{
                                        errorMsg := fmt.Sprintf("time out to wait for msg with msg type %s for node %s", codeToStr(p.code), p.from)
                                        if p.code == pongMsgType </span><span class="cov0" title="0">{
                                                u.log.Info(errorMsg)
                                        }</span><span class="cov0" title="0"> else {
                                                u.log.Debug(errorMsg)
                                        }</span>

                                        <span class="cov0" title="0">p.errorCallBack()
                                        pendingList.Remove(el)</span>
                                }
                        }

                        <span class="cov0" title="0">resetTimer()</span>
                }
        }
}

func (u *udp) discovery() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                id, err := crypto.GenerateRandomAddress()
                if err != nil </span><span class="cov0" title="0">{
                        u.log.Error(err.Error())
                        continue</span>
                }

                <span class="cov0" title="0">nodes := u.table.findNodeForRequest(crypto.HashBytes(id.Bytes()))

                u.log.Debug("query node with id: %s", id.ToHex())
                sendFindNodeRequest(u, nodes, *id)

                concurrentCount := 0
                for i := 1; i &lt; common.ShardCount+1; i++ </span><span class="cov0" title="0">{
                        shardBucket := u.table.shardBuckets[i]
                        size := shardBucket.size()
                        if size &lt; bucketSize </span><span class="cov0" title="0">{
                                var node *Node
                                if size == 0 </span><span class="cov0" title="0">{
                                        node = u.db.getRandNode()
                                }</span><span class="cov0" title="0"> else {
                                        // request same shard node will find more nodes
                                        selectNode := rand2.Intn(size)
                                        node = shardBucket.get(selectNode)
                                }</span>

                                <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">sendFindShardNodeRequest(u, uint(i), node)

                                concurrentCount++
                                if concurrentCount == discoveryConcurrentNumber </span><span class="cov0" title="0">{
                                        time.Sleep(discoveryInterval)
                                        concurrentCount = 0
                                }</span>
                        }
                }

                <span class="cov0" title="0">time.Sleep(discoveryInterval)</span>
        }
}

func (u *udp) pingPongService() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                copyMap := u.db.GetCopy()
                loopPingPongNodes := make(map[string]*Node, 0)

                // loopPingPongNodes add backup nodes, only ping pong once
                if len(u.bootstrapNodes) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range u.bootstrapNodes </span><span class="cov0" title="0">{
                                loopPingPongNodes[u.bootstrapNodes[i].GetUDPAddr().String()] = u.bootstrapNodes[i]
                        }</span>
                        <span class="cov0" title="0">u.bootstrapNodes = nil</span>
                }

                // loopPingPongNodes add trust nodes, loop ping pong; if bootstrapNodes have the same key, will use the trust node to update it
                <span class="cov0" title="0">if len(u.trustNodes) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range u.trustNodes </span><span class="cov0" title="0">{
                                loopPingPongNodes[u.trustNodes[i].GetUDPAddr().String()] = u.trustNodes[i]
                        }</span>
                }

                // loopPingPongNodes add db nodes, loop ping pong; if bootstrapNodes or trustNodes have the same key, will use the db node to update it
                <span class="cov0" title="0">if len(copyMap) &gt; 0 </span><span class="cov0" title="0">{
                        for _, value := range copyMap </span><span class="cov0" title="0">{
                                loopPingPongNodes[value.GetUDPAddr().String()] = value
                        }</span>
                }

                <span class="cov0" title="0">u.log.Debug("loop ping pong nodes %d", len(loopPingPongNodes))
                concurrentCount := 0
                for _, n := range loopPingPongNodes </span><span class="cov0" title="0">{
                        u.ping(n)

                        concurrentCount++
                        if concurrentCount == pingpongConcurrentNumber </span><span class="cov0" title="0">{
                                time.Sleep(pingpongInterval)
                                concurrentCount = 0
                        }</span>
                }

                <span class="cov0" title="0">time.Sleep(pingpongInterval)</span>
        }
}

func (u *udp) ping(value *Node) <span class="cov0" title="0">{
        p := &amp;ping{
                Version:   discoveryProtocolVersion,
                SelfID:    u.self.ID,
                SelfShard: u.self.Shard,

                to: value,
        }

        p.send(u)
}</span>

func (u *udp) StartServe(nodeDir string) <span class="cov0" title="0">{
        go u.readLoop()
        go u.loopReply()
        go u.discovery()
        go u.pingPongService()
        go u.sendLoop()
        go u.db.StartSaveNodes(nodeDir, make(chan struct{}))
}</span>

// only notify connect when got pong msg
func (u *udp) addNode(n *Node, notifyConnect bool) <span class="cov8" title="1">{
        if n == nil || u.self.ID.Equal(n.ID) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">count := u.db.size()
        u.table.addNode(n)
        u.db.add(n, notifyConnect)

        newCount := u.db.size()
        if count != newCount </span><span class="cov8" title="1">{
                u.log.Info("add node %s, total nodes:%d", n, newCount)
        }</span><span class="cov0" title="0"> else {
                u.log.Debug("got add node event, but it is already exist. total nodes didn't change:%d", newCount)
        }</span>
}

func (u *udp) deleteNode(n *Node) <span class="cov0" title="0">{
        selfSha := u.self.getSha()
        sha := n.getSha()
        if sha == selfSha </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if _, ok := u.db.FindByNodeID(n.ID); !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">idStr := n.ID.ToHex()
        var count = 0
        value, ok := u.timeoutNodesCount.Get(idStr)
        if ok </span><span class="cov0" title="0">{
                count = value.(int)
        }</span>

        <span class="cov0" title="0">count++
        if count == timeoutCountForDeleteNode </span><span class="cov0" title="0">{
                u.table.deleteNode(n)
                u.db.delete(sha)

                u.log.Info("after delete node %s, total nodes:%d", n, u.db.size())
                u.timeoutNodesCount.Remove(idStr)
        }</span><span class="cov0" title="0"> else {
                u.log.Info("node %s got time out, current timeout count %d", n, count)
                u.timeoutNodesCount.Set(idStr, count)
        }</span>
}

func (u *udp) loadNodes(nodeDir string) <span class="cov8" title="1">{
        fileFullPath := filepath.Join(nodeDir, NodesBackupFileName)

        if !common.FileOrFolderExists(fileFullPath) </span><span class="cov0" title="0">{
                u.log.Debug("nodes info backup file isn't exists in the path:%s", fileFullPath)
                return
        }</span>

        <span class="cov8" title="1">data, err := ioutil.ReadFile(fileFullPath)
        if err != nil </span><span class="cov0" title="0">{
                u.log.Error("read nodes info backup file failed for:[%s]", err)
                return
        }</span>

        <span class="cov8" title="1">var nodes []string
        err = json.Unmarshal(data, &amp;nodes)
        if err != nil </span><span class="cov0" title="0">{
                u.log.Error("nodes unmarshal failed for:[%s]", err)
                return
        }</span>

        <span class="cov8" title="1">for i := range nodes </span><span class="cov8" title="1">{
                n, err := NewNodeFromString(nodes[i])
                if err != nil </span><span class="cov0" title="0">{
                        u.log.Error("new node from string failed for:[%s]", err)
                        continue</span>
                }
                <span class="cov8" title="1">u.bootstrapNodes = append(u.bootstrapNodes, n)</span>
        }

        <span class="cov8" title="1">u.log.Debug("load %d nodes from back file", len(u.bootstrapNodes))</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package p2p

import (
        "time"

        "github.com/seeleteam/go-seele/common"
)

const (
        ctlMsgProtoHandshake uint16 = 10
        ctlMsgDiscCode       uint16 = 4
        ctlMsgPingCode       uint16 = 3
        ctlMsgPongCode       uint16 = 4
)

// Message exposed for high level layer to receive
type Message struct {
        Code       uint16 // message code, defined in each protocol
        Payload    []byte
        ReceivedAt time.Time
}

func SendMessage(write MsgWriter, code uint16, payload []byte) error <span class="cov0" title="0">{
        msg := Message{
                Code:    code,
                Payload: payload,
        }

        return write.WriteMsg(msg)
}</span>

// ProtoHandShake handshake message for two peer to exchage base information
// TODO add public key or other information for encryption?
type ProtoHandShake struct {
        Caps      []Cap
        NodeID    common.Address
        Params    []byte
        NetworkID uint64
}

type MsgReader interface {
        // ReadMsg read a message. It will block until send the message out or get errors
        ReadMsg() (Message, error)
}

type MsgWriter interface {
        // WriteMsg sends a message. It will block until the message's
        // Payload has been consumed by the other end.
        //
        // Note that messages can be sent only once because their
        // payload reader is drained.
        WriteMsg(Message) error
}

// MsgReadWriter provides reading and writing of encoded messages.
// Implementations should ensure that ReadMsg and WriteMsg can be
// called simultaneously from multiple goroutines.
type MsgReadWriter interface {
        MsgReader
        MsgWriter
}
</pre>
		
		<pre class="file" id="file83" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package p2p

import (
        "errors"
        "fmt"
        "net"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/p2p/discovery"
)

const (
        pingInterval   = 15 * time.Second                 // ping interval for peer tcp connection. Should be 15
        discServerQuit = "disconnect because server quit" // p2p.server need quit, all peers should quit as it can
)

// Peer represents a connected remote node.
type Peer struct {
        protocolErr   chan error
        closed        chan struct{}
        Node          *discovery.Node // remote peer that this peer connects
        disconnection chan string
        protocolMap   map[string]protocolRW // protocol cap =&gt; protocol read write wrapper
        rw            *connection

        wg   sync.WaitGroup
        log  *log.SeeleLog
        lock sync.Mutex
}

func NewPeer(conn *connection, protocols []Protocol, log *log.SeeleLog, node *discovery.Node) *Peer <span class="cov8" title="1">{
        closed := make(chan struct{})
        offset := baseProtoCode
        protoMap := make(map[string]protocolRW)
        for _, p := range protocols </span><span class="cov0" title="0">{
                protoRW := protocolRW{
                        rw:       conn,
                        offset:   offset,
                        Protocol: p,
                        in:       make(chan Message, 1),
                        close:    closed,
                }

                protoMap[p.cap().String()] = protoRW
                offset += p.Length
                log.Debug("NewPeer called, add protocol: %s", p.cap())
        }</span>

        <span class="cov8" title="1">return &amp;Peer{
                rw:            conn,
                protocolMap:   protoMap,
                disconnection: make(chan string),
                closed:        closed,
                log:           log,
                protocolErr:   make(chan error),
                Node:          node,
                lock:          sync.Mutex{},
        }</span>
}

func (p *Peer) getShardNumber() uint <span class="cov8" title="1">{
        return p.Node.Shard
}</span>

// run assumes that SubProtocol will never quit, otherwise proto.DelPeerCh may be closed before peer.run quits?
func (p *Peer) run() (err error) <span class="cov0" title="0">{
        var readErr = make(chan error, 1)
        p.wg.Add(2)
        go p.readLoop(readErr)
        go p.pingLoop()

        // Wait for an error or disconnect.
errLoop:
        for </span><span class="cov0" title="0">{
                select </span>{
                case err = &lt;-readErr:<span class="cov0" title="0">
                        p.log.Warn("p2p.peer.run read err %s", err)
                        break errLoop</span>
                case reason := &lt;-p.disconnection:<span class="cov0" title="0">
                        p.log.Info("p2p peer got disconnection request")
                        err = fmt.Errorf("disconnection error received, %s", reason)
                        break errLoop</span>
                case err = &lt;-p.protocolErr:<span class="cov0" title="0">
                        p.log.Warn("p2p peer got protocol err %s", err.Error())
                        break errLoop</span>
                }
        }

        <span class="cov0" title="0">p.close()
        p.wg.Wait()
        p.log.Info("p2p.peer.run quit. err=%s", err)

        return err</span>
}

func (p *Peer) close() <span class="cov0" title="0">{
        p.lock.Lock()
        defer p.lock.Unlock()

        close(p.closed)
        close(p.disconnection)
        p.disconnection = nil
        p.rw.fd.Close()
}</span>

func (p *Peer) pingLoop() <span class="cov0" title="0">{
        ping := time.NewTimer(pingInterval)
        defer p.log.Debug("exit ping loop.")
        defer p.wg.Done()
        defer ping.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ping.C:<span class="cov0" title="0">
                        p.sendCtlMsg(ctlMsgPingCode)
                        ping.Reset(pingInterval)</span>
                case &lt;-p.closed:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (p *Peer) readLoop(readErr chan&lt;- error) <span class="cov0" title="0">{
        defer p.log.Debug("exit read loop")
        defer p.wg.Done()
        for </span><span class="cov0" title="0">{
                msgRecv, err := p.rw.ReadMsg()
                if err != nil </span><span class="cov0" title="0">{
                        readErr &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">if err = p.handle(msgRecv); err != nil </span><span class="cov0" title="0">{
                        readErr &lt;- err
                        return
                }</span>
        }
}

func (p *Peer) notifyProtocolsAddPeer() <span class="cov0" title="0">{
        p.wg.Add(len(p.protocolMap))
        p.log.Info("notifyProtocolsAddPeer called, len(protocolMap)=%d, %s -&gt; %s",
                len(p.protocolMap), p.LocalAddr(), p.RemoteAddr())
        for _, proto := range p.protocolMap </span><span class="cov0" title="0">{
                go func(proto protocolRW) </span><span class="cov0" title="0">{
                        defer p.wg.Done()

                        if proto.AddPeer != nil </span><span class="cov0" title="0">{
                                p.log.Debug("protocol.AddPeer called. protocol:%s", proto.cap())
                                proto.AddPeer(p, &amp;proto)
                        }</span>
                }(proto)
        }
}

func (p *Peer) notifyProtocolsDeletePeer() <span class="cov0" title="0">{
        p.wg.Add(len(p.protocolMap))
        p.log.Debug("notifyProtocolsDeletePeer called, len(protocolMap)=%d", len(p.protocolMap))
        for _, proto := range p.protocolMap </span><span class="cov0" title="0">{
                go func(proto protocolRW) </span><span class="cov0" title="0">{
                        defer p.wg.Done()

                        if proto.DeletePeer != nil </span><span class="cov0" title="0">{
                                p.log.Debug("protocol.DeletePeer called. protocol:%s", proto.cap())
                                proto.DeletePeer(p)
                        }</span>
                }(proto)
        }
}

func (p *Peer) handle(msgRecv Message) error <span class="cov0" title="0">{
        // control msg
        if msgRecv.Code &lt; baseProtoCode </span><span class="cov0" title="0">{
                switch </span>{
                case msgRecv.Code == ctlMsgPingCode:<span class="cov0" title="0">
                        go p.sendCtlMsg(ctlMsgPongCode)</span>
                case msgRecv.Code == ctlMsgPongCode:<span class="cov0" title="0">
                        //p.log.Debug("peer handle Ping msg.")
                        return nil</span>
                case msgRecv.Code == ctlMsgDiscCode:<span class="cov0" title="0">
                        return fmt.Errorf("error=%d", ctlMsgDiscCode)</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">var protocolTarget protocolRW
        found := false
        for _, p := range p.protocolMap </span><span class="cov0" title="0">{
                if msgRecv.Code &gt;= p.offset &amp;&amp; msgRecv.Code &lt; p.offset+p.Length </span><span class="cov0" title="0">{
                        protocolTarget = p
                        found = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return fmt.Errorf(fmt.Sprintf("could not found mapping proto with code %d", msgRecv.Code))
        }</span>

        <span class="cov0" title="0">protocolTarget.in &lt;- msgRecv

        return nil</span>
}

func (p *Peer) sendCtlMsg(msgCode uint16) error <span class="cov0" title="0">{
        hsMsg := Message{
                Code: msgCode,
        }

        p.rw.WriteMsg(hsMsg)

        return nil
}</span>

// Disconnect terminates the peer connection with the given reason.
// It returns immediately and does not wait until the connection is closed.
func (p *Peer) Disconnect(reason string) <span class="cov0" title="0">{
        p.lock.Lock()
        defer p.lock.Unlock()

        if p.disconnection != nil </span><span class="cov0" title="0">{
                p.disconnection &lt;- reason
        }</span>
}

type protocolRW struct {
        Protocol
        offset uint16
        in     chan Message // read message channel, message will be transferred here when it is a protocol message
        rw     MsgReadWriter
        close  chan struct{}
}

func (rw *protocolRW) WriteMsg(msg Message) (err error) <span class="cov0" title="0">{
        if msg.Code &gt;= rw.Length </span><span class="cov0" title="0">{
                return errors.New("invalid msg code")
        }</span>

        <span class="cov0" title="0">msg.Code += rw.offset

        return rw.rw.WriteMsg(msg)</span>
}

func (rw *protocolRW) ReadMsg() (Message, error) <span class="cov0" title="0">{
        select </span>{
        case msg := &lt;-rw.in:<span class="cov0" title="0">
                msg.Code -= rw.offset

                return msg, nil</span>
        case &lt;-rw.close:<span class="cov0" title="0">
                return Message{}, errors.New("peer connection closed")</span>
        }
}

// ProtocolMap returns cap =&gt; protocol read write wrapper
func (p *Peer) ProtocolMap() map[string]protocolRW <span class="cov8" title="1">{
        return p.protocolMap
}</span>

// RemoteAddr returns the remote address of the network connection.
func (p *Peer) RemoteAddr() net.Addr <span class="cov8" title="1">{
        return p.rw.fd.RemoteAddr()
}</span>

// LocalAddr returns the local address of the network connection.
func (p *Peer) LocalAddr() net.Addr <span class="cov8" title="1">{
        return p.rw.fd.LocalAddr()
}</span>

// PeerInfo represents a short summary of a connected peer
type PeerInfo struct {
        ID      string   `json:"id"`   // Unique of the node
        Caps    []string `json:"caps"` // Sum-protocols advertised by this particular peer
        Network struct {
                LocalAddress  string `json:"localAddress"`  // Local endpoint of the TCP data connection
                RemoteAddress string `json:"remoteAddress"` // Remote endpoint of the TCP data connection
        } `json:"network"`
        Protocols map[string]interface{} `json:"protocols"` // Sub-protocol specific metadata fields
        Shard     uint                   `json:"shard"`     // shard id of the node
}

// Info returns data of the peer but not contain id and name.
func (p *Peer) Info() *PeerInfo <span class="cov8" title="1">{
        var caps []string
        protocols := make(map[string]interface{})

        for cap, protocol := range p.ProtocolMap() </span><span class="cov0" title="0">{
                caps = append(caps, cap)

                protoInfo := interface{}("unknown")
                if query := protocol.Protocol.GetPeer; query != nil </span><span class="cov0" title="0">{
                        if metadata := query(p.Node.ID); metadata != nil </span><span class="cov0" title="0">{
                                protoInfo = metadata
                        }</span><span class="cov0" title="0"> else {
                                protoInfo = "handshake"
                        }</span>
                }
                <span class="cov0" title="0">protocols[protocol.Protocol.Name] = protoInfo</span>
        }

        <span class="cov8" title="1">info := &amp;PeerInfo{
                ID:        p.Node.ID.ToHex(),
                Caps:      caps,
                Protocols: protocols,
                Shard:     p.getShardNumber(),
        }
        info.Network.LocalAddress = p.LocalAddr().String()
        info.Network.RemoteAddress = p.RemoteAddr().String()

        return info</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package p2p

import (
        "sync"

        "github.com/seeleteam/go-seele/common"
)

// peerSet is thread safe collection
type peerSet struct {
        peerMap      map[common.Address]*Peer
        shardPeerMap map[uint]map[common.Address]*Peer
        lock         sync.RWMutex
}

func NewPeerSet() *peerSet <span class="cov8" title="1">{
        peers := make(map[uint]map[common.Address]*Peer)
        for i := 1; i &lt; common.ShardCount+1; i++ </span><span class="cov8" title="1">{
                peers[uint(i)] = make(map[common.Address]*Peer)
        }</span>

        <span class="cov8" title="1">return &amp;peerSet{
                peerMap:      make(map[common.Address]*Peer),
                shardPeerMap: peers,
                lock:         sync.RWMutex{},
        }</span>
}

func (set *peerSet) add(p *Peer) <span class="cov8" title="1">{
        set.lock.Lock()
        defer set.lock.Unlock()

        set.shardPeerMap[p.getShardNumber()][p.Node.ID] = p
        set.peerMap[p.Node.ID] = p
}</span>

func (set *peerSet) count() int <span class="cov8" title="1">{
        set.lock.RLock()
        defer set.lock.RUnlock()

        return len(set.peerMap)
}</span>

func (set *peerSet) find(addr common.Address) *Peer <span class="cov8" title="1">{
        set.lock.RLock()
        defer set.lock.RUnlock()

        return set.peerMap[addr]
}</span>

func (set *peerSet) delete(p *Peer) <span class="cov8" title="1">{
        set.lock.Lock()
        defer set.lock.Unlock()

        delete(set.peerMap, p.Node.ID)
        delete(set.shardPeerMap[p.getShardNumber()], p.Node.ID)
}</span>

func (set *peerSet) foreach(call func(p *Peer)) <span class="cov0" title="0">{
        set.lock.RLock()
        defer set.lock.RUnlock()

        for _, p := range set.peerMap </span><span class="cov0" title="0">{
                call(p)
        }</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package p2p

import (
        "fmt"

        "github.com/seeleteam/go-seele/common"
)

const (
        baseProtoCode uint16 = 16 //start protoCode used by higher level
        ctlProtoCode  uint16 = 1  //control protoCode. For example, handshake ping pong message etc
)

//Protocol base class for high level transfer protocol.
type Protocol struct {
        // Name should contain the official protocol name,
        // often a three-letter word.
        Name string

        // Version should contain the version number of the protocol.
        Version uint

        // Length should contain the number of message codes used by the protocol.
        Length uint16

        // AddPeer find a new peer will call this method
        AddPeer func(peer *Peer, rw MsgReadWriter)

        // DeletePeer this method will be called when a peer is disconnected
        DeletePeer func(peer *Peer)

        // GetPeer this method will be called for get peer information
        GetPeer func(address common.Address) interface{}
}

func (p *Protocol) cap() Cap <span class="cov0" title="0">{
        return Cap{p.Name, p.Version}
}</span>

// Cap is the structure of a peer capability.
type Cap struct {
        Name    string
        Version uint
}

func (cap Cap) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%d", cap.Name, cap.Version)
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package qvic

//FECHelper helper class for FEC
type FECHelper struct {
        canVec         []*VBitVec //candidate vector
        bitLen, fecLen uint
}

//createAndInsertByPattern create VBitVec by pattern, and append to canVec
func (h *FECHelper) createAndInsertByPattern(ch byte, len uint, extFlag byte) <span class="cov8" title="1">{
        p := new(VBitVec)
        p.Init(h.bitLen)
        p.InitPattern(ch, len)
        p.ExtFlag = extFlag
        h.canVec = append(h.canVec, p)
}</span>

//createOne create one VBitVec, and append to canVec
func (h *FECHelper) createOne(arr []int, arrLen int) <span class="cov8" title="1">{
        var flag byte
        for _, v := range arr </span><span class="cov8" title="1">{
                flag = flag | (1 &lt;&lt; (7 - uint(v)))
        }</span>

        <span class="cov8" title="1">p := new(VBitVec)
        p.Init(h.bitLen)
        p.BitXor(h.canVec[arr[0]], h.canVec[arr[1]])
        for idx := 2; idx &lt; arrLen; idx++ </span><span class="cov8" title="1">{
                p.BitXor1(h.canVec[arr[idx]])
        }</span>

        <span class="cov8" title="1">p.ExtFlag = flag
        h.canVec = append(h.canVec, p)</span>
}

//selectNum create all VBitVec
func (h *FECHelper) selectNum(pre []int, preLen int, arr []int, arrLen int, cnt int) <span class="cov8" title="1">{
        if arrLen == cnt </span><span class="cov8" title="1">{
                h.createOne(append(pre, arr...), preLen+arrLen)
                return
        }</span>

        <span class="cov8" title="1">if cnt == 1 </span><span class="cov8" title="1">{
                for _, v := range arr </span><span class="cov8" title="1">{
                        h.createOne(append(pre, v), preLen+1)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">newPreLen, newCnt := preLen+1, cnt-1
        for idx, v := range arr </span><span class="cov8" title="1">{
                pre1 := make([]int, preLen)
                copy(pre1, pre)
                newPre := append(pre1, v)

                arr1 := make([]int, arrLen)
                copy(arr1, arr)
                newArr := append([]int{}, arr1[idx+1:]...)
                newArrLen := arrLen - idx - 1
                h.selectNum(newPre, newPreLen, newArr, newArrLen, newCnt)
        }</span>
}

//Init initialize helper.
func (h *FECHelper) Init(_bitLen uint) bool <span class="cov8" title="1">{
        if _bitLen%8 != 0 </span><span class="cov0" title="0">{
                panic("invalid paras, panic...")</span>
        }
        <span class="cov8" title="1">h.canVec = make([]*VBitVec, 0, 255)
        h.bitLen, h.fecLen = _bitLen, 8

        h.createAndInsertByPattern(0x80, 1, 0x80)
        h.createAndInsertByPattern(0x80, 2, 0x40)
        h.createAndInsertByPattern(0x80, 3, 0x20)
        h.createAndInsertByPattern(0x40, 3, 0x10)
        h.createAndInsertByPattern(0xdb, 7, 0x08)
        h.createAndInsertByPattern(0xba, 7, 0x04)
        h.createAndInsertByPattern(0x6e, 7, 0x02)
        h.createAndInsertByPattern(0xcd, 7, 0x01)
        h.canVec[0].SetBit(14, false)
        h.canVec[0].SetBit(12, false)

        org := []int{0, 1, 2, 3, 4, 5, 6, 7}
        pre := []int{}
        for i := 2; i &lt;= 8; i++ </span><span class="cov8" title="1">{
                h.selectNum(pre, 0, org, 8, i)
        }</span>
        <span class="cov8" title="1">return true</span>
}

//GetRecoverInfo get VBitVec that can recover
func (h *FECHelper) GetRecoverInfo(pS *VBitVec) *VBitVec <span class="cov8" title="1">{
        if pS.ExtFlag == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var pCur *VBitVec
        var curBits uint
        for _, p := range h.canVec </span><span class="cov8" title="1">{
                if p.ExtFlag|pS.ExtFlag != pS.ExtFlag </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if p.has1fecBit(pS) </span><span class="cov8" title="1">{
                        if pCur == nil </span><span class="cov8" title="1">{
                                pCur, curBits = p, p.getBitsCnt(pS.BitLen)
                                continue</span>
                        }
                        <span class="cov8" title="1">cnt := p.getBitsCnt(pS.BitLen)
                        if cnt &lt; curBits </span><span class="cov8" title="1">{
                                pCur = p
                                curBits = cnt
                        }</span>
                }
        }
        <span class="cov8" title="1">return pCur</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package qvic

import (
        "net"
        "sync"
        "time"
)

// QConn represents a qvic connection, implements net.Conn interface.
type QConn struct {
        lock sync.Mutex // protects running
        quit chan struct{}
}

func (qc *QConn) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        return 0, nil
}</span>

func (qc *QConn) Write(b []byte) (n int, err error) <span class="cov0" title="0">{
        return 0, nil
}</span>

func (qc *QConn) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// LocalAddr returns the local network address.
func (qc *QConn) LocalAddr() net.Addr <span class="cov0" title="0">{
        return nil
}</span>

// RemoteAddr returns the remote network address.
func (qc *QConn) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return nil
}</span>

func (qc *QConn) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

func (qc *QConn) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

func (qc *QConn) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package qvic

import (
        "errors"
        "net"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/log"
)

var (
        errAlreadyInited   = errors.New("QvicMgr already initialized")
        errInvalidProtocol = errors.New("Invalid connection prototol, must be tcp or qvic")
        errQVICMgrFinished = errors.New("QVIC module has finished")
        errUnknownError    = errors.New("Unknown error")
)

// QvicMgr manages qvic module.
type QvicMgr struct {
        lock         sync.Mutex
        quit         chan struct{}
        acceptChan   chan *acceptInfo
        udpfd        *net.UDPConn
        tcpListenner net.Listener

        loopWG sync.WaitGroup
        log    *log.SeeleLog
}

// acceptInfo represents acceptance information for both tcp and qvic.
type acceptInfo struct {
        conn net.Conn
        err  error
}

// NewQvicMgr creates QvicMgr object.
func NewQvicMgr() *QvicMgr <span class="cov8" title="1">{
        q := &amp;QvicMgr{
                quit:       make(chan struct{}),
                acceptChan: make(chan *acceptInfo),
                log:        log.GetLogger("qvic", common.LogConfig.PrintLog),
        }
        q.log.Info("QVIC module started!")
        return q
}</span>

// DialTimeout connects to the address on the named network with a timeout config.
// network parameters must be "tcp" or "qvic" for tcp connection and qvic connection respectively.
func (mgr *QvicMgr) DialTimeout(network, addr string, timeout time.Duration) (net.Conn, error) <span class="cov0" title="0">{
        if network == "tcp" </span><span class="cov0" title="0">{
                conn, err := net.DialTimeout("tcp", addr, timeout)
                if err != nil </span><span class="cov0" title="0">{
                        mgr.log.Error("qvic failed to connect: %s", err)
                        if conn != nil </span><span class="cov0" title="0">{
                                conn.Close()
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">mgr.log.Debug("qvic DialTimeout OK! network=%s addr=%s", network, addr)
                return conn, nil</span>
        }

        <span class="cov0" title="0">if network == "qvic" </span>{<span class="cov0" title="0">
                //TODO qvic dial support
        }</span>

        <span class="cov0" title="0">return nil, errInvalidProtocol</span>
}

type tempError interface {
        Temporary() bool
}

// Listen binds ports and starts listenning for both tcp and qvic.
func (mgr *QvicMgr) Listen(tcpAddress string, qvicAddress string) (err error) <span class="cov8" title="1">{
        if mgr.tcpListenner != nil || mgr.udpfd != nil </span><span class="cov0" title="0">{
                return errAlreadyInited
        }</span>

        <span class="cov8" title="1">if len(tcpAddress) != 0 </span><span class="cov8" title="1">{
                mgr.tcpListenner, err = net.Listen("tcp", tcpAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        mgr.loopWG.Add(1)
                        defer mgr.loopWG.Done()
                        for </span><span class="cov8" title="1">{
                                fd, errConn := mgr.tcpListenner.Accept()
                                if tempErr, ok := errConn.(tempError); ok &amp;&amp; tempErr.Temporary() </span><span class="cov0" title="0">{
                                        continue</span>
                                }<span class="cov8" title="1"> else if errConn != nil </span><span class="cov8" title="1">{
                                        mgr.log.Error("qvic. tcp accept err. %s", errConn)
                                        break</span>
                                }
                                <span class="cov8" title="1">mgr.acceptChan &lt;- &amp;acceptInfo{fd, errConn}</span>
                        }
                        <span class="cov8" title="1">mgr.log.Info("tcp loop accept quit")</span>
                }()
        }

        <span class="cov8" title="1">if len(qvicAddress) != 0 </span><span class="cov8" title="1">{
                addr, _ := net.ResolveUDPAddr("udp", qvicAddress)
                mgr.udpfd, err = net.ListenUDP("udp", addr)
                if err != nil </span><span class="cov0" title="0">{
                        mgr.log.Error("qvic. qvic-protocol udp listen err. %s", err)
                        return err
                }</span>
                <span class="cov8" title="1">go mgr.qvicRun()</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (mgr *QvicMgr) qvicRun() <span class="cov8" title="1">{
        mgr.loopWG.Add(1)
        defer mgr.loopWG.Done()
        mgr.log.Info("qvic qvicRun start")

needQuit:
        for </span><span class="cov8" title="1">{
                data := make([]byte, 2048)
                n, remoteAddr, err := mgr.udpfd.ReadFromUDP(data)
                if err != nil </span><span class="cov8" title="1">{
                        mgr.log.Warn("qvicRun read udp failed. %s", err)
                        select </span>{
                        case &lt;-mgr.quit:<span class="cov8" title="1">
                                break needQuit</span>
                        default:</span><span class="cov0" title="0">
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">data = data[:n]
                mgr.handleMsg(remoteAddr, data)</span>
        }
        <span class="cov8" title="1">mgr.log.Info("qvic qvicRun out")</span>
}

func (mgr *QvicMgr) handleMsg(from *net.UDPAddr, data []byte) {<span class="cov0" title="0">
        //TODO handle udp message

}</span>

// Accept gets connection from qvic module if exists.
func (mgr *QvicMgr) Accept() (net.Conn, error) <span class="cov8" title="1">{
        mgr.log.Info("accept start")
        mgr.loopWG.Add(1)
        defer mgr.loopWG.Done()
        select </span>{
        case &lt;-mgr.quit:<span class="cov0" title="0">
                mgr.log.Info("qvic Accept, but received quit message")
                return nil, errQVICMgrFinished</span>
        case acc := &lt;-mgr.acceptChan:<span class="cov8" title="1">
                if acc.err == nil </span><span class="cov8" title="1">{
                        mgr.log.Info("qvic Accepted OK")
                }</span><span class="cov0" title="0"> else {
                        mgr.log.Info("qvic Accepted, err=%s", acc.err)
                }</span>
                <span class="cov8" title="1">return acc.conn, acc.err</span>
        }
}

// Close clean for QvicMgr object.
func (mgr *QvicMgr) Close() <span class="cov8" title="1">{
        mgr.log.Info("qvic Close called")
        close(mgr.quit)
        if mgr.tcpListenner != nil </span><span class="cov8" title="1">{
                mgr.tcpListenner.Close()
        }</span>
        <span class="cov8" title="1">if mgr.udpfd != nil </span><span class="cov8" title="1">{
                mgr.udpfd.Close()
        }</span>
        <span class="cov8" title="1">mgr.loopWG.Wait()
        close(mgr.acceptChan)</span>

        // TODO close all qvic connections
}
</pre>
		
		<pre class="file" id="file89" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package qvic

import (
        "sync"

        "github.com/aristanetworks/goarista/monotime"
)

const (
        // MilliInSec milliseconds in one second
        MilliInSec uint64 = 1000
)

// speedMeterSubItem records amount in a step
type speedMeterSubItem struct {
        tick   uint64
        amount uint
}

// SpeedMeter computes bandwidth
type SpeedMeter struct {
        itemArr     []speedMeterSubItem
        preFeedTick uint64 // last feed tick
        step        uint64 //
        itemsNum    uint   // step num in a period
        mutex       sync.Mutex
}

// NewSpeedMeter creates SpeedMeter.
// step should be ms. for example: step=100 items=10; step=50 items=20.
// step * items = a period.
func NewSpeedMeter(step uint64, items uint) (s *SpeedMeter) <span class="cov8" title="1">{
        s = new(SpeedMeter)
        s.step, s.itemsNum = step, items
        s.itemArr = make([]speedMeterSubItem, items)
        return s
}</span>

// Feed called when bytes received from network
func (s *SpeedMeter) Feed(num uint) <span class="cov8" title="1">{
        cur := monotime.Now() / MilliInSec
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.paveToTick(cur)
        curIdx := uint((cur / s.step)) % s.itemsNum
        s.itemArr[curIdx].amount += num
        s.preFeedTick = cur - cur%s.step
}</span>

// GetRate gets rate
func (s *SpeedMeter) GetRate() uint <span class="cov8" title="1">{
        cur := monotime.Now() / MilliInSec
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.paveToTick(cur)
        curIdx := uint((cur / s.step)) % s.itemsNum
        curAmount := s.itemArr[curIdx].amount

        var firstAmount uint
        if curIdx == (s.itemsNum - 1) </span><span class="cov0" title="0">{
                firstAmount = s.itemArr[0].amount
        }</span><span class="cov8" title="1"> else {
                firstAmount = s.itemArr[curIdx+1].amount
        }</span>

        <span class="cov8" title="1">return curAmount - firstAmount</span>
}

// paveToTick cur's milliseconds
func (s *SpeedMeter) paveToTick(cur uint64) <span class="cov8" title="1">{
        preIdx := uint((s.preFeedTick / s.step)) % s.itemsNum
        preAmount := s.itemArr[preIdx].amount
        cur = cur - cur%s.step
        for i := uint(0); i &lt; s.itemsNum; i++ </span><span class="cov8" title="1">{
                tick := cur - uint64(i)*s.step
                if tick == s.preFeedTick </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">idx := uint((tick / s.step)) % s.itemsNum
                s.itemArr[idx].tick, s.itemArr[idx].amount = tick, preAmount</span>
        }
}
</pre>
		
		<pre class="file" id="file90" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package qvic

import (
        "sync"

        "github.com/aristanetworks/goarista/monotime"
)

// TokenBucket for bucket limit rate
type TokenBucket struct {
        bytesPerSecond int64 // bandwidth
        maxTokens      int64 // size of bucket
        curTokens      int64
        tokensPerMS    int64  // tokens produced every milliseconds
        reservedTokens int64  // reserved tokens
        preTick        uint64 // last tick producing tokens
        mutex          sync.Mutex
}

// Init initializes TokenBucket with bytesPerSecond and factor
func (t *TokenBucket) Init(bytesPerSecond int64) <span class="cov8" title="1">{
        t.initCommon(bytesPerSecond)
        t.curTokens = t.maxTokens
        t.preTick = monotime.Now() / 1000
}</span>

// AdjustBW adjusts bandwidth anytime
func (t *TokenBucket) AdjustBW(bytesPerSecond int64) <span class="cov8" title="1">{
        t.initCommon(bytesPerSecond)
        if t.curTokens &gt; t.maxTokens </span><span class="cov0" title="0">{
                t.curTokens = t.maxTokens
        }</span>
}

// PeriodicFeed called periodically, for example 30ms
func (t *TokenBucket) PeriodicFeed() <span class="cov8" title="1">{
        t.mutex.Lock()
        defer t.mutex.Unlock()

        cur := monotime.Now() / 1000
        i := t.curTokens + int64(cur-t.preTick)*t.tokensPerMS
        if i &gt; t.maxTokens </span><span class="cov8" title="1">{
                t.curTokens = t.maxTokens
        }</span><span class="cov0" title="0"> else {
                t.curTokens = i
        }</span>
        <span class="cov8" title="1">t.preTick = cur</span>
}

// GetCurTokens gets valid tokens
func (t *TokenBucket) GetCurTokens() int64 <span class="cov0" title="0">{
        return t.curTokens
}</span>

// GetCurLooseTokens gets valid tokens, minus reserved
func (t *TokenBucket) GetCurLooseTokens() int64 <span class="cov0" title="0">{
        return t.curTokens - t.reservedTokens
}</span>

// Consume consumes some buckets
func (t *TokenBucket) Consume(tokens int64) <span class="cov8" title="1">{
        t.mutex.Lock()
        defer t.mutex.Unlock()
        t.curTokens -= tokens
}</span>

func (t *TokenBucket) initCommon(bytesPerSecond int64) <span class="cov8" title="1">{
        t.bytesPerSecond = bytesPerSecond
        t.maxTokens = bytesPerSecond
        t.tokensPerMS = bytesPerSecond / 1000
        t.reservedTokens = bytesPerSecond / 10
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package qvic

import (
        "fmt"
)

const (
        // MaxBitLength Max bit length
        MaxBitLength uint = 8

        // MaxBitIndex Max bit index size
        MaxBitIndex uint = 7

        // ShiftOffset Left/Right shift size
        ShiftOffset uint = 3
)

// VBitVec bitmap friendly for FEC helper
type VBitVec struct {
        BitLen  uint
        bufLen  uint
        pBuf    []byte
        ExtFlag byte // flag for extra package
}

// Init initializes VBitVec with bitLen
func (v *VBitVec) Init(_bitLen uint) bool <span class="cov8" title="1">{
        if v.BitLen != 0 </span><span class="cov0" title="0">{
                panic("VBitVec.Init pacnic")</span>
        }

        <span class="cov8" title="1">v.BitLen, v.bufLen, v.ExtFlag = _bitLen, _bitLen&gt;&gt;ShiftOffset, 0
        if _bitLen&amp;MaxBitIndex != 0 </span><span class="cov0" title="0">{
                v.bufLen++
        }</span>

        <span class="cov8" title="1">v.pBuf = make([]byte, v.bufLen)
        return true</span>
}

// Attatch initializes bitmap with memory block
func (v *VBitVec) Attatch(p []byte, _bitLen uint, flag byte) <span class="cov8" title="1">{
        v.BitLen, v.bufLen, v.ExtFlag = _bitLen, _bitLen&gt;&gt;ShiftOffset, flag
        if _bitLen&amp;MaxBitIndex != 0 </span><span class="cov8" title="1">{
                v.bufLen++
        }</span>

        <span class="cov8" title="1">v.pBuf = p</span>
}

// Detach clears VBitVec
func (v *VBitVec) Detach() <span class="cov8" title="1">{
        v.BitLen, v.bufLen, v.ExtFlag = 0, 0, 0
        v.pBuf = nil
}</span>

// SetBit sets value by bit index
func (v *VBitVec) SetBit(idx uint, val bool) <span class="cov8" title="1">{
        indx, bitIndx := idx&gt;&gt;ShiftOffset, idx&amp;MaxBitIndex
        if val </span><span class="cov8" title="1">{
                v.pBuf[indx] |= 1 &lt;&lt; (MaxBitIndex - bitIndx)
        }</span><span class="cov8" title="1"> else {
                v.pBuf[indx] &amp;^= 1 &lt;&lt; (MaxBitIndex - bitIndx)
        }</span>
}

// GetBit gets bit in pos
func (v *VBitVec) GetBit(idx uint) bool <span class="cov8" title="1">{
        indx, bitIndx := idx&gt;&gt;ShiftOffset, idx&amp;MaxBitIndex
        return ((v.pBuf[indx] &gt;&gt; (MaxBitIndex - bitIndx)) &amp; 1) != 0
}</span>

// GetFlagBit gets bit in pos of extflag
func (v *VBitVec) GetFlagBit(idx uint) bool <span class="cov8" title="1">{
        if idx &gt; MaxBitLength </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return ((v.ExtFlag &gt;&gt; (MaxBitIndex - idx)) &amp; 1) != 0</span>
}

// InitPattern initializes bitmap with pattern
func (v *VBitVec) InitPattern(flag byte, len uint) <span class="cov8" title="1">{
        for idx := uint(0); idx &lt; v.BitLen; idx++ </span><span class="cov8" title="1">{
                flagIdx := idx % len
                if flag&amp;(1&lt;&lt;(MaxBitIndex-flagIdx)) != 0 </span><span class="cov8" title="1">{
                        v.SetBit(idx, true)
                }</span><span class="cov8" title="1"> else {
                        v.SetBit(idx, false)
                }</span>
        }
}

// BitXor initializes bitmap with c1 ^ c2
func (v *VBitVec) BitXor(c1 *VBitVec, c2 *VBitVec) <span class="cov8" title="1">{
        if (v.BitLen != c1.BitLen) || (c1.BitLen != c2.BitLen) </span><span class="cov0" title="0">{
                panic("Failed to Xor")</span>
        }

        <span class="cov8" title="1">for i := uint(0); i &lt; v.bufLen; i++ </span><span class="cov8" title="1">{
                v.pBuf[i] = (c1.pBuf[i]) ^ (c2.pBuf[i])
        }</span>
}

// BitXor1 calculates the xor value with c1
func (v *VBitVec) BitXor1(c1 *VBitVec) <span class="cov8" title="1">{
        if v.BitLen != c1.BitLen </span><span class="cov0" title="0">{
                panic("cannot xor")</span>
        }

        <span class="cov8" title="1">for i := uint(0); i &lt; v.bufLen; i++ </span><span class="cov8" title="1">{
                v.pBuf[i] = (v.pBuf[i]) ^ (c1.pBuf[i])
        }</span>
}

// has1fecBit checks whether there is only 1 bit set in bitmap
func (v *VBitVec) has1fecBit(s *VBitVec) bool <span class="cov8" title="1">{
        diffCnt := uint(0)
        for i := uint(0); i &lt; v.bufLen; i++ </span><span class="cov8" title="1">{
                ch := (v.pBuf[i]) &amp; (s.pBuf[i])
                ch = ch ^ v.pBuf[i]
                for ; ch &gt; 0; diffCnt++ </span><span class="cov8" title="1">{
                        ch &amp;= (ch - 1)
                }</span>

                <span class="cov8" title="1">if diffCnt &gt;= 2 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return diffCnt == 1</span>
}

// getBitsCnt calculates bit num
func (v *VBitVec) getBitsCnt(len uint) uint <span class="cov8" title="1">{
        indx := len &gt;&gt; ShiftOffset
        trueCnt := uint(0)
        for i := uint(0); i &lt; indx; i++ </span><span class="cov8" title="1">{
                for ch := v.pBuf[i]; ch &gt; 0; trueCnt++ </span><span class="cov8" title="1">{
                        ch &amp;= (ch - 1)
                }</span>
        }

        <span class="cov8" title="1">for i := indx &lt;&lt; ShiftOffset; i &lt; len; i++ </span><span class="cov0" title="0">{
                if v.GetBit(i) </span><span class="cov0" title="0">{
                        trueCnt++
                }</span>
        }

        <span class="cov8" title="1">return trueCnt</span>
}

// GetBitmapString gets bitmap string
func (v *VBitVec) GetBitmapString() (str string) <span class="cov0" title="0">{
        for i := uint(0); i &lt; v.bufLen; i++ </span><span class="cov0" title="0">{
                str = str + fmt.Sprintf("%02X ", v.pBuf[i])
        }</span>

        <span class="cov0" title="0">return str</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">/**
*  Package p2p
*  @copyright defined in go-seele/LICENSE
 */

package qvic

import (
        "encoding/binary"
)

const (
        // VPacketHeadLen head length in net-package
        VPacketHeadLen uint = 13
)

// VPacket package for QVIC
type VPacket struct {
        seq                uint32
        packType           byte
        fecIdx             int
        crc                uint16
        magic              uint16
        lastSeqSendTick    uint16
        createTick         uint16
        data               []byte
        dataLen            uint
        isRecovered        int // 1: ok; 0: others. for client, 1: recved ack; for server, 1: ack sent.
        isSendedToTun      int // only avalible for recovering. 0: no; 1: already write to tun
        isSendedToPeer     bool
        sendTimes          int
        lastSendTickLocal  uint16
        myPos              int
        forVConnDestroyMsg uint32
        dataNet            [1500]byte
}

// MarshalData pack data to dataNet
func (v *VPacket) MarshalData() <span class="cov8" title="1">{
        b := v.dataNet[0:]
        binary.BigEndian.PutUint32(b[:4], v.seq)
        b[4] = (v.packType &lt;&lt; 4) | byte(v.fecIdx)
        binary.BigEndian.PutUint16(b[5:7], v.crc)
        binary.BigEndian.PutUint16(b[7:9], v.magic)
        binary.BigEndian.PutUint16(b[9:11], v.lastSeqSendTick)
        binary.BigEndian.PutUint16(b[11:13], v.createTick)
        copy(b[VPacketHeadLen:], v.data)
}</span>

// ParseData parse data from dataNet. packData contains udp-package recved from net
func (v *VPacket) ParseData(packData []byte) <span class="cov8" title="1">{
        b := v.dataNet[0:]
        copy(b, packData)
        v.seq = binary.BigEndian.Uint32(b[:4])
        v.packType, v.fecIdx = b[4]&gt;&gt;4, int(b[4]&amp;0x0f)
        v.crc = binary.BigEndian.Uint16(b[5:7])
        v.magic = binary.BigEndian.Uint16(b[7:9])
        v.lastSeqSendTick = binary.BigEndian.Uint16(b[9:11])
        v.createTick = binary.BigEndian.Uint16(b[11:13])
        v.dataLen = uint(len(packData)) - VPacketHeadLen
        v.data = make([]byte, v.dataLen)
        copy(v.data, b[VPacketHeadLen:])
}</span>

// FECInfo record packages info of a bundle
type FECInfo struct {
        seq        uint32
        fecPackets [8]*VPacket
        fecFlag    byte
}

// NewFECInfo create new FECInfo class
func NewFECInfo() (f *FECInfo) <span class="cov8" title="1">{
        f = new(FECInfo)
        return f
}</span>

// Clear reset FECInfo
func (v *FECInfo) Clear() <span class="cov0" title="0">{
        if v.fecFlag == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; 8; i++ </span><span class="cov0" title="0">{
                if v.fecPackets[i] != nil </span><span class="cov0" title="0">{
                        v.fecPackets[i] = nil
                }</span>
        }
        <span class="cov0" title="0">v.fecFlag = 0</span>
}

// VPacketItem package info for RecverMgr
type VPacketItem struct {
        pFECInfo      *FECInfo
        p             *VPacket
        fecCreateTick uint16
}
</pre>
		
		<pre class="file" id="file93" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package p2p

import (
        "bytes"
        "crypto/ecdsa"
        "crypto/md5"
        "crypto/rand"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "net"
        "sort"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core"
        "github.com/seeleteam/go-seele/crypto"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/p2p/discovery"
)

const (
        // Maximun number of peers that can be connected
        defaultMaxPeers = 500

        // Maximum number of concurrently handshaking inbound connections.
        maxAcceptConns = 50

        defaultDialTimeout = 15 * time.Second

        // Maximum amount of time allowed for writing some bytes, not a complete message, because the message length is very highly variable.
        connWriteTimeout = 10 * time.Second

        // Maximum time allowed for reading a complete message.
        frameReadTimeout = 30 * time.Second

        inboundConn  = 1
        outboundConn = 2

        // In transfering handshake msg, length of extra data
        extraDataLen = 24
)

//P2PConfig is the Configuration of p2p
type Config struct {
        // p2p.server will listen for incoming tcp connections. And it is for udp address used for Kad protocol
        ListenAddr string `json:"address"`

        // NetworkID used to define net type, for example main net and test net.
        NetworkID uint64 `json:"networkID"`

        // static nodes which will be connected to find more nodes when the node starts
        StaticNodes []*discovery.Node `json:"staticNodes"`

        // SubPrivateKey which will be make PrivateKey
        SubPrivateKey string `json:"privateKey"`

        // PrivateKey private key for p2p module, do not use it as any accounts
        PrivateKey *ecdsa.PrivateKey
}

// Server manages all p2p peer connections.
type Server struct {
        // Config fields may not be modified while the server is running.
        Config

        lock    sync.Mutex // protects running
        running bool

        kadDB    *discovery.Database
        listener net.Listener

        quit chan struct{}

        loopWG sync.WaitGroup // loop, listenLoop

        peerSet  *peerSet
        peerLock sync.Mutex // lock for peer set
        log      *log.SeeleLog

        // MaxPeers max number of peers that can be connected
        MaxPeers int

        // MaxPendingPeers is the maximum number of peers that can be pending in the
        // handshake phase, counted separately for inbound and outbound connections.
        // Zero defaults to preset values.
        MaxPendingPeers int

        // Protocols should contain the protocols supported by the server.
        Protocols []Protocol

        SelfNode *discovery.Node

        genesis core.GenesisInfo
}

// NewServer initialize a server
func NewServer(genesis core.GenesisInfo, config Config, protocols []Protocol) *Server <span class="cov0" title="0">{
        return &amp;Server{
                Config:          config,
                running:         false,
                log:             log.GetLogger("p2p", common.LogConfig.PrintLog),
                MaxPeers:        defaultMaxPeers,
                quit:            make(chan struct{}),
                peerSet:         NewPeerSet(),
                MaxPendingPeers: 0,
                Protocols:       protocols,
                genesis:         genesis,
        }
}</span>

// PeerCount return the count of peers
func (srv *Server) PeerCount() int <span class="cov0" title="0">{
        return srv.peerSet.count()
}</span>

// Start starts running the server.
func (srv *Server) Start(nodeDir string, shard uint) (err error) <span class="cov0" title="0">{
        srv.lock.Lock()
        defer srv.lock.Unlock()
        if srv.running </span><span class="cov0" title="0">{
                return errors.New("server already running")
        }</span>

        <span class="cov0" title="0">srv.running = true
        srv.log.Debug("Starting P2P networking...")
        // self node
        address := crypto.GetAddress(&amp;srv.PrivateKey.PublicKey)
        addr, err := net.ResolveUDPAddr("udp", srv.ListenAddr)

        srv.SelfNode = discovery.NewNodeWithAddr(*address, addr, shard)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">srv.log.Info("p2p.Server.Start: MyNodeID [%s]", srv.SelfNode)
        srv.kadDB = discovery.StartService(nodeDir, *address, addr, srv.StaticNodes, shard)
        srv.kadDB.SetHookForNewNode(srv.addNode)
        srv.kadDB.SetHookForDeleteNode(srv.deleteNode)

        if err := srv.startListening(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">srv.loopWG.Add(1)
        go srv.run()
        srv.running = true
        return nil</span>
}

func (srv *Server) addNode(node *discovery.Node) <span class="cov0" title="0">{
        if node.Shard == discovery.UndefinedShardNumber </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">srv.log.Debug("got discovery a new node event, node info:%s", node)
        if srv.checkPeerExist(node.ID) </span><span class="cov0" title="0">{
                return
        }</span>

        //TODO UDPPort==&gt; TCPPort
        <span class="cov0" title="0">addr, err := net.ResolveTCPAddr("tcp4", fmt.Sprintf("%s:%d", node.IP.String(), node.UDPPort))
        if err != nil </span><span class="cov0" title="0">{
                srv.log.Error("resolve tpc address failed %s", err)
                return
        }</span>

        <span class="cov0" title="0">conn, err := net.DialTimeout("tcp", addr.String(), defaultDialTimeout)
        if err != nil </span><span class="cov0" title="0">{
                srv.log.Error("connect to a new node err: %s, node: %s", err, node)
                if conn != nil </span><span class="cov0" title="0">{
                        conn.Close()
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">srv.log.Info("connect to a node with %s -&gt; %s", conn.LocalAddr(), conn.RemoteAddr())
        if err := srv.setupConn(conn, outboundConn, node); err != nil </span><span class="cov0" title="0">{
                srv.log.Info("add new node failed. err=%s", err)
        }</span>
}

func (srv *Server) deleteNode(node *discovery.Node) <span class="cov0" title="0">{
        srv.deletePeer(node.ID)
}</span>

func (srv *Server) checkPeerExist(id common.Address) bool <span class="cov0" title="0">{
        srv.peerLock.Lock()
        srv.peerLock.Unlock()

        peer := srv.peerSet.find(id)
        return peer != nil
}</span>

func (srv *Server) addPeer(p *Peer) bool <span class="cov0" title="0">{
        srv.peerLock.Lock()
        defer srv.peerLock.Unlock()

        if p.getShardNumber() == discovery.UndefinedShardNumber </span><span class="cov0" title="0">{
                srv.log.Warn("got invalid peer with shard 0, peer info %s", p.Node)
                return false
        }</span>

        <span class="cov0" title="0">peer := srv.peerSet.find(p.Node.ID)
        if peer != nil </span><span class="cov0" title="0">{
                srv.log.Debug("peer is already exist %s -&gt; %s, skip %s -&gt; %s", peer.LocalAddr(), peer.RemoteAddr(),
                        p.LocalAddr(), p.RemoteAddr())
                return false
        }</span>

        <span class="cov0" title="0">srv.peerSet.add(p)
        srv.log.Info("add peer to server, len(peers)=%d. peer %s", srv.PeerCount(), p.Node)
        p.notifyProtocolsAddPeer()

        metricsAddPeerMeter.Mark(1)
        metricsPeerCountGauge.Update(int64(srv.PeerCount()))
        return true</span>
}

func (srv *Server) deletePeer(id common.Address) <span class="cov0" title="0">{
        srv.peerLock.Lock()
        defer srv.peerLock.Unlock()

        p := srv.peerSet.find(id)
        if p != nil </span><span class="cov0" title="0">{
                srv.peerSet.delete(p)
                p.notifyProtocolsDeletePeer()
                srv.log.Info("server.run delPeerChan recved. peer match. remove peer. peers num=%d", srv.PeerCount())

                metricsDeletePeerMeter.Mark(1)
                metricsPeerCountGauge.Update(int64(srv.PeerCount()))
        }</span><span class="cov0" title="0"> else {
                srv.log.Info("server.run delPeerChan received. peer not match")
        }</span>
}

func (srv *Server) run() <span class="cov0" title="0">{
        defer srv.loopWG.Done()
        srv.log.Info("p2p start running...")

running:
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-srv.quit:<span class="cov0" title="0">
                        srv.log.Warn("server got quit signal, run cleanup logic")
                        break running</span>
                }
        }

        // Disconnect all peers.
        <span class="cov0" title="0">srv.peerSet.foreach(func(p *Peer) </span><span class="cov0" title="0">{
                p.Disconnect(discServerQuit)
        }</span>)
}

func (srv *Server) startListening() error <span class="cov0" title="0">{
        // Launch the TCP listener.
        listener, err := net.Listen("tcp", srv.Config.ListenAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">laddr := listener.Addr().(*net.TCPAddr)
        srv.Config.ListenAddr = laddr.String()
        srv.listener = listener
        srv.loopWG.Add(1)
        go srv.listenLoop()
        return nil</span>
}

type tempError interface {
        Temporary() bool
}

// Wait wait for server until it exit
func (srv *Server) Wait() <span class="cov0" title="0">{
        srv.loopWG.Wait()
}</span>

// listenLoop runs in its own goroutine and accepts inbound connections.
func (srv *Server) listenLoop() <span class="cov0" title="0">{
        defer srv.loopWG.Done()
        // If all slots are taken, no further connections are accepted.
        tokens := maxAcceptConns
        if srv.MaxPendingPeers &gt; 0 </span><span class="cov0" title="0">{
                tokens = srv.MaxPendingPeers
        }</span>
        <span class="cov0" title="0">slots := make(chan struct{}, tokens)
        for i := 0; i &lt; tokens; i++ </span><span class="cov0" title="0">{
                slots &lt;- struct{}{}
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                // Wait for a handshake slot before accepting.
                &lt;-slots
                var (
                        fd  net.Conn
                        err error
                )
                for </span><span class="cov0" title="0">{
                        fd, err = srv.listener.Accept()
                        if tempErr, ok := err.(tempError); ok &amp;&amp; tempErr.Temporary() </span><span class="cov0" title="0">{
                                continue</span>
                        }<span class="cov0" title="0"> else if err != nil </span><span class="cov0" title="0">{
                                srv.log.Error("p2p.listenLoop accept err. %s", err)
                                return
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        srv.log.Info("Accept new connection from, %s -&gt; %s", fd.RemoteAddr(), fd.LocalAddr())
                        err := srv.setupConn(fd, inboundConn, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                srv.log.Info("setupConn err, %s", err)
                        }</span>

                        <span class="cov0" title="0">slots &lt;- struct{}{}</span>
                }()
        }
}

// setupConn Confirm both side are valid peers, have sub-protocols supported by each other
// Assume the inbound side is server side; outbound side is client side.
func (srv *Server) setupConn(fd net.Conn, flags int, dialDest *discovery.Node) error <span class="cov0" title="0">{
        srv.log.Info("setup connection with peer %s", dialDest)
        peer := NewPeer(&amp;connection{fd: fd}, srv.Protocols, srv.log, dialDest)
        var caps []Cap
        for _, proto := range srv.Protocols </span><span class="cov0" title="0">{
                caps = append(caps, proto.cap())
        }</span>

        <span class="cov0" title="0">recvMsg, _, err := srv.doHandShake(caps, peer, flags, dialDest)
        if err != nil </span><span class="cov0" title="0">{
                srv.log.Info("do handshake failed with peer %s, err info %s", dialDest, err)
                peer.close()
                return err
        }</span>

        <span class="cov0" title="0">srv.log.Debug("handshake succeed. %s -&gt; %s", fd.LocalAddr(), fd.RemoteAddr())
        peerNodeID := recvMsg.NodeID
        if flags == inboundConn </span><span class="cov0" title="0">{
                peerNode, ok := srv.kadDB.FindByNodeID(peerNodeID)
                if !ok </span><span class="cov0" title="0">{
                        srv.log.Warn("p2p.setupConn conn handshaked, not found nodeID")
                        peer.close()
                        return errors.New("not found nodeID in discovery database")
                }</span>

                <span class="cov0" title="0">srv.log.Info("p2p.setupConn peerNodeID found in nodeMap. %s", peerNode.ID.ToHex())
                peer.Node = peerNode</span>
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                srv.loopWG.Add(1)
                if srv.addPeer(peer) </span><span class="cov0" title="0">{
                        peer.run()
                        srv.deletePeer(peer.Node.ID)
                }</span><span class="cov0" title="0"> else {
                        peer.close()
                }</span>

                <span class="cov0" title="0">srv.loopWG.Done()</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) peerIsValidate(recvMsg *ProtoHandShake) bool <span class="cov0" title="0">{
        var genesis core.GenesisInfo
        err := json.Unmarshal(recvMsg.Params, &amp;genesis)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for key, val := range genesis.Accounts </span><span class="cov0" title="0">{
                v, ok := srv.genesis.Accounts[key]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if val.Cmp(v) != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">if srv.Config.NetworkID != recvMsg.NetworkID </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">var caps []Cap
        for _, proto := range srv.Protocols </span><span class="cov0" title="0">{
                caps = append(caps, proto.cap())
        }</span>
        <span class="cov0" title="0">if len(caps) != len(recvMsg.Caps) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">var str string
        var tag = true
        len := len(caps)
        for i := 0; i &lt; len; i++ </span><span class="cov0" title="0">{
                str = caps[i].String()
                for j := 0; j &lt; len; j++ </span><span class="cov0" title="0">{
                        if recvMsg.Caps[j].String() != str </span><span class="cov0" title="0">{
                                tag = false
                                continue</span>
                        }
                        <span class="cov0" title="0">tag = true
                        break</span>
                }
                <span class="cov0" title="0">if !tag </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return tag</span>
}

// doHandShake Communicate each other
func (srv *Server) doHandShake(caps []Cap, peer *Peer, flags int, dialDest *discovery.Node) (recvMsg *ProtoHandShake, nounceCnt uint64, err error) <span class="cov0" title="0">{
        var renounceCnt uint64
        handshakeMsg := &amp;ProtoHandShake{Caps: caps}
        handshakeMsg.NetworkID = srv.Config.NetworkID
        params, err := json.Marshal(srv.genesis)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">handshakeMsg.Params = params
        nodeID := srv.SelfNode.ID
        copy(handshakeMsg.NodeID[0:], nodeID[0:])
        if flags == outboundConn </span><span class="cov0" title="0">{
                // client side. Send msg first
                binary.Read(rand.Reader, binary.BigEndian, &amp;nounceCnt)
                wrapMsg, err := srv.packWrapHSMsg(handshakeMsg, dialDest.ID[0:], nounceCnt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">if err = peer.rw.WriteMsg(wrapMsg); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">recvWrapMsg, err := peer.rw.ReadMsg()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">recvMsg, renounceCnt, err = srv.unPackWrapHSMsg(recvWrapMsg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">if renounceCnt != nounceCnt </span><span class="cov0" title="0">{
                        return nil, 0, errors.New("client nounceCnt is changed")
                }</span>
                <span class="cov0" title="0">if !srv.peerIsValidate(recvMsg) </span><span class="cov0" title="0">{
                        return nil, 0, errors.New("node is not consitent with groups")
                }</span>
        }<span class="cov0" title="0"> else {
                // server side. Receive handshake msg first
                recvWrapMsg, err := peer.rw.ReadMsg()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">recvMsg, nounceCnt, err = srv.unPackWrapHSMsg(recvWrapMsg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">if !srv.peerIsValidate(recvMsg) </span><span class="cov0" title="0">{
                        return nil, 0, errors.New("node is not consitent with groups")
                }</span>
                <span class="cov0" title="0">wrapMsg, err := srv.packWrapHSMsg(handshakeMsg, recvMsg.NodeID[0:], nounceCnt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">if err = peer.rw.WriteMsg(wrapMsg); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// packWrapHSMsg compose the wrapped send msg.
// A 32 byte ExtraData is used for verification process.
func (srv *Server) packWrapHSMsg(handshakeMsg *ProtoHandShake, peerNodeID []byte, nounceCnt uint64) (Message, error) <span class="cov0" title="0">{
        // Serialize should handle big-endian
        hdmsgRLP, err := common.Serialize(handshakeMsg)

        if err != nil </span><span class="cov0" title="0">{
                return Message{}, err
        }</span>
        <span class="cov0" title="0">wrapMsg := Message{
                Code: ctlMsgProtoHandshake,
        }
        md5Inst := md5.New()
        if _, err := md5Inst.Write(hdmsgRLP); err != nil </span><span class="cov0" title="0">{
                return Message{}, err
        }</span>
        <span class="cov0" title="0">extBuf := make([]byte, extraDataLen)

        // first 16 bytes, contains md5sum of hdmsgRLP;
        // then 8 bytes for client side nounce;
        copy(extBuf, md5Inst.Sum(nil))
        binary.BigEndian.PutUint64(extBuf[16:], nounceCnt)

        // Sign with local privateKey first
        signature := crypto.MustSign(srv.PrivateKey, crypto.MustHash(extBuf).Bytes())
        enc := make([]byte, extraDataLen+len(signature.Sig))
        copy(enc, extBuf)
        copy(enc[extraDataLen:], signature.Sig)

        // Format of wrapMsg payload, [handshake's rlp body, encoded extra data, length of encoded extra data]
        size := uint32(len(hdmsgRLP) + len(enc) + 4)
        wrapMsg.Payload = make([]byte, size)
        copy(wrapMsg.Payload, hdmsgRLP)
        copy(wrapMsg.Payload[len(hdmsgRLP):], enc)
        binary.BigEndian.PutUint32(wrapMsg.Payload[len(hdmsgRLP)+len(enc):], uint32(len(enc)))
        return wrapMsg, nil</span>
}

// unPackWrapHSMsg verify recved msg, and recover the handshake msg
func (srv *Server) unPackWrapHSMsg(recvWrapMsg Message) (recvMsg *ProtoHandShake, nounceCnt uint64, err error) <span class="cov0" title="0">{
        size := uint32(len(recvWrapMsg.Payload))
        if size &lt; extraDataLen+4 </span><span class="cov0" title="0">{
                err = errors.New("received msg with invalid length")
                return
        }</span>

        <span class="cov0" title="0">extraEncLen := binary.BigEndian.Uint32(recvWrapMsg.Payload[size-4:])
        recvHSMsgLen := size - extraEncLen - 4
        nounceCnt = binary.BigEndian.Uint64(recvWrapMsg.Payload[recvHSMsgLen+16:])
        recvEnc := recvWrapMsg.Payload[recvHSMsgLen : size-4]
        recvMsg = &amp;ProtoHandShake{}
        if err = common.Deserialize(recvWrapMsg.Payload[:recvHSMsgLen], recvMsg); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        // verify signature
        <span class="cov0" title="0">sig := crypto.Signature{
                Sig: recvEnc[extraDataLen:],
        }

        if !sig.Verify(recvMsg.NodeID, crypto.MustHash(recvEnc[0:extraDataLen]).Bytes()) </span><span class="cov0" title="0">{
                err = errors.New("unPackWrapHSMsg: received public key not match")
                return
        }</span>

        // verify recvMsg's payload md5sum to prevent modification
        <span class="cov0" title="0">md5Inst := md5.New()
        if _, err = md5Inst.Write(recvWrapMsg.Payload[:recvHSMsgLen]); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if !bytes.Equal(md5Inst.Sum(nil), recvEnc[:16]) </span><span class="cov0" title="0">{
                err = errors.New("unPackWrapHSMsg: received md5sum not match")
                return
        }</span>

        <span class="cov0" title="0">srv.log.Debug("unPackWrapHSMsg: verify OK!")
        return</span>
}

// Stop terminates the execution of the p2p server
func (srv *Server) Stop() <span class="cov0" title="0">{
        srv.lock.Lock()
        defer srv.lock.Unlock()

        if !srv.running </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">srv.running = false

        if srv.listener != nil </span><span class="cov0" title="0">{
                srv.listener.Close()
        }</span>

        <span class="cov0" title="0">close(srv.quit)
        srv.Wait()</span>
}

// PeerInfos array of PeerInfo for sort alphabetically by node identifier
type PeerInfos []PeerInfo

func (p PeerInfos) Len() int           <span class="cov0" title="0">{ return len(p) }</span>
func (p PeerInfos) Less(i, j int) bool <span class="cov0" title="0">{ return p[i].ID &lt; p[j].ID }</span>
func (p PeerInfos) Swap(i, j int)      <span class="cov0" title="0">{ p[i], p[j] = p[j], p[i] }</span>

// PeersInfo returns an array of metadata objects describing connected peers.
func (srv *Server) PeersInfo() *[]PeerInfo <span class="cov0" title="0">{
        infos := make([]PeerInfo, 0, srv.PeerCount())
        srv.peerSet.foreach(func(peer *Peer) </span><span class="cov0" title="0">{
                if peer != nil </span><span class="cov0" title="0">{
                        peerInfo := peer.Info()
                        infos = append(infos, *peerInfo)
                }</span>
        })

        <span class="cov0" title="0">sort.Sort(PeerInfos(infos))
        return &amp;infos</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "bytes"
        "container/list"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net"
        "net/url"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
)

var (
        ErrClientQuit                = errors.New("client is closed")
        ErrNoResult                  = errors.New("no result in JSON-RPC response")
        ErrSubscriptionQueueOverflow = errors.New("subscription queue overflow")
)

const (
        // Timeouts
        tcpKeepAliveInterval = 30 * time.Second
        defaultDialTimeout   = 10 * time.Second // used when dialing if the context has no deadline
        defaultWriteTimeout  = 10 * time.Second // used for calls if the context has no deadline
        subscribeTimeout     = 5 * time.Second  // overall timeout eth_subscribe, rpc_modules calls
)

const (
        // Subscriptions are removed when the subscriber cannot keep up.
        //
        // This can be worked around by supplying a channel with sufficiently sized buffer,
        // but this can be inconvenient and hard to explain in the docs. Another issue with
        // buffered channels is that the buffer is static even though it might not be needed
        // most of the time.
        //
        // The approach taken here is to maintain a per-subscription linked list buffer
        // shrinks on demand. If the buffer reaches the size below, the subscription is
        // dropped.
        maxClientSubscriptionBuffer = 8000
)

// BatchElem is an element in a batch request.
type BatchElem struct {
        Method string
        Args   []interface{}
        // The result is unmarshaled into this field. Result must be set to a
        // non-nil pointer value of the desired type, otherwise the response will be
        // discarded.
        Result interface{}
        // Error is set if the server returns an error for this request, or if
        // unmarshaling into Result fails. It is not set for I/O errors.
        Error error
}

// A value of this type can a JSON-RPC request, notification, successful response or
// error response. Which one it is depends on the fields.
type jsonrpcMessage struct {
        Version string          `json:"jsonrpc"`
        ID      json.RawMessage `json:"id,omitempty"`
        Method  string          `json:"method,omitempty"`
        Params  json.RawMessage `json:"params,omitempty"`
        Error   *jsonError      `json:"error,omitempty"`
        Result  json.RawMessage `json:"result,omitempty"`
}

func (msg *jsonrpcMessage) isNotification() bool <span class="cov8" title="1">{
        return msg.ID == nil &amp;&amp; msg.Method != ""
}</span>

func (msg *jsonrpcMessage) isResponse() bool <span class="cov8" title="1">{
        return msg.hasValidID() &amp;&amp; msg.Method == "" &amp;&amp; len(msg.Params) == 0
}</span>

func (msg *jsonrpcMessage) hasValidID() bool <span class="cov8" title="1">{
        return len(msg.ID) &gt; 0 &amp;&amp; msg.ID[0] != '{' &amp;&amp; msg.ID[0] != '['
}</span>

func (msg *jsonrpcMessage) String() string <span class="cov0" title="0">{
        b, _ := json.Marshal(msg)
        return string(b)
}</span>

// Client represents a connection to an RPC server.
type Client struct {
        idCounter   uint32
        connectFunc func(ctx context.Context) (net.Conn, error)
        isHTTP      bool

        // writeConn is only safe to access outside dispatch, with the
        // write lock held. The write lock is taken by sending on
        // requestOp and released by sending on sendDone.
        writeConn net.Conn

        // for dispatch
        close       chan struct{}
        didQuit     chan struct{}                  // closed when client quits
        reconnected chan net.Conn                  // where write/reconnect sends the new connection
        readErr     chan error                     // errors from read
        readResp    chan []*jsonrpcMessage         // valid messages from read
        requestOp   chan *requestOp                // for registering response IDs
        sendDone    chan error                     // signals write completion, releases write lock
        respWait    map[string]*requestOp          // active requests
        subs        map[string]*ClientSubscription // active subscriptions
}

type requestOp struct {
        ids  []json.RawMessage
        err  error
        resp chan *jsonrpcMessage // receives up to len(ids) responses
        sub  *ClientSubscription  // only set for EthSubscribe requests
}

func (op *requestOp) wait(ctx context.Context) (*jsonrpcMessage, error) <span class="cov8" title="1">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return nil, ctx.Err()</span>
        case resp := &lt;-op.resp:<span class="cov8" title="1">
                return resp, op.err</span>
        }
}

// Dial creates a new client for the given URL.
//
// The currently supported URL schemes are "http", "https", "ws" and "wss". If rawurl is a
// file name with no URL scheme, a local socket connection is established using UNIX
// domain sockets on supported platforms and named pipes on Windows. If you want to
// configure transport options, use DialHTTP, DialWebsocket or DialIPC instead.
//
// For websocket connections, the origin is set to the local host name.
//
// The client reconnects automatically if the connection is lost.
func Dial(rawurl string) (*Client, error) <span class="cov8" title="1">{
        return DialContext(context.Background(), rawurl)
}</span>

// DialContext creates a new RPC client, just like Dial.
//
// The context is used to cancel or time out the initial connection establishment. It does
// not affect subsequent interactions with the client.
func DialContext(ctx context.Context, rawurl string) (*Client, error) <span class="cov8" title="1">{
        u, err := url.Parse(rawurl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">switch u.Scheme </span>{
        case "http", "https":<span class="cov8" title="1">
                return DialHTTP(rawurl)</span>
        case "ws", "wss":<span class="cov8" title="1">
                return DialWebsocket(ctx, rawurl, "")</span>
        case "":<span class="cov8" title="1">
                return DialIPC(ctx, rawurl)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("no known transport for URL scheme %q", u.Scheme)</span>
        }
}

func newClient(initctx context.Context, connectFunc func(context.Context) (net.Conn, error)) (*Client, error) <span class="cov8" title="1">{
        conn, err := connectFunc(initctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, isHTTP := conn.(*httpConn)

        c := &amp;Client{
                writeConn:   conn,
                isHTTP:      isHTTP,
                connectFunc: connectFunc,
                close:       make(chan struct{}),
                didQuit:     make(chan struct{}),
                reconnected: make(chan net.Conn),
                readErr:     make(chan error),
                readResp:    make(chan []*jsonrpcMessage),
                requestOp:   make(chan *requestOp),
                sendDone:    make(chan error, 1),
                respWait:    make(map[string]*requestOp),
                subs:        make(map[string]*ClientSubscription),
        }
        if !isHTTP </span><span class="cov8" title="1">{
                go c.dispatch(conn)
        }</span>
        <span class="cov8" title="1">return c, nil</span>
}

func (c *Client) nextID() json.RawMessage <span class="cov8" title="1">{
        id := atomic.AddUint32(&amp;c.idCounter, 1)
        return []byte(strconv.FormatUint(uint64(id), 10))
}</span>

// SupportedModules calls the rpc_modules method, retrieving the list of
// APIs that are available on the server.
func (c *Client) SupportedModules() (map[string]string, error) <span class="cov0" title="0">{
        var result map[string]string
        ctx, cancel := context.WithTimeout(context.Background(), subscribeTimeout)
        defer cancel()
        err := c.CallContext(ctx, &amp;result, "rpc_modules")
        return result, err
}</span>

// Close closes the client, aborting any in-flight requests.
func (c *Client) Close() <span class="cov8" title="1">{
        if c.isHTTP </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">select </span>{
        case c.close &lt;- struct{}{}:<span class="cov8" title="1">
                &lt;-c.didQuit</span>
        case &lt;-c.didQuit:</span><span class="cov8" title="1">
        }
}

// Call performs a JSON-RPC call with the given arguments and unmarshals into
// result if no error occurred.
//
// The result must be a pointer so that package json can unmarshal into it. You
// can also pass nil, in which case the result is ignored.
func (c *Client) Call(result interface{}, method string, args ...interface{}) error <span class="cov8" title="1">{
        ctx := context.Background()
        return c.CallContext(ctx, result, method, args...)
}</span>

// CallContext performs a JSON-RPC call with the given arguments. If the context is
// canceled before the call has successfully returned, CallContext returns immediately.
//
// The result must be a pointer so that package json can unmarshal into it. You
// can also pass nil, in which case the result is ignored.
func (c *Client) CallContext(ctx context.Context, result interface{}, method string, args ...interface{}) error <span class="cov8" title="1">{
        msg, err := c.newMessage(method, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">op := &amp;requestOp{ids: []json.RawMessage{msg.ID}, resp: make(chan *jsonrpcMessage, 1)}

        if c.isHTTP </span><span class="cov8" title="1">{
                err = c.sendHTTP(ctx, op, msg)
        }</span><span class="cov8" title="1"> else {
                err = c.send(ctx, op, msg)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // dispatch has accepted the request and will close the channel it when it quits.
        <span class="cov8" title="1">switch resp, err := op.wait(ctx); </span>{
        case err != nil:<span class="cov8" title="1">
                return err</span>
        case resp.Error != nil:<span class="cov0" title="0">
                return resp.Error</span>
        case len(resp.Result) == 0:<span class="cov0" title="0">
                return ErrNoResult</span>
        default:<span class="cov8" title="1">
                return json.Unmarshal(resp.Result, &amp;result)</span>
        }
}

// BatchCall sends all given requests as a single batch and waits for the server
// to return a response for all of them.
//
// In contrast to Call, BatchCall only returns I/O errors. Any error specific to
// a request is reported through the Error field of the corresponding BatchElem.
//
// Note that batch calls may not be executed atomically on the server side.
func (c *Client) BatchCall(b []BatchElem) error <span class="cov8" title="1">{
        ctx := context.Background()
        return c.BatchCallContext(ctx, b)
}</span>

// BatchCall sends all given requests as a single batch and waits for the server
// to return a response for all of them. The wait duration is bounded by the
// context's deadline.
//
// In contrast to CallContext, BatchCallContext only returns errors that have occurred
// while sending the request. Any error specific to a request is reported through the
// Error field of the corresponding BatchElem.
//
// Note that batch calls may not be executed atomically on the server side.
func (c *Client) BatchCallContext(ctx context.Context, b []BatchElem) error <span class="cov8" title="1">{
        msgs := make([]*jsonrpcMessage, len(b))
        op := &amp;requestOp{
                ids:  make([]json.RawMessage, len(b)),
                resp: make(chan *jsonrpcMessage, len(b)),
        }
        for i, elem := range b </span><span class="cov8" title="1">{
                msg, err := c.newMessage(elem.Method, elem.Args...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">msgs[i] = msg
                op.ids[i] = msg.ID</span>
        }

        <span class="cov8" title="1">var err error
        if c.isHTTP </span><span class="cov0" title="0">{
                err = c.sendBatchHTTP(ctx, op, msgs)
        }</span><span class="cov8" title="1"> else {
                err = c.send(ctx, op, msgs)
        }</span>

        // Wait for all responses to come back.
        <span class="cov8" title="1">for n := 0; n &lt; len(b) &amp;&amp; err == nil; n++ </span><span class="cov8" title="1">{
                var resp *jsonrpcMessage
                resp, err = op.wait(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                // Find the element corresponding to this response.
                // The element is guaranteed to be present because dispatch
                // only sends valid IDs to our channel.
                <span class="cov8" title="1">var elem *BatchElem
                for i := range msgs </span><span class="cov8" title="1">{
                        if bytes.Equal(msgs[i].ID, resp.ID) </span><span class="cov8" title="1">{
                                elem = &amp;b[i]
                                break</span>
                        }
                }
                <span class="cov8" title="1">if resp.Error != nil </span><span class="cov8" title="1">{
                        elem.Error = resp.Error
                        continue</span>
                }
                <span class="cov8" title="1">if len(resp.Result) == 0 </span><span class="cov0" title="0">{
                        elem.Error = ErrNoResult
                        continue</span>
                }
                <span class="cov8" title="1">elem.Error = json.Unmarshal(resp.Result, elem.Result)</span>
        }
        <span class="cov8" title="1">return err</span>
}

// EthSubscribe registers a subscripion under the "eth" namespace.
func (c *Client) EthSubscribe(ctx context.Context, channel interface{}, args ...interface{}) (*ClientSubscription, error) <span class="cov8" title="1">{
        return c.Subscribe(ctx, "eth", channel, args...)
}</span>

// ShhSubscribe registers a subscripion under the "shh" namespace.
func (c *Client) ShhSubscribe(ctx context.Context, channel interface{}, args ...interface{}) (*ClientSubscription, error) <span class="cov0" title="0">{
        return c.Subscribe(ctx, "shh", channel, args...)
}</span>

// Subscribe calls the "&lt;namespace&gt;_subscribe" method with the given arguments,
// registering a subscription. Server notifications for the subscription are
// sent to the given channel. The element type of the channel must match the
// expected type of content returned by the subscription.
//
// The context argument cancels the RPC request that sets up the subscription but has no
// effect on the subscription after Subscribe has returned.
//
// Slow subscribers will be dropped eventually. Client buffers up to 8000 notifications
// before considering the subscriber dead. The subscription Err channel will receive
// ErrSubscriptionQueueOverflow. Use a sufficiently large buffer on the channel or ensure
// that the channel usually has at least one reader to prevent this issue.
func (c *Client) Subscribe(ctx context.Context, namespace string, channel interface{}, args ...interface{}) (*ClientSubscription, error) <span class="cov8" title="1">{
        // Check type of channel first.
        chanVal := reflect.ValueOf(channel)
        if chanVal.Kind() != reflect.Chan || chanVal.Type().ChanDir()&amp;reflect.SendDir == 0 </span><span class="cov8" title="1">{
                panic("first argument to Subscribe must be a writable channel")</span>
        }
        <span class="cov8" title="1">if chanVal.IsNil() </span><span class="cov8" title="1">{
                panic("channel given to Subscribe must not be nil")</span>
        }
        <span class="cov8" title="1">if c.isHTTP </span><span class="cov0" title="0">{
                return nil, ErrNotificationsUnsupported
        }</span>

        <span class="cov8" title="1">msg, err := c.newMessage(namespace+subscribeMethodSuffix, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">op := &amp;requestOp{
                ids:  []json.RawMessage{msg.ID},
                resp: make(chan *jsonrpcMessage),
                sub:  newClientSubscription(c, namespace, chanVal),
        }

        // Send the subscription request.
        // The arrival and validity of the response is signaled on sub.quit.
        if err := c.send(ctx, op, msg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if _, err := op.wait(ctx); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return op.sub, nil</span>
}

func (c *Client) newMessage(method string, paramsIn ...interface{}) (*jsonrpcMessage, error) <span class="cov8" title="1">{
        params, err := json.Marshal(paramsIn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;jsonrpcMessage{Version: "2.0", ID: c.nextID(), Method: method, Params: params}, nil</span>
}

// send registers op with the dispatch loop, then sends msg on the connection.
// if sending fails, op is deregistered.
func (c *Client) send(ctx context.Context, op *requestOp, msg interface{}) error <span class="cov8" title="1">{
        select </span>{
        case c.requestOp &lt;- op:<span class="cov8" title="1">
                err := c.write(ctx, msg)
                c.sendDone &lt;- err
                return err</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                // This can happen if the client is overloaded or unable to keep up with
                // subscription notifications.
                return ctx.Err()</span>
        case &lt;-c.didQuit:<span class="cov0" title="0">
                return ErrClientQuit</span>
        }
}

func (c *Client) write(ctx context.Context, msg interface{}) error <span class="cov8" title="1">{
        deadline, ok := ctx.Deadline()
        if !ok </span><span class="cov8" title="1">{
                deadline = time.Now().Add(defaultWriteTimeout)
        }</span>
        // The previous write failed. Try to establish a new connection.
        <span class="cov8" title="1">if c.writeConn == nil </span><span class="cov8" title="1">{
                if err := c.reconnect(ctx); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">c.writeConn.SetWriteDeadline(deadline)
        err := json.NewEncoder(c.writeConn).Encode(msg)
        if err != nil </span><span class="cov8" title="1">{
                c.writeConn = nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (c *Client) reconnect(ctx context.Context) error <span class="cov8" title="1">{
        newconn, err := c.connectFunc(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">select </span>{
        case c.reconnected &lt;- newconn:<span class="cov8" title="1">
                c.writeConn = newconn
                return nil</span>
        case &lt;-c.didQuit:<span class="cov0" title="0">
                newconn.Close()
                return ErrClientQuit</span>
        }
}

// dispatch is the main loop of the client.
// It sends read messages to waiting calls to Call and BatchCall
// and subscription notifications to registered subscriptions.
func (c *Client) dispatch(conn net.Conn) <span class="cov8" title="1">{
        // Spawn the initial read loop.
        go c.read(conn)

        var (
                lastOp        *requestOp    // tracks last send operation
                requestOpLock = c.requestOp // nil while the send lock is held
                reading       = true        // if true, a read loop is running
        )
        defer close(c.didQuit)
        defer func() </span><span class="cov8" title="1">{
                c.closeRequestOps(ErrClientQuit)
                conn.Close()
                if reading </span><span class="cov8" title="1">{
                        // Empty read channels until read is dead.
                        for </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-c.readResp:</span><span class="cov0" title="0">
                                case &lt;-c.readErr:<span class="cov8" title="1">
                                        return</span>
                                }
                        }
                }
        }()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.close:<span class="cov8" title="1">
                        return</span>

                // Read path.
                case batch := &lt;-c.readResp:<span class="cov8" title="1">
                        for _, msg := range batch </span><span class="cov8" title="1">{
                                switch </span>{
                                case msg.isNotification():<span class="cov8" title="1">
                                        c.handleNotification(msg)</span>
                                case msg.isResponse():<span class="cov8" title="1">
                                        c.handleResponse(msg)</span>
                                default:</span><span class="cov0" title="0">
                                        // TODO: maybe close
                                }
                        }

                case err := &lt;-c.readErr:<span class="cov8" title="1">
                        c.closeRequestOps(err)
                        conn.Close()
                        reading = false</span>

                case newconn := &lt;-c.reconnected:<span class="cov8" title="1">
                        if reading </span><span class="cov0" title="0">{
                                // Wait for the previous read loop to exit. This is a rare case.
                                conn.Close()
                                &lt;-c.readErr
                        }</span>
                        <span class="cov8" title="1">go c.read(newconn)
                        reading = true
                        conn = newconn</span>

                // Send path.
                case op := &lt;-requestOpLock:<span class="cov8" title="1">
                        // Stop listening for further send ops until the current one is done.
                        requestOpLock = nil
                        lastOp = op
                        for _, id := range op.ids </span><span class="cov8" title="1">{
                                c.respWait[string(id)] = op
                        }</span>

                case err := &lt;-c.sendDone:<span class="cov8" title="1">
                        if err != nil </span><span class="cov8" title="1">{
                                // Remove response handlers for the last send. We remove those here
                                // because the error is already handled in Call or BatchCall. When the
                                // read loop goes down, it will signal all other current operations.
                                for _, id := range lastOp.ids </span><span class="cov8" title="1">{
                                        delete(c.respWait, string(id))
                                }</span>
                        }
                        // Listen for send ops again.
                        <span class="cov8" title="1">requestOpLock = c.requestOp
                        lastOp = nil</span>
                }
        }
}

// closeRequestOps unblocks pending send ops and active subscriptions.
func (c *Client) closeRequestOps(err error) <span class="cov8" title="1">{
        didClose := make(map[*requestOp]bool)

        for id, op := range c.respWait </span><span class="cov8" title="1">{
                // Remove the op so that later calls will not close op.resp again.
                delete(c.respWait, id)

                if !didClose[op] </span><span class="cov8" title="1">{
                        op.err = err
                        close(op.resp)
                        didClose[op] = true
                }</span>
        }
        <span class="cov8" title="1">for id, sub := range c.subs </span><span class="cov8" title="1">{
                delete(c.subs, id)
                sub.quitWithError(err, false)
        }</span>
}

func (c *Client) handleNotification(msg *jsonrpcMessage) <span class="cov8" title="1">{
        if !strings.HasSuffix(msg.Method, notificationMethodSuffix) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var subResult struct {
                ID     string          `json:"subscription"`
                Result json.RawMessage `json:"result"`
        }
        if err := json.Unmarshal(msg.Params, &amp;subResult); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if c.subs[subResult.ID] != nil </span><span class="cov8" title="1">{
                c.subs[subResult.ID].deliver(subResult.Result)
        }</span>
}

func (c *Client) handleResponse(msg *jsonrpcMessage) <span class="cov8" title="1">{
        op := c.respWait[string(msg.ID)]
        if op == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">delete(c.respWait, string(msg.ID))
        // For normal responses, just forward the reply to Call/BatchCall.
        if op.sub == nil </span><span class="cov8" title="1">{
                op.resp &lt;- msg
                return
        }</span>
        // For subscription responses, start the subscription if the server
        // indicates success. EthSubscribe gets unblocked in either case through
        // the op.resp channel.
        <span class="cov8" title="1">defer close(op.resp)
        if msg.Error != nil </span><span class="cov8" title="1">{
                op.err = msg.Error
                return
        }</span>
        <span class="cov8" title="1">if op.err = json.Unmarshal(msg.Result, &amp;op.sub.subid); op.err == nil </span><span class="cov8" title="1">{
                go op.sub.start()
                c.subs[op.sub.subid] = op.sub
        }</span>
}

// Reading happens on a dedicated goroutine.

func (c *Client) read(conn net.Conn) error <span class="cov8" title="1">{
        var (
                buf json.RawMessage
                dec = json.NewDecoder(conn)
        )
        readMessage := func() (rs []*jsonrpcMessage, err error) </span><span class="cov8" title="1">{
                buf = buf[:0]
                if err = dec.Decode(&amp;buf); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if isBatch(buf) </span><span class="cov8" title="1">{
                        err = json.Unmarshal(buf, &amp;rs)
                }</span><span class="cov8" title="1"> else {
                        rs = make([]*jsonrpcMessage, 1)
                        err = json.Unmarshal(buf, &amp;rs[0])
                }</span>
                <span class="cov8" title="1">return rs, err</span>
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                resp, err := readMessage()
                if err != nil </span><span class="cov8" title="1">{
                        c.readErr &lt;- err
                        return err
                }</span>
                <span class="cov8" title="1">c.readResp &lt;- resp</span>
        }
}

// Subscriptions.

// A ClientSubscription represents a subscription established through EthSubscribe.
type ClientSubscription struct {
        client    *Client
        etype     reflect.Type
        channel   reflect.Value
        namespace string
        subid     string
        in        chan json.RawMessage

        quitOnce sync.Once     // ensures quit is closed once
        quit     chan struct{} // quit is closed when the subscription exits
        errOnce  sync.Once     // ensures err is closed once
        err      chan error
}

func newClientSubscription(c *Client, namespace string, channel reflect.Value) *ClientSubscription <span class="cov8" title="1">{
        sub := &amp;ClientSubscription{
                client:    c,
                namespace: namespace,
                etype:     channel.Type().Elem(),
                channel:   channel,
                quit:      make(chan struct{}),
                err:       make(chan error, 1),
                in:        make(chan json.RawMessage),
        }
        return sub
}</span>

// Err returns the subscription error channel. The intended use of Err is to schedule
// resubscription when the client connection is closed unexpectedly.
//
// The error channel receives a value when the subscription has ended due
// to an error. The received error is nil if Close has been called
// on the underlying client and no other error has occurred.
//
// The error channel is closed when Unsubscribe is called on the subscription.
func (sub *ClientSubscription) Err() &lt;-chan error <span class="cov8" title="1">{
        return sub.err
}</span>

// Unsubscribe unsubscribes the notification and closes the error channel.
// It can safely be called more than once.
func (sub *ClientSubscription) Unsubscribe() <span class="cov8" title="1">{
        sub.quitWithError(nil, true)
        sub.errOnce.Do(func() </span><span class="cov8" title="1">{ close(sub.err) }</span>)
}

func (sub *ClientSubscription) quitWithError(err error, unsubscribeServer bool) <span class="cov8" title="1">{
        sub.quitOnce.Do(func() </span><span class="cov8" title="1">{
                // The dispatch loop won't be able to execute the unsubscribe call
                // if it is blocked on deliver. Close sub.quit first because it
                // unblocks deliver.
                close(sub.quit)
                if unsubscribeServer </span><span class="cov8" title="1">{
                        sub.requestUnsubscribe()
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        if err == ErrClientQuit </span><span class="cov0" title="0">{
                                err = nil // Adhere to subscription semantics.
                        }</span>
                        <span class="cov8" title="1">sub.err &lt;- err</span>
                }
        })
}

func (sub *ClientSubscription) deliver(result json.RawMessage) (ok bool) <span class="cov8" title="1">{
        select </span>{
        case sub.in &lt;- result:<span class="cov8" title="1">
                return true</span>
        case &lt;-sub.quit:<span class="cov8" title="1">
                return false</span>
        }
}

func (sub *ClientSubscription) start() <span class="cov8" title="1">{
        sub.quitWithError(sub.forward())
}</span>

func (sub *ClientSubscription) forward() (err error, unsubscribeServer bool) <span class="cov8" title="1">{
        cases := []reflect.SelectCase{
                {Dir: reflect.SelectRecv, Chan: reflect.ValueOf(sub.quit)},
                {Dir: reflect.SelectRecv, Chan: reflect.ValueOf(sub.in)},
                {Dir: reflect.SelectSend, Chan: sub.channel},
        }
        buffer := list.New()
        defer buffer.Init()
        for </span><span class="cov8" title="1">{
                var chosen int
                var recv reflect.Value
                if buffer.Len() == 0 </span><span class="cov8" title="1">{
                        // Idle, omit send case.
                        chosen, recv, _ = reflect.Select(cases[:2])
                }</span><span class="cov8" title="1"> else {
                        // Non-empty buffer, send the first queued item.
                        cases[2].Send = reflect.ValueOf(buffer.Front().Value)
                        chosen, recv, _ = reflect.Select(cases)
                }</span>

                <span class="cov8" title="1">switch chosen </span>{
                case 0:<span class="cov8" title="1"> // &lt;-sub.quit
                        return nil, false</span>
                case 1:<span class="cov8" title="1"> // &lt;-sub.in
                        val, err := sub.unmarshal(recv.Interface().(json.RawMessage))
                        if err != nil </span><span class="cov0" title="0">{
                                return err, true
                        }</span>
                        <span class="cov8" title="1">if buffer.Len() == maxClientSubscriptionBuffer </span><span class="cov8" title="1">{
                                return ErrSubscriptionQueueOverflow, true
                        }</span>
                        <span class="cov8" title="1">buffer.PushBack(val)</span>
                case 2:<span class="cov8" title="1"> // sub.channel&lt;-
                        cases[2].Send = reflect.Value{} // Don't hold onto the value.
                        buffer.Remove(buffer.Front())</span>
                }
        }
}

func (sub *ClientSubscription) unmarshal(result json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        val := reflect.New(sub.etype)
        err := json.Unmarshal(result, val.Interface())
        return val.Elem().Interface(), err
}</span>

func (sub *ClientSubscription) requestUnsubscribe() error <span class="cov8" title="1">{
        var result interface{}
        return sub.client.Call(&amp;result, sub.namespace+unsubscribeMethodSuffix, sub.subid)
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import "fmt"

// request is for an unknown service
type methodNotFoundError struct {
        service string
        method  string
}

func (e *methodNotFoundError) ErrorCode() int <span class="cov8" title="1">{ return -32601 }</span>

func (e *methodNotFoundError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("The method %s%s%s does not exist/is not available", e.service, serviceMethodSeparator, e.method)
}</span>

// received message isn't a valid request
type invalidRequestError struct{ message string }

func (e *invalidRequestError) ErrorCode() int <span class="cov8" title="1">{ return -32600 }</span>

func (e *invalidRequestError) Error() string <span class="cov8" title="1">{ return e.message }</span>

// received message is invalid
type invalidMessageError struct{ message string }

func (e *invalidMessageError) ErrorCode() int <span class="cov0" title="0">{ return -32700 }</span>

func (e *invalidMessageError) Error() string <span class="cov0" title="0">{ return e.message }</span>

// unable to decode supplied params, or an invalid number of parameters
type invalidParamsError struct{ message string }

func (e *invalidParamsError) ErrorCode() int <span class="cov0" title="0">{ return -32602 }</span>

func (e *invalidParamsError) Error() string <span class="cov0" title="0">{ return e.message }</span>

// logic error, callback returned an error
type callbackError struct{ message string }

func (e *callbackError) ErrorCode() int <span class="cov0" title="0">{ return -32000 }</span>

func (e *callbackError) Error() string <span class="cov0" title="0">{ return e.message }</span>

// issued when a request is received after the server is issued to stop.
type shutdownError struct{}

func (e *shutdownError) ErrorCode() int <span class="cov0" title="0">{ return -32000 }</span>

func (e *shutdownError) Error() string <span class="cov0" title="0">{ return "server is shutting down" }</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "mime"
        "net"
        "net/http"
        "sync"
        "time"

        "github.com/rs/cors"
        "strings"
)

const (
        contentType                 = "application/json"
        maxHTTPRequestContentLength = 1024 * 128
)

var nullAddr, _ = net.ResolveTCPAddr("tcp", "127.0.0.1:0")

type httpConn struct {
        client    *http.Client
        req       *http.Request
        closeOnce sync.Once
        closed    chan struct{}
}

// httpConn is treated specially by Client.
func (hc *httpConn) LocalAddr() net.Addr              <span class="cov0" title="0">{ return nullAddr }</span>
func (hc *httpConn) RemoteAddr() net.Addr             <span class="cov0" title="0">{ return nullAddr }</span>
func (hc *httpConn) SetReadDeadline(time.Time) error  <span class="cov0" title="0">{ return nil }</span>
func (hc *httpConn) SetWriteDeadline(time.Time) error <span class="cov0" title="0">{ return nil }</span>
func (hc *httpConn) SetDeadline(time.Time) error      <span class="cov0" title="0">{ return nil }</span>
func (hc *httpConn) Write([]byte) (int, error)        <span class="cov0" title="0">{ panic("Write called")</span> }

func (hc *httpConn) Read(b []byte) (int, error) <span class="cov0" title="0">{
        &lt;-hc.closed
        return 0, io.EOF
}</span>

func (hc *httpConn) Close() error <span class="cov0" title="0">{
        hc.closeOnce.Do(func() </span><span class="cov0" title="0">{ close(hc.closed) }</span>)
        <span class="cov0" title="0">return nil</span>
}

// DialHTTPWithClient creates a new RPC client that connects to an RPC server over HTTP
// using the provided HTTP Client.
func DialHTTPWithClient(endpoint string, client *http.Client) (*Client, error) <span class="cov8" title="1">{
        req, err := http.NewRequest(http.MethodPost, endpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", contentType)
        req.Header.Set("Accept", contentType)

        initctx := context.Background()
        return newClient(initctx, func(context.Context) (net.Conn, error) </span><span class="cov8" title="1">{
                return &amp;httpConn{client: client, req: req, closed: make(chan struct{})}, nil
        }</span>)
}

// DialHTTP creates a new RPC client that connects to an RPC server over HTTP.
func DialHTTP(endpoint string) (*Client, error) <span class="cov8" title="1">{
        return DialHTTPWithClient(endpoint, new(http.Client))
}</span>

func (c *Client) sendHTTP(ctx context.Context, op *requestOp, msg interface{}) error <span class="cov8" title="1">{
        hc := c.writeConn.(*httpConn)
        respBody, err := hc.doRequest(ctx, msg)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer respBody.Close()
        var respmsg jsonrpcMessage
        if err := json.NewDecoder(respBody).Decode(&amp;respmsg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">op.resp &lt;- &amp;respmsg
        return nil</span>
}

func (c *Client) sendBatchHTTP(ctx context.Context, op *requestOp, msgs []*jsonrpcMessage) error <span class="cov0" title="0">{
        hc := c.writeConn.(*httpConn)
        respBody, err := hc.doRequest(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer respBody.Close()
        var respmsgs []jsonrpcMessage
        if err := json.NewDecoder(respBody).Decode(&amp;respmsgs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; len(respmsgs); i++ </span><span class="cov0" title="0">{
                op.resp &lt;- &amp;respmsgs[i]
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (hc *httpConn) doRequest(ctx context.Context, msg interface{}) (io.ReadCloser, error) <span class="cov8" title="1">{
        body, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req := hc.req.WithContext(ctx)
        req.Body = ioutil.NopCloser(bytes.NewReader(body))
        req.ContentLength = int64(len(body))

        resp, err := hc.client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return resp.Body, nil</span>
}

// httpReadWriteNopCloser wraps a io.Reader and io.Writer with a NOP Close method.
type httpReadWriteNopCloser struct {
        io.Reader
        io.Writer
}

// Close does nothing and returns always nil
func (t *httpReadWriteNopCloser) Close() error <span class="cov8" title="1">{
        return nil
}</span>

// NewHTTPServer creates a new HTTP RPC server around an API provider.
//
// Deprecated: Server implements http.Handler
func NewHTTPServer(cors []string, vhosts []string, srv *Server) *http.Server <span class="cov0" title="0">{
        // Wrap the CORS-handler within a host-handler
        handler := newCorsHandler(srv, cors)
        handler = newVHostHandler(vhosts, handler)
        return &amp;http.Server{Handler: handler}
}</span>

// ServeHTTP serves JSON-RPC requests over HTTP.
func (srv *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Permit dumb empty requests for remote health-checks (AWS)
        if r.Method == http.MethodGet &amp;&amp; r.ContentLength == 0 &amp;&amp; r.URL.RawQuery == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if code, err := validateRequest(r); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), code)
                return
        }</span>
        // All checks passed, create a codec that reads direct from the request body
        // untilEOF and writes the response to w and order the server to process a
        // single request.
        <span class="cov8" title="1">codec := NewJSONCodec(&amp;httpReadWriteNopCloser{r.Body, w})
        defer codec.Close()

        w.Header().Set("content-type", contentType)
        srv.ServeSingleRequest(codec, OptionMethodInvocation)</span>
}

// validateRequest returns a non-zero response code and error message if the
// request is invalid.
func validateRequest(r *http.Request) (int, error) <span class="cov8" title="1">{
        if r.Method == http.MethodPut || r.Method == http.MethodDelete </span><span class="cov8" title="1">{
                return http.StatusMethodNotAllowed, errors.New("method not allowed")
        }</span>
        <span class="cov8" title="1">if r.ContentLength &gt; maxHTTPRequestContentLength </span><span class="cov8" title="1">{
                err := fmt.Errorf("content length too large (%d&gt;%d)", r.ContentLength, maxHTTPRequestContentLength)
                return http.StatusRequestEntityTooLarge, err
        }</span>
        <span class="cov8" title="1">mt, _, err := mime.ParseMediaType(r.Header.Get("content-type"))
        if r.Method != http.MethodOptions &amp;&amp; (err != nil || mt != contentType) </span><span class="cov8" title="1">{
                err := fmt.Errorf("invalid content type, only %s is supported", contentType)
                return http.StatusUnsupportedMediaType, err
        }</span>
        <span class="cov8" title="1">return 0, nil</span>
}

func newCorsHandler(srv *Server, allowedOrigins []string) http.Handler <span class="cov0" title="0">{
        // disable CORS support if user has not specified a custom CORS configuration
        if len(allowedOrigins) == 0 </span><span class="cov0" title="0">{
                return srv
        }</span>
        <span class="cov0" title="0">c := cors.New(cors.Options{
                AllowedOrigins: allowedOrigins,
                AllowedMethods: []string{http.MethodPost, http.MethodGet},
                MaxAge:         600,
                AllowedHeaders: []string{"*"},
        })
        return c.Handler(srv)</span>
}

// virtualHostHandler is a handler which validates the Host-header of incoming requests.
// The virtualHostHandler can prevent DNS rebinding attacks, which do not utilize CORS-headers,
// since they do in-domain requests against the RPC api. Instead, we can see on the Host-header
// which domain was used, and validate that against a whitelist.
type virtualHostHandler struct {
        vhosts map[string]struct{}
        next   http.Handler
}

// ServeHTTP serves JSON-RPC requests over HTTP, implements http.Handler
func (h *virtualHostHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // if r.Host is not set, we can continue serving since a browser would set the Host header
        if r.Host == "" </span><span class="cov0" title="0">{
                h.next.ServeHTTP(w, r)
                return
        }</span>
        <span class="cov0" title="0">host, _, err := net.SplitHostPort(r.Host)
        if err != nil </span><span class="cov0" title="0">{
                // Either invalid (too many colons) or no port specified
                host = r.Host
        }</span>
        <span class="cov0" title="0">if ipAddr := net.ParseIP(host); ipAddr != nil </span><span class="cov0" title="0">{
                // It's an IP address, we can serve that
                h.next.ServeHTTP(w, r)
                return

        }</span>
        // Not an ip address, but a hostname. Need to validate
        <span class="cov0" title="0">if _, exist := h.vhosts["*"]; exist </span><span class="cov0" title="0">{
                h.next.ServeHTTP(w, r)
                return
        }</span>
        <span class="cov0" title="0">if _, exist := h.vhosts[host]; exist </span><span class="cov0" title="0">{
                h.next.ServeHTTP(w, r)
                return
        }</span>
        <span class="cov0" title="0">http.Error(w, "invalid host specified", http.StatusForbidden)</span>
}

func newVHostHandler(vhosts []string, next http.Handler) http.Handler <span class="cov0" title="0">{
        vhostMap := make(map[string]struct{})
        for _, allowedHost := range vhosts </span><span class="cov0" title="0">{
                vhostMap[strings.ToLower(allowedHost)] = struct{}{}
        }</span>
        <span class="cov0" title="0">return &amp;virtualHostHandler{vhostMap, next}</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "context"
        "net"
)

// NewInProcClient attaches an in-process connection to the given RPC server.
func DialInProc(handler *Server) *Client <span class="cov8" title="1">{
        initctx := context.Background()
        c, _ := newClient(initctx, func(context.Context) (net.Conn, error) </span><span class="cov8" title="1">{
                p1, p2 := net.Pipe()
                go handler.ServeCodec(NewJSONCodec(p1), OptionMethodInvocation|OptionSubscriptions)
                return p2, nil
        }</span>)
        <span class="cov8" title="1">return c</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "context"
        "net"
)

// CreateIPCListener creates an listener, on Unix platforms this is a unix socket, on
// Windows this is a named pipe
func CreateIPCListener(endpoint string) (net.Listener, error) <span class="cov0" title="0">{
        return ipcListen(endpoint)
}</span>

// ServeListener accepts connections on l, serving JSON-RPC on them.
func (srv *Server) ServeListener(l net.Listener) error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                conn, err := l.Accept()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">go srv.ServeCodec(NewJSONCodec(conn), OptionMethodInvocation|OptionSubscriptions)</span>
        }
}

// DialIPC create a new IPC client that connects to the given endpoint. On Unix it assumes
// the endpoint is the full path to a unix socket, and Windows the endpoint is an
// identifier for a named pipe.
//
// The context is used for the initial connection establishment. It does not
// affect subsequent interactions with the client.
func DialIPC(ctx context.Context, endpoint string) (*Client, error) <span class="cov8" title="1">{
        return newClient(ctx, func(ctx context.Context) (net.Conn, error) </span><span class="cov8" title="1">{
                return newIPCConnection(ctx, endpoint)
        }</span>)
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

// +build windows

package rpc

import (
        "context"
        "net"
        "time"

        "gopkg.in/natefinch/npipe.v2"
)

// This is used if the dialing context has no deadline. It is much smaller than the
// defaultDialTimeout because named pipes are local and there is no need to wait so long.
const defaultPipeDialTimeout = 2 * time.Second

// ipcListen will create a named pipe on the given endpoint.
func ipcListen(endpoint string) (net.Listener, error) <span class="cov8" title="1">{
        return npipe.Listen(endpoint)
}</span>

// newIPCConnection will connect to a named pipe with the given endpoint as name.
func newIPCConnection(ctx context.Context, endpoint string) (net.Conn, error) <span class="cov8" title="1">{
        timeout := defaultPipeDialTimeout
        if deadline, ok := ctx.Deadline(); ok </span><span class="cov8" title="1">{
                timeout = deadline.Sub(time.Now())
                if timeout &lt; 0 </span><span class="cov0" title="0">{
                        timeout = 0
                }</span>
        }
        <span class="cov8" title="1">return npipe.DialTimeout(endpoint, timeout)</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "reflect"
        "strconv"
        "strings"
        "sync"
)

const (
        jsonrpcVersion           = "2.0"
        serviceMethodSeparator   = "_"
        subscribeMethodSuffix    = "_subscribe"
        unsubscribeMethodSuffix  = "_unsubscribe"
        notificationMethodSuffix = "_subscription"
)

type jsonRequest struct {
        Method  string          `json:"method"`
        Version string          `json:"jsonrpc"`
        Id      json.RawMessage `json:"id,omitempty"`
        Payload json.RawMessage `json:"params,omitempty"`
}

type jsonSuccessResponse struct {
        Version string      `json:"jsonrpc"`
        Id      interface{} `json:"id,omitempty"`
        Result  interface{} `json:"result"`
}

type jsonError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

type jsonErrResponse struct {
        Version string      `json:"jsonrpc"`
        Id      interface{} `json:"id,omitempty"`
        Error   jsonError   `json:"error"`
}

type jsonSubscription struct {
        Subscription string      `json:"subscription"`
        Result       interface{} `json:"result,omitempty"`
}

type jsonNotification struct {
        Version string           `json:"jsonrpc"`
        Method  string           `json:"method"`
        Params  jsonSubscription `json:"params"`
}

// jsonCodec reads and writes JSON-RPC messages to the underlying connection. It
// also has support for parsing arguments and serializing (result) objects.
type jsonCodec struct {
        closer sync.Once          // close closed channel once
        closed chan interface{}   // closed on Close
        decMu  sync.Mutex         // guards d
        d      *json.Decoder      // decodes incoming requests
        encMu  sync.Mutex         // guards e
        e      *json.Encoder      // encodes responses
        rw     io.ReadWriteCloser // connection
}

func (err *jsonError) Error() string <span class="cov0" title="0">{
        if err.Message == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("json-rpc error %d", err.Code)
        }</span>
        <span class="cov0" title="0">return err.Message</span>
}

func (err *jsonError) ErrorCode() int <span class="cov0" title="0">{
        return err.Code
}</span>

// NewJSONCodec creates a new RPC server codec with support for JSON-RPC 2.0
func NewJSONCodec(rwc io.ReadWriteCloser) ServerCodec <span class="cov8" title="1">{
        d := json.NewDecoder(rwc)
        d.UseNumber()
        return &amp;jsonCodec{closed: make(chan interface{}), d: d, e: json.NewEncoder(rwc), rw: rwc}
}</span>

// isBatch returns true when the first non-whitespace characters is '['
func isBatch(msg json.RawMessage) bool <span class="cov8" title="1">{
        for _, c := range msg </span><span class="cov8" title="1">{
                // skip insignificant whitespace (http://www.ietf.org/rfc/rfc4627.txt)
                if c == 0x20 || c == 0x09 || c == 0x0a || c == 0x0d </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">return c == '['</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ReadRequestHeaders will read new requests without parsing the arguments. It will
// return a collection of requests, an indication if these requests are in batch
// form or an error when the incoming message could not be read/parsed.
func (c *jsonCodec) ReadRequestHeaders() ([]rpcRequest, bool, Error) <span class="cov8" title="1">{
        c.decMu.Lock()
        defer c.decMu.Unlock()

        var incomingMsg json.RawMessage
        if err := c.d.Decode(&amp;incomingMsg); err != nil </span><span class="cov8" title="1">{
                return nil, false, &amp;invalidRequestError{err.Error()}
        }</span>

        <span class="cov8" title="1">if isBatch(incomingMsg) </span><span class="cov8" title="1">{
                return parseBatchRequest(incomingMsg)
        }</span>

        <span class="cov8" title="1">return parseRequest(incomingMsg)</span>
}

// checkReqId returns an error when the given reqId isn't valid for RPC method calls.
// valid id's are strings, numbers or null
func checkReqId(reqId json.RawMessage) error <span class="cov8" title="1">{
        if len(reqId) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing request id")
        }</span>
        <span class="cov8" title="1">if _, err := strconv.ParseFloat(string(reqId), 64); err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">var str string
        if err := json.Unmarshal(reqId, &amp;str); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("invalid request id")</span>
}

// parseRequest will parse a single request from the given RawMessage. It will return
// the parsed request, an indication if the request was a batch or an error when
// the request could not be parsed.
func parseRequest(incomingMsg json.RawMessage) ([]rpcRequest, bool, Error) <span class="cov8" title="1">{
        var in jsonRequest
        if err := json.Unmarshal(incomingMsg, &amp;in); err != nil </span><span class="cov0" title="0">{
                return nil, false, &amp;invalidMessageError{err.Error()}
        }</span>

        <span class="cov8" title="1">if err := checkReqId(in.Id); err != nil </span><span class="cov0" title="0">{
                return nil, false, &amp;invalidMessageError{err.Error()}
        }</span>

        // subscribe are special, they will always use `subscribeMethod` as first param in the payload
        <span class="cov8" title="1">if strings.HasSuffix(in.Method, subscribeMethodSuffix) </span><span class="cov8" title="1">{
                reqs := []rpcRequest{{id: &amp;in.Id, isPubSub: true}}
                if len(in.Payload) &gt; 0 </span><span class="cov8" title="1">{
                        // first param must be subscription name
                        var subscribeMethod [1]string
                        if err := json.Unmarshal(in.Payload, &amp;subscribeMethod); err != nil </span><span class="cov0" title="0">{
                                return nil, false, &amp;invalidRequestError{"Unable to parse subscription request"}
                        }</span>

                        <span class="cov8" title="1">reqs[0].service, reqs[0].method = strings.TrimSuffix(in.Method, subscribeMethodSuffix), subscribeMethod[0]
                        reqs[0].params = in.Payload
                        return reqs, false, nil</span>
                }
                <span class="cov0" title="0">return nil, false, &amp;invalidRequestError{"Unable to parse subscription request"}</span>
        }

        <span class="cov8" title="1">if strings.HasSuffix(in.Method, unsubscribeMethodSuffix) </span><span class="cov8" title="1">{
                return []rpcRequest{{id: &amp;in.Id, isPubSub: true,
                        method: in.Method, params: in.Payload}}, false, nil
        }</span>

        <span class="cov8" title="1">elems := strings.Split(in.Method, serviceMethodSeparator)
        if len(elems) != 2 </span><span class="cov0" title="0">{
                return nil, false, &amp;methodNotFoundError{in.Method, ""}
        }</span>

        // regular RPC call
        <span class="cov8" title="1">if len(in.Payload) == 0 </span><span class="cov0" title="0">{
                return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id}}, false, nil
        }</span>

        <span class="cov8" title="1">return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id, params: in.Payload}}, false, nil</span>
}

// parseBatchRequest will parse a batch request into a collection of requests from the given RawMessage, an indication
// if the request was a batch or an error when the request could not be read.
func parseBatchRequest(incomingMsg json.RawMessage) ([]rpcRequest, bool, Error) <span class="cov8" title="1">{
        var in []jsonRequest
        if err := json.Unmarshal(incomingMsg, &amp;in); err != nil </span><span class="cov0" title="0">{
                return nil, false, &amp;invalidMessageError{err.Error()}
        }</span>

        <span class="cov8" title="1">requests := make([]rpcRequest, len(in))
        for i, r := range in </span><span class="cov8" title="1">{
                if err := checkReqId(r.Id); err != nil </span><span class="cov0" title="0">{
                        return nil, false, &amp;invalidMessageError{err.Error()}
                }</span>

                <span class="cov8" title="1">id := &amp;in[i].Id

                // subscribe are special, they will always use `subscriptionMethod` as first param in the payload
                if strings.HasSuffix(r.Method, subscribeMethodSuffix) </span><span class="cov8" title="1">{
                        requests[i] = rpcRequest{id: id, isPubSub: true}
                        if len(r.Payload) &gt; 0 </span><span class="cov8" title="1">{
                                // first param must be subscription name
                                var subscribeMethod [1]string
                                if err := json.Unmarshal(r.Payload, &amp;subscribeMethod); err != nil </span><span class="cov0" title="0">{
                                        return nil, false, &amp;invalidRequestError{"Unable to parse subscription request"}
                                }</span>

                                <span class="cov8" title="1">requests[i].service, requests[i].method = strings.TrimSuffix(r.Method, subscribeMethodSuffix), subscribeMethod[0]
                                requests[i].params = r.Payload
                                continue</span>
                        }

                        <span class="cov0" title="0">return nil, true, &amp;invalidRequestError{"Unable to parse (un)subscribe request arguments"}</span>
                }

                <span class="cov8" title="1">if strings.HasSuffix(r.Method, unsubscribeMethodSuffix) </span><span class="cov0" title="0">{
                        requests[i] = rpcRequest{id: id, isPubSub: true, method: r.Method, params: r.Payload}
                        continue</span>
                }

                <span class="cov8" title="1">if len(r.Payload) == 0 </span><span class="cov0" title="0">{
                        requests[i] = rpcRequest{id: id, params: nil}
                }</span><span class="cov8" title="1"> else {
                        requests[i] = rpcRequest{id: id, params: r.Payload}
                }</span>
                <span class="cov8" title="1">if elem := strings.Split(r.Method, serviceMethodSeparator); len(elem) == 2 </span><span class="cov8" title="1">{
                        requests[i].service, requests[i].method = elem[0], elem[1]
                }</span><span class="cov8" title="1"> else {
                        requests[i].err = &amp;methodNotFoundError{r.Method, ""}
                }</span>
        }

        <span class="cov8" title="1">return requests, true, nil</span>
}

// ParseRequestArguments tries to parse the given params (json.RawMessage) with the given
// types. It returns the parsed values or an error when the parsing failed.
func (c *jsonCodec) ParseRequestArguments(argTypes []reflect.Type, params interface{}) ([]reflect.Value, Error) <span class="cov8" title="1">{
        if args, ok := params.(json.RawMessage); !ok </span><span class="cov8" title="1">{
                return nil, &amp;invalidParamsError{"Invalid params supplied"}
        }</span><span class="cov8" title="1"> else {
                return parsePositionalArguments(args, argTypes)
        }</span>
}

// parsePositionalArguments tries to parse the given args to an array of values with the
// given types. It returns the parsed values or an error when the args could not be
// parsed. Missing optional arguments are returned as reflect.Zero values.
func parsePositionalArguments(rawArgs json.RawMessage, types []reflect.Type) ([]reflect.Value, Error) <span class="cov8" title="1">{
        // Read beginning of the args array.
        dec := json.NewDecoder(bytes.NewReader(rawArgs))
        if tok, _ := dec.Token(); tok != json.Delim('[') </span><span class="cov0" title="0">{
                return nil, &amp;invalidParamsError{"non-array args"}
        }</span>
        // Read args.
        <span class="cov8" title="1">args := make([]reflect.Value, 0, len(types))
        for i := 0; dec.More(); i++ </span><span class="cov8" title="1">{
                if i &gt;= len(types) </span><span class="cov0" title="0">{
                        return nil, &amp;invalidParamsError{fmt.Sprintf("too many arguments, want at most %d", len(types))}
                }</span>
                <span class="cov8" title="1">argval := reflect.New(types[i])
                if err := dec.Decode(argval.Interface()); err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;invalidParamsError{fmt.Sprintf("invalid argument %d: %v", i, err)}
                }</span>
                <span class="cov8" title="1">if argval.IsNil() &amp;&amp; types[i].Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                        return nil, &amp;invalidParamsError{fmt.Sprintf("missing value for required argument %d", i)}
                }</span>
                <span class="cov8" title="1">args = append(args, argval.Elem())</span>
        }
        // Read end of args array.
        <span class="cov8" title="1">if _, err := dec.Token(); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;invalidParamsError{err.Error()}
        }</span>
        // Set any missing args to nil.
        <span class="cov8" title="1">for i := len(args); i &lt; len(types); i++ </span><span class="cov8" title="1">{
                if types[i].Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                        return nil, &amp;invalidParamsError{fmt.Sprintf("missing value for required argument %d", i)}
                }</span>
                <span class="cov8" title="1">args = append(args, reflect.Zero(types[i]))</span>
        }
        <span class="cov8" title="1">return args, nil</span>
}

// CreateResponse will create a JSON-RPC success response with the given id and reply as result.
func (c *jsonCodec) CreateResponse(id interface{}, reply interface{}) interface{} <span class="cov8" title="1">{
        if isHexNum(reflect.TypeOf(reply)) </span><span class="cov0" title="0">{
                return &amp;jsonSuccessResponse{Version: jsonrpcVersion, Id: id, Result: fmt.Sprintf(`%#x`, reply)}
        }</span>
        <span class="cov8" title="1">return &amp;jsonSuccessResponse{Version: jsonrpcVersion, Id: id, Result: reply}</span>
}

// CreateErrorResponse will create a JSON-RPC error response with the given id and error.
func (c *jsonCodec) CreateErrorResponse(id interface{}, err Error) interface{} <span class="cov8" title="1">{
        return &amp;jsonErrResponse{Version: jsonrpcVersion, Id: id, Error: jsonError{Code: err.ErrorCode(), Message: err.Error()}}
}</span>

// CreateErrorResponseWithInfo will create a JSON-RPC error response with the given id and error.
// info is optional and contains additional information about the error. When an empty string is passed it is ignored.
func (c *jsonCodec) CreateErrorResponseWithInfo(id interface{}, err Error, info interface{}) interface{} <span class="cov0" title="0">{
        return &amp;jsonErrResponse{Version: jsonrpcVersion, Id: id,
                Error: jsonError{Code: err.ErrorCode(), Message: err.Error(), Data: info}}
}</span>

// CreateNotification will create a JSON-RPC notification with the given subscription id and event as params.
func (c *jsonCodec) CreateNotification(subid, namespace string, event interface{}) interface{} <span class="cov8" title="1">{
        if isHexNum(reflect.TypeOf(event)) </span><span class="cov0" title="0">{
                return &amp;jsonNotification{Version: jsonrpcVersion, Method: namespace + notificationMethodSuffix,
                        Params: jsonSubscription{Subscription: subid, Result: fmt.Sprintf(`%#x`, event)}}
        }</span>

        <span class="cov8" title="1">return &amp;jsonNotification{Version: jsonrpcVersion, Method: namespace + notificationMethodSuffix,
                Params: jsonSubscription{Subscription: subid, Result: event}}</span>
}

// Write message to client
func (c *jsonCodec) Write(res interface{}) error <span class="cov8" title="1">{
        c.encMu.Lock()
        defer c.encMu.Unlock()

        return c.e.Encode(res)
}</span>

// Close the underlying connection
func (c *jsonCodec) Close() <span class="cov8" title="1">{
        c.closer.Do(func() </span><span class="cov8" title="1">{
                close(c.closed)
                c.rw.Close()
        }</span>)
}

// Closed returns a channel which will be closed when Close is called
func (c *jsonCodec) Closed() &lt;-chan interface{} <span class="cov8" title="1">{
        return c.closed
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "context"
        "fmt"
        "reflect"
        "runtime"
        "strings"
        "sync"
        "sync/atomic"

        "gopkg.in/fatih/set.v0"
)

const MetadataApi = "rpc"

// CodecOption specifies which type of messages this codec supports
type CodecOption int

const (
        // OptionMethodInvocation is an indication that the codec supports RPC method calls
        OptionMethodInvocation CodecOption = 1 &lt;&lt; iota

        // OptionSubscriptions is an indication that the codec suports RPC notifications
        OptionSubscriptions = 1 &lt;&lt; iota // support pub sub
)

// NewServer will create a new server instance with no registered handlers.
func NewServer() *Server <span class="cov8" title="1">{
        server := &amp;Server{
                services: make(serviceRegistry),
                codecs:   set.New(),
                run:      1,
        }

        // register a default service which will provide meta information about the RPC service such as the services and
        // methods it offers.
        rpcService := &amp;RPCService{server}
        server.RegisterName(MetadataApi, rpcService)

        return server
}</span>

// RPCService gives meta information about the server.
// e.g. gives information about the loaded modules.
type RPCService struct {
        server *Server
}

// Modules returns the list of RPC services with their version number
func (s *RPCService) Modules() map[string]string <span class="cov0" title="0">{
        modules := make(map[string]string)
        for name := range s.server.services </span><span class="cov0" title="0">{
                modules[name] = "1.0"
        }</span>
        <span class="cov0" title="0">return modules</span>
}

// RegisterName will create a service for the given rcvr type under the given name. When no methods on the given rcvr
// match the criteria to be either a RPC method or a subscription an error is returned. Otherwise a new service is
// created and added to the service collection this server instance serves.
func (s *Server) RegisterName(name string, rcvr interface{}) error <span class="cov8" title="1">{
        if s.services == nil </span><span class="cov0" title="0">{
                s.services = make(serviceRegistry)
        }</span>

        <span class="cov8" title="1">svc := new(service)
        svc.typ = reflect.TypeOf(rcvr)
        rcvrVal := reflect.ValueOf(rcvr)

        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no service name for type %s", svc.typ.String())
        }</span>
        <span class="cov8" title="1">if !isExported(reflect.Indirect(rcvrVal).Type().Name()) </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is not exported", reflect.Indirect(rcvrVal).Type().Name())
        }</span>

        <span class="cov8" title="1">methods, subscriptions := suitableCallbacks(rcvrVal, svc.typ)

        // already a previous service register under given sname, merge methods/subscriptions
        if regsvc, present := s.services[name]; present </span><span class="cov0" title="0">{
                if len(methods) == 0 &amp;&amp; len(subscriptions) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Service %T doesn't have any suitable methods/subscriptions to expose", rcvr)
                }</span>
                <span class="cov0" title="0">for _, m := range methods </span><span class="cov0" title="0">{
                        regsvc.callbacks[formatName(m.method.Name)] = m
                }</span>
                <span class="cov0" title="0">for _, s := range subscriptions </span><span class="cov0" title="0">{
                        regsvc.subscriptions[formatName(s.method.Name)] = s
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">svc.name = name
        svc.callbacks, svc.subscriptions = methods, subscriptions

        if len(svc.callbacks) == 0 &amp;&amp; len(svc.subscriptions) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Service %T doesn't have any suitable methods/subscriptions to expose", rcvr)
        }</span>

        <span class="cov8" title="1">s.services[svc.name] = svc
        return nil</span>
}

// serveRequest will reads requests from the codec, calls the RPC callback and
// writes the response to the given codec.
//
// If singleShot is true it will process a single request, otherwise it will handle
// requests until the codec returns an error when reading a request (in most cases
// an EOF). It executes requests in parallel when singleShot is false.
func (s *Server) serveRequest(codec ServerCodec, singleShot bool, options CodecOption) error <span class="cov8" title="1">{
        var pend sync.WaitGroup

        defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        const size = 64 &lt;&lt; 10
                        buf := make([]byte, size)
                        buf = buf[:runtime.Stack(buf, false)]
                }</span>
                <span class="cov8" title="1">s.codecsMu.Lock()
                s.codecs.Remove(codec)
                s.codecsMu.Unlock()</span>
        }()

        <span class="cov8" title="1">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // if the codec supports notification include a notifier that callbacks can use
        // to send notification to clients. It is thight to the codec/connection. If the
        // connection is closed the notifier will stop and cancels all active subscriptions.
        if options&amp;OptionSubscriptions == OptionSubscriptions </span><span class="cov8" title="1">{
                ctx = context.WithValue(ctx, notifierKey{}, newNotifier(codec))
        }</span>
        <span class="cov8" title="1">s.codecsMu.Lock()
        if atomic.LoadInt32(&amp;s.run) != 1 </span><span class="cov0" title="0">{ // server stopped
                s.codecsMu.Unlock()
                return &amp;shutdownError{}
        }</span>
        <span class="cov8" title="1">s.codecs.Add(codec)
        s.codecsMu.Unlock()

        // test if the server is ordered to stop
        for atomic.LoadInt32(&amp;s.run) == 1 </span><span class="cov8" title="1">{
                reqs, batch, err := s.readRequest(codec)
                if err != nil </span><span class="cov8" title="1">{
                        // If a parsing error occurred, send an error
                        if err.Error() != "EOF" </span><span class="cov8" title="1">{
                                codec.Write(codec.CreateErrorResponse(nil, err))
                        }</span>
                        // Error or end of stream, wait for requests and tear down
                        <span class="cov8" title="1">pend.Wait()
                        return nil</span>
                }

                // check if server is ordered to shutdown and return an error
                // telling the client that his request failed.
                <span class="cov8" title="1">if atomic.LoadInt32(&amp;s.run) != 1 </span><span class="cov0" title="0">{
                        err = &amp;shutdownError{}
                        if batch </span><span class="cov0" title="0">{
                                resps := make([]interface{}, len(reqs))
                                for i, r := range reqs </span><span class="cov0" title="0">{
                                        resps[i] = codec.CreateErrorResponse(&amp;r.id, err)
                                }</span>
                                <span class="cov0" title="0">codec.Write(resps)</span>
                        }<span class="cov0" title="0"> else {
                                codec.Write(codec.CreateErrorResponse(&amp;reqs[0].id, err))
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                // If a single shot request is executing, run and return immediately
                <span class="cov8" title="1">if singleShot </span><span class="cov8" title="1">{
                        if batch </span><span class="cov0" title="0">{
                                s.execBatch(ctx, codec, reqs)
                        }</span><span class="cov8" title="1"> else {
                                s.exec(ctx, codec, reqs[0])
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
                // For multi-shot connections, start a goroutine to serve and loop back
                <span class="cov8" title="1">pend.Add(1)

                go func(reqs []*serverRequest, batch bool) </span><span class="cov8" title="1">{
                        defer pend.Done()
                        if batch </span><span class="cov8" title="1">{
                                s.execBatch(ctx, codec, reqs)
                        }</span><span class="cov8" title="1"> else {
                                s.exec(ctx, codec, reqs[0])
                        }</span>
                }(reqs, batch)
        }
        <span class="cov0" title="0">return nil</span>
}

// ServeCodec reads incoming requests from codec, calls the appropriate callback and writes the
// response back using the given codec. It will block until the codec is closed or the server is
// stopped. In either case the codec is closed.
func (s *Server) ServeCodec(codec ServerCodec, options CodecOption) <span class="cov8" title="1">{
        defer codec.Close()
        s.serveRequest(codec, false, options)
}</span>

// ServeSingleRequest reads and processes a single RPC request from the given codec. It will not
// close the codec unless a non-recoverable error has occurred. Note, this method will return after
// a single request has been processed!
func (s *Server) ServeSingleRequest(codec ServerCodec, options CodecOption) <span class="cov8" title="1">{
        s.serveRequest(codec, true, options)
}</span>

// Stop will stop reading new requests, wait for stopPendingRequestTimeout to allow pending requests to finish,
// close all codecs which will cancel pending requests/subscriptions.
func (s *Server) Stop() <span class="cov8" title="1">{
        if atomic.CompareAndSwapInt32(&amp;s.run, 1, 0) </span><span class="cov8" title="1">{
                s.codecsMu.Lock()
                defer s.codecsMu.Unlock()
                s.codecs.Each(func(c interface{}) bool </span><span class="cov8" title="1">{
                        c.(ServerCodec).Close()
                        return true
                }</span>)
        }
}

// createSubscription will call the subscription callback and returns the subscription id or error.
func (s *Server) createSubscription(ctx context.Context, c ServerCodec, req *serverRequest) (ID, error) <span class="cov8" title="1">{
        // subscription have as first argument the context following optional arguments
        args := []reflect.Value{req.callb.rcvr, reflect.ValueOf(ctx)}
        args = append(args, req.args...)
        reply := req.callb.method.Func.Call(args)

        if !reply[1].IsNil() </span><span class="cov0" title="0">{ // subscription creation failed
                return "", reply[1].Interface().(error)
        }</span>

        <span class="cov8" title="1">return reply[0].Interface().(*Subscription).ID, nil</span>
}

// handle executes a request and returns the response from the callback.
func (s *Server) handle(ctx context.Context, codec ServerCodec, req *serverRequest) (interface{}, func()) <span class="cov8" title="1">{
        if req.err != nil </span><span class="cov0" title="0">{
                return codec.CreateErrorResponse(&amp;req.id, req.err), nil
        }</span>

        <span class="cov8" title="1">if req.isUnsubscribe </span><span class="cov8" title="1">{ // cancel subscription, first param must be the subscription id
                if len(req.args) &gt;= 1 &amp;&amp; req.args[0].Kind() == reflect.String </span><span class="cov8" title="1">{
                        notifier, supported := NotifierFromContext(ctx)
                        if !supported </span><span class="cov0" title="0">{ // interface doesn't support subscriptions (e.g. http)
                                return codec.CreateErrorResponse(&amp;req.id, &amp;callbackError{ErrNotificationsUnsupported.Error()}), nil
                        }</span>

                        <span class="cov8" title="1">subid := ID(req.args[0].String())
                        if err := notifier.unsubscribe(subid); err != nil </span><span class="cov0" title="0">{
                                return codec.CreateErrorResponse(&amp;req.id, &amp;callbackError{err.Error()}), nil
                        }</span>

                        <span class="cov8" title="1">return codec.CreateResponse(req.id, true), nil</span>
                }
                <span class="cov0" title="0">return codec.CreateErrorResponse(&amp;req.id, &amp;invalidParamsError{"Expected subscription id as first argument"}), nil</span>
        }

        <span class="cov8" title="1">if req.callb.isSubscribe </span><span class="cov8" title="1">{
                subid, err := s.createSubscription(ctx, codec, req)
                if err != nil </span><span class="cov0" title="0">{
                        return codec.CreateErrorResponse(&amp;req.id, &amp;callbackError{err.Error()}), nil
                }</span>

                // active the subscription after the sub id was successfully sent to the client
                <span class="cov8" title="1">activateSub := func() </span><span class="cov8" title="1">{
                        notifier, _ := NotifierFromContext(ctx)
                        notifier.activate(subid, req.svcname)
                }</span>

                <span class="cov8" title="1">return codec.CreateResponse(req.id, subid), activateSub</span>
        }

        // regular RPC call, prepare arguments
        <span class="cov8" title="1">if len(req.args) != len(req.callb.argTypes) </span><span class="cov0" title="0">{
                rpcErr := &amp;invalidParamsError{fmt.Sprintf("%s%s%s expects %d parameters, got %d",
                        req.svcname, serviceMethodSeparator, req.callb.method.Name,
                        len(req.callb.argTypes), len(req.args))}
                return codec.CreateErrorResponse(&amp;req.id, rpcErr), nil
        }</span>

        <span class="cov8" title="1">arguments := []reflect.Value{req.callb.rcvr}
        if req.callb.hasCtx </span><span class="cov8" title="1">{
                arguments = append(arguments, reflect.ValueOf(ctx))
        }</span>
        <span class="cov8" title="1">if len(req.args) &gt; 0 </span><span class="cov8" title="1">{
                arguments = append(arguments, req.args...)
        }</span>

        // execute RPC method and return result
        <span class="cov8" title="1">reply := req.callb.method.Func.Call(arguments)
        if len(reply) == 0 </span><span class="cov8" title="1">{
                return codec.CreateResponse(req.id, nil), nil
        }</span>

        <span class="cov8" title="1">if req.callb.errPos &gt;= 0 </span><span class="cov0" title="0">{ // test if method returned an error
                if !reply[req.callb.errPos].IsNil() </span><span class="cov0" title="0">{
                        e := reply[req.callb.errPos].Interface().(error)
                        res := codec.CreateErrorResponse(&amp;req.id, &amp;callbackError{e.Error()})
                        return res, nil
                }</span>
        }
        <span class="cov8" title="1">return codec.CreateResponse(req.id, reply[0].Interface()), nil</span>
}

// exec executes the given request and writes the result back using the codec.
func (s *Server) exec(ctx context.Context, codec ServerCodec, req *serverRequest) <span class="cov8" title="1">{
        var response interface{}
        var callback func()
        if req.err != nil </span><span class="cov8" title="1">{
                response = codec.CreateErrorResponse(&amp;req.id, req.err)
        }</span><span class="cov8" title="1"> else {
                response, callback = s.handle(ctx, codec, req)
        }</span>

        <span class="cov8" title="1">if err := codec.Write(response); err != nil </span><span class="cov8" title="1">{
                codec.Close()
        }</span>

        // when request was a subscribe request this allows these subscriptions to be actived
        <span class="cov8" title="1">if callback != nil </span><span class="cov8" title="1">{
                callback()
        }</span>
}

// execBatch executes the given requests and writes the result back using the codec.
// It will only write the response back when the last request is processed.
func (s *Server) execBatch(ctx context.Context, codec ServerCodec, requests []*serverRequest) <span class="cov8" title="1">{
        responses := make([]interface{}, len(requests))
        var callbacks []func()
        for i, req := range requests </span><span class="cov8" title="1">{
                if req.err != nil </span><span class="cov8" title="1">{
                        responses[i] = codec.CreateErrorResponse(&amp;req.id, req.err)
                }</span><span class="cov8" title="1"> else {
                        var callback func()
                        if responses[i], callback = s.handle(ctx, codec, req); callback != nil </span><span class="cov8" title="1">{
                                callbacks = append(callbacks, callback)
                        }</span>
                }
        }

        <span class="cov8" title="1">if err := codec.Write(responses); err != nil </span><span class="cov0" title="0">{
                codec.Close()
        }</span>

        // when request holds one of more subscribe requests this allows these subscriptions to be activated
        <span class="cov8" title="1">for _, c := range callbacks </span><span class="cov8" title="1">{
                c()
        }</span>
}

// readRequest requests the next (batch) request from the codec. It will return the collection
// of requests, an indication if the request was a batch, the invalid request identifier and an
// error when the request could not be read/parsed.
func (s *Server) readRequest(codec ServerCodec) ([]*serverRequest, bool, Error) <span class="cov8" title="1">{
        reqs, batch, err := codec.ReadRequestHeaders()
        if err != nil </span><span class="cov8" title="1">{
                return nil, batch, err
        }</span>

        <span class="cov8" title="1">requests := make([]*serverRequest, len(reqs))

        // verify requests
        for i, r := range reqs </span><span class="cov8" title="1">{
                var ok bool
                var svc *service

                if r.err != nil </span><span class="cov8" title="1">{
                        requests[i] = &amp;serverRequest{id: r.id, err: r.err}
                        continue</span>
                }

                <span class="cov8" title="1">if r.isPubSub &amp;&amp; strings.HasSuffix(r.method, unsubscribeMethodSuffix) </span><span class="cov8" title="1">{
                        requests[i] = &amp;serverRequest{id: r.id, isUnsubscribe: true}
                        argTypes := []reflect.Type{reflect.TypeOf("")} // expect subscription id as first arg
                        if args, err := codec.ParseRequestArguments(argTypes, r.params); err == nil </span><span class="cov8" title="1">{
                                requests[i].args = args
                        }</span><span class="cov0" title="0"> else {
                                requests[i].err = &amp;invalidParamsError{err.Error()}
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if svc, ok = s.services[r.service]; !ok </span><span class="cov8" title="1">{ // rpc method isn't available
                        requests[i] = &amp;serverRequest{id: r.id, err: &amp;methodNotFoundError{r.service, r.method}}
                        continue</span>
                }

                <span class="cov8" title="1">if r.isPubSub </span><span class="cov8" title="1">{ // eth_subscribe, r.method contains the subscription method name
                        if callb, ok := svc.subscriptions[r.method]; ok </span><span class="cov8" title="1">{
                                requests[i] = &amp;serverRequest{id: r.id, svcname: svc.name, callb: callb}
                                if r.params != nil &amp;&amp; len(callb.argTypes) &gt; 0 </span><span class="cov8" title="1">{
                                        argTypes := []reflect.Type{reflect.TypeOf("")}
                                        argTypes = append(argTypes, callb.argTypes...)
                                        if args, err := codec.ParseRequestArguments(argTypes, r.params); err == nil </span><span class="cov8" title="1">{
                                                requests[i].args = args[1:] // first one is service.method name which isn't an actual argument
                                        }</span><span class="cov0" title="0"> else {
                                                requests[i].err = &amp;invalidParamsError{err.Error()}
                                        }</span>
                                }
                        }<span class="cov0" title="0"> else {
                                requests[i] = &amp;serverRequest{id: r.id, err: &amp;methodNotFoundError{r.service, r.method}}
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if callb, ok := svc.callbacks[r.method]; ok </span><span class="cov8" title="1">{ // lookup RPC method
                        requests[i] = &amp;serverRequest{id: r.id, svcname: svc.name, callb: callb}
                        if r.params != nil &amp;&amp; len(callb.argTypes) &gt; 0 </span><span class="cov8" title="1">{
                                if args, err := codec.ParseRequestArguments(callb.argTypes, r.params); err == nil </span><span class="cov8" title="1">{
                                        requests[i].args = args
                                }</span><span class="cov0" title="0"> else {
                                        requests[i].err = &amp;invalidParamsError{err.Error()}
                                }</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov0" title="0">requests[i] = &amp;serverRequest{id: r.id, err: &amp;methodNotFoundError{r.service, r.method}}</span>
        }

        <span class="cov8" title="1">return requests, batch, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "context"
        "errors"
        "sync"
)

var (
        // ErrNotificationsUnsupported is returned when the connection doesn't support notifications
        ErrNotificationsUnsupported = errors.New("notifications not supported")
        // ErrNotificationNotFound is returned when the notification for the given id is not found
        ErrSubscriptionNotFound = errors.New("subscription not found")
)

// ID defines a pseudo random number that is used to identify RPC subscriptions.
type ID string

// a Subscription is created by a notifier and tight to that notifier. The client can use
// this subscription to wait for an unsubscribe request for the client, see Err().
type Subscription struct {
        ID        ID
        namespace string
        err       chan error // closed on unsubscribe
}

// Err returns a channel that is closed when the client send an unsubscribe request.
func (s *Subscription) Err() &lt;-chan error <span class="cov8" title="1">{
        return s.err
}</span>

// notifierKey is used to store a notifier within the connection context.
type notifierKey struct{}

// Notifier is tight to a RPC connection that supports subscriptions.
// Server callbacks use the notifier to send notifications.
type Notifier struct {
        codec    ServerCodec
        subMu    sync.RWMutex // guards active and inactive maps
        active   map[ID]*Subscription
        inactive map[ID]*Subscription
}

// newNotifier creates a new notifier that can be used to send subscription
// notifications to the client.
func newNotifier(codec ServerCodec) *Notifier <span class="cov8" title="1">{
        return &amp;Notifier{
                codec:    codec,
                active:   make(map[ID]*Subscription),
                inactive: make(map[ID]*Subscription),
        }
}</span>

// NotifierFromContext returns the Notifier value stored in ctx, if any.
func NotifierFromContext(ctx context.Context) (*Notifier, bool) <span class="cov8" title="1">{
        n, ok := ctx.Value(notifierKey{}).(*Notifier)
        return n, ok
}</span>

// CreateSubscription returns a new subscription that is coupled to the
// RPC connection. By default subscriptions are inactive and notifications
// are dropped until the subscription is marked as active. This is done
// by the RPC server after the subscription ID is send to the client.
func (n *Notifier) CreateSubscription() *Subscription <span class="cov8" title="1">{
        s := &amp;Subscription{ID: NewID(), err: make(chan error)}
        n.subMu.Lock()
        n.inactive[s.ID] = s
        n.subMu.Unlock()
        return s
}</span>

// Notify sends a notification to the client with the given data as payload.
// If an error occurs the RPC connection is closed and the error is returned.
func (n *Notifier) Notify(id ID, data interface{}) error <span class="cov8" title="1">{
        n.subMu.RLock()
        defer n.subMu.RUnlock()

        sub, active := n.active[id]
        if active </span><span class="cov8" title="1">{
                notification := n.codec.CreateNotification(string(id), sub.namespace, data)
                if err := n.codec.Write(notification); err != nil </span><span class="cov8" title="1">{
                        n.codec.Close()
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Closed returns a channel that is closed when the RPC connection is closed.
func (n *Notifier) Closed() &lt;-chan interface{} <span class="cov8" title="1">{
        return n.codec.Closed()
}</span>

// unsubscribe a subscription.
// If the subscription could not be found ErrSubscriptionNotFound is returned.
func (n *Notifier) unsubscribe(id ID) error <span class="cov8" title="1">{
        n.subMu.Lock()
        defer n.subMu.Unlock()
        if s, found := n.active[id]; found </span><span class="cov8" title="1">{
                close(s.err)
                delete(n.active, id)
                return nil
        }</span>
        <span class="cov0" title="0">return ErrSubscriptionNotFound</span>
}

// activate enables a subscription. Until a subscription is enabled all
// notifications are dropped. This method is called by the RPC server after
// the subscription ID was sent to client. This prevents notifications being
// send to the client before the subscription ID is send to the client.
func (n *Notifier) activate(id ID, namespace string) <span class="cov8" title="1">{
        n.subMu.Lock()
        defer n.subMu.Unlock()
        if sub, found := n.inactive[id]; found </span><span class="cov8" title="1">{
                sub.namespace = namespace
                n.active[id] = sub
                delete(n.inactive, id)
        }</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "fmt"
        "math"
        "reflect"
        "strings"
        "sync"

        "github.com/ethereum/go-ethereum/common/hexutil"
        "gopkg.in/fatih/set.v0"
)

// API describes the set of methods offered over the RPC interface
type API struct {
        Namespace string      // namespace under which the rpc methods of Service are exposed
        Version   string      // api version for DApp's
        Service   interface{} // receiver instance which holds the methods
        Public    bool        // indication if the methods must be considered safe for public use
}

// callback is a method callback which was registered in the server
type callback struct {
        rcvr        reflect.Value  // receiver of method
        method      reflect.Method // callback
        argTypes    []reflect.Type // input argument types
        hasCtx      bool           // method's first argument is a context (not included in argTypes)
        errPos      int            // err return idx, of -1 when method cannot return error
        isSubscribe bool           // indication if the callback is a subscription
}

// service represents a registered object
type service struct {
        name          string        // name for service
        typ           reflect.Type  // receiver type
        callbacks     callbacks     // registered handlers
        subscriptions subscriptions // available subscriptions/notifications
}

// serverRequest is an incoming request
type serverRequest struct {
        id            interface{}
        svcname       string
        callb         *callback
        args          []reflect.Value
        isUnsubscribe bool
        err           Error
}

type serviceRegistry map[string]*service // collection of services
type callbacks map[string]*callback      // collection of RPC callbacks
type subscriptions map[string]*callback  // collection of subscription callbacks

// Server represents a RPC server
type Server struct {
        services serviceRegistry

        run      int32
        codecsMu sync.Mutex
        codecs   *set.Set
}

// rpcRequest represents a raw incoming RPC request
type rpcRequest struct {
        service  string
        method   string
        id       interface{}
        isPubSub bool
        params   interface{}
        err      Error // invalid batch element
}

// Error wraps RPC errors, which contain an error code in addition to the message.
type Error interface {
        Error() string  // returns the message
        ErrorCode() int // returns the code
}

// ServerCodec implements reading, parsing and writing RPC messages for the server side of
// a RPC session. Implementations must be go-routine safe since the codec can be called in
// multiple go-routines concurrently.
type ServerCodec interface {
        // Read next request
        ReadRequestHeaders() ([]rpcRequest, bool, Error)
        // Parse request argument to the given types
        ParseRequestArguments(argTypes []reflect.Type, params interface{}) ([]reflect.Value, Error)
        // Assemble success response, expects response id and payload
        CreateResponse(id interface{}, reply interface{}) interface{}
        // Assemble error response, expects response id and error
        CreateErrorResponse(id interface{}, err Error) interface{}
        // Assemble error response with extra information about the error through info
        CreateErrorResponseWithInfo(id interface{}, err Error, info interface{}) interface{}
        // Create notification response
        CreateNotification(id, namespace string, event interface{}) interface{}
        // Write msg to client.
        Write(msg interface{}) error
        // Close underlying data stream
        Close()
        // Closed when underlying connection is closed
        Closed() &lt;-chan interface{}
}

type BlockNumber int64

const (
        PendingBlockNumber  = BlockNumber(-2)
        LatestBlockNumber   = BlockNumber(-1)
        EarliestBlockNumber = BlockNumber(0)
)

// UnmarshalJSON parses the given JSON fragment into a BlockNumber. It supports:
// - "latest", "earliest" or "pending" as string arguments
// - the block number
// Returned errors:
// - an invalid block number error when the given argument isn't a known strings
// - an out of range error when the given block number is either too little or too large
func (bn *BlockNumber) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        input := strings.TrimSpace(string(data))
        if len(input) &gt;= 2 &amp;&amp; input[0] == '"' &amp;&amp; input[len(input)-1] == '"' </span><span class="cov8" title="1">{
                input = input[1 : len(input)-1]
        }</span>

        <span class="cov8" title="1">switch input </span>{
        case "earliest":<span class="cov8" title="1">
                *bn = EarliestBlockNumber
                return nil</span>
        case "latest":<span class="cov8" title="1">
                *bn = LatestBlockNumber
                return nil</span>
        case "pending":<span class="cov8" title="1">
                *bn = PendingBlockNumber
                return nil</span>
        }

        <span class="cov8" title="1">blckNum, err := hexutil.DecodeUint64(input)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if blckNum &gt; math.MaxInt64 </span><span class="cov8" title="1">{
                return fmt.Errorf("Blocknumber too high")
        }</span>

        <span class="cov8" title="1">*bn = BlockNumber(blckNum)
        return nil</span>
}

func (bn BlockNumber) Int64() int64 <span class="cov0" title="0">{
        return (int64)(bn)
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "bufio"
        "context"
        crand "crypto/rand"
        "encoding/binary"
        "encoding/hex"
        "math/big"
        "math/rand"
        "reflect"
        "strings"
        "sync"
        "time"
        "unicode"
        "unicode/utf8"
)

var (
        subscriptionIDGenMu sync.Mutex
        subscriptionIDGen   = idGenerator()
)

// Is this an exported - upper case - name?
func isExported(name string) bool <span class="cov8" title="1">{
        rune, _ := utf8.DecodeRuneInString(name)
        return unicode.IsUpper(rune)
}</span>

// Is this type exported or a builtin?
func isExportedOrBuiltinType(t reflect.Type) bool <span class="cov8" title="1">{
        for t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>
        // PkgPath will be non-empty even for an exported type,
        // so we need to check the type name as well.
        <span class="cov8" title="1">return isExported(t.Name()) || t.PkgPath() == ""</span>
}

var contextType = reflect.TypeOf((*context.Context)(nil)).Elem()

// isContextType returns an indication if the given t is of context.Context or *context.Context type
func isContextType(t reflect.Type) bool <span class="cov8" title="1">{
        for t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">return t == contextType</span>
}

var errorType = reflect.TypeOf((*error)(nil)).Elem()

// Implements this type the error interface
func isErrorType(t reflect.Type) bool <span class="cov8" title="1">{
        for t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">return t.Implements(errorType)</span>
}

var subscriptionType = reflect.TypeOf((*Subscription)(nil)).Elem()

// isSubscriptionType returns an indication if the given t is of Subscription or *Subscription type
func isSubscriptionType(t reflect.Type) bool <span class="cov8" title="1">{
        for t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">return t == subscriptionType</span>
}

// isPubSub tests whether the given method has as as first argument a context.Context
// and returns the pair (Subscription, error)
func isPubSub(methodType reflect.Type) bool <span class="cov8" title="1">{
        // numIn(0) is the receiver type
        if methodType.NumIn() &lt; 2 || methodType.NumOut() != 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return isContextType(methodType.In(1)) &amp;&amp;
                isSubscriptionType(methodType.Out(0)) &amp;&amp;
                isErrorType(methodType.Out(1))</span>
}

// formatName will convert to first character to lower case
func formatName(name string) string <span class="cov8" title="1">{
        ret := []rune(name)
        if len(ret) &gt; 0 </span><span class="cov8" title="1">{
                ret[0] = unicode.ToLower(ret[0])
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}

var bigIntType = reflect.TypeOf((*big.Int)(nil)).Elem()

// Indication if this type should be serialized in hex
func isHexNum(t reflect.Type) bool <span class="cov8" title="1">{
        if t == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">return t == bigIntType</span>
}

// suitableCallbacks iterates over the methods of the given type. It will determine if a method satisfies the criteria
// for a RPC callback or a subscription callback and adds it to the collection of callbacks or subscriptions. See server
// documentation for a summary of these criteria.
func suitableCallbacks(rcvr reflect.Value, typ reflect.Type) (callbacks, subscriptions) <span class="cov8" title="1">{
        callbacks := make(callbacks)
        subscriptions := make(subscriptions)

METHODS:
        for m := 0; m &lt; typ.NumMethod(); m++ </span><span class="cov8" title="1">{
                method := typ.Method(m)
                mtype := method.Type
                mname := formatName(method.Name)
                if method.PkgPath != "" </span><span class="cov0" title="0">{ // method must be exported
                        continue</span>
                }

                <span class="cov8" title="1">var h callback
                h.isSubscribe = isPubSub(mtype)
                h.rcvr = rcvr
                h.method = method
                h.errPos = -1

                firstArg := 1
                numIn := mtype.NumIn()
                if numIn &gt;= 2 &amp;&amp; mtype.In(1) == contextType </span><span class="cov8" title="1">{
                        h.hasCtx = true
                        firstArg = 2
                }</span>

                <span class="cov8" title="1">if h.isSubscribe </span><span class="cov8" title="1">{
                        h.argTypes = make([]reflect.Type, numIn-firstArg) // skip rcvr type
                        for i := firstArg; i &lt; numIn; i++ </span><span class="cov8" title="1">{
                                argType := mtype.In(i)
                                if isExportedOrBuiltinType(argType) </span><span class="cov8" title="1">{
                                        h.argTypes[i-firstArg] = argType
                                }</span><span class="cov0" title="0"> else {
                                        continue METHODS</span>
                                }
                        }

                        <span class="cov8" title="1">subscriptions[mname] = &amp;h
                        continue METHODS</span>
                }

                // determine method arguments, ignore first arg since it's the receiver type
                // Arguments must be exported or builtin types
                <span class="cov8" title="1">h.argTypes = make([]reflect.Type, numIn-firstArg)
                for i := firstArg; i &lt; numIn; i++ </span><span class="cov8" title="1">{
                        argType := mtype.In(i)
                        if !isExportedOrBuiltinType(argType) </span><span class="cov0" title="0">{
                                continue METHODS</span>
                        }
                        <span class="cov8" title="1">h.argTypes[i-firstArg] = argType</span>
                }

                // check that all returned values are exported or builtin types
                <span class="cov8" title="1">for i := 0; i &lt; mtype.NumOut(); i++ </span><span class="cov8" title="1">{
                        if !isExportedOrBuiltinType(mtype.Out(i)) </span><span class="cov0" title="0">{
                                continue METHODS</span>
                        }
                }

                // when a method returns an error it must be the last returned value
                <span class="cov8" title="1">h.errPos = -1
                for i := 0; i &lt; mtype.NumOut(); i++ </span><span class="cov8" title="1">{
                        if isErrorType(mtype.Out(i)) </span><span class="cov8" title="1">{
                                h.errPos = i
                                break</span>
                        }
                }

                <span class="cov8" title="1">if h.errPos &gt;= 0 &amp;&amp; h.errPos != mtype.NumOut()-1 </span><span class="cov8" title="1">{
                        continue METHODS</span>
                }

                <span class="cov8" title="1">switch mtype.NumOut() </span>{
                case 0, 1, 2:<span class="cov8" title="1">
                        if mtype.NumOut() == 2 &amp;&amp; h.errPos == -1 </span><span class="cov8" title="1">{ // method must one return value and 1 error
                                continue METHODS</span>
                        }
                        <span class="cov8" title="1">callbacks[mname] = &amp;h</span>
                }
        }

        <span class="cov8" title="1">return callbacks, subscriptions</span>
}

// idGenerator helper utility that generates a (pseudo) random sequence of
// bytes that are used to generate identifiers.
func idGenerator() *rand.Rand <span class="cov8" title="1">{
        if seed, err := binary.ReadVarint(bufio.NewReader(crand.Reader)); err == nil </span><span class="cov8" title="1">{
                return rand.New(rand.NewSource(seed))
        }</span>
        <span class="cov0" title="0">return rand.New(rand.NewSource(int64(time.Now().Nanosecond())))</span>
}

// NewID generates a identifier that can be used as an identifier in the RPC interface.
// e.g. filter and subscription identifier.
func NewID() ID <span class="cov8" title="1">{
        subscriptionIDGenMu.Lock()
        defer subscriptionIDGenMu.Unlock()

        id := make([]byte, 16)
        for i := 0; i &lt; len(id); i += 7 </span><span class="cov8" title="1">{
                val := subscriptionIDGen.Int63()
                for j := 0; i+j &lt; len(id) &amp;&amp; j &lt; 7; j++ </span><span class="cov8" title="1">{
                        id[i+j] = byte(val)
                        val &gt;&gt;= 8
                }</span>
        }

        <span class="cov8" title="1">rpcId := hex.EncodeToString(id)
        // rpc ID's are RPC quantities, no leading zero's and 0 is 0x0
        rpcId = strings.TrimLeft(rpcId, "0")
        if rpcId == "" </span><span class="cov0" title="0">{
                rpcId = "0"
        }</span>

        <span class="cov8" title="1">return ID("0x" + rpcId)</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package rpc

import (
        "context"
        "crypto/tls"
        "fmt"
        "net"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        "golang.org/x/net/websocket"
        "gopkg.in/fatih/set.v0"
)

// WebsocketHandler returns a handler that serves JSON-RPC to WebSocket connections.
//
// allowedOrigins should be a comma-separated list of allowed origin URLs.
// To allow connections with any origin, pass "*".
func (srv *Server) WebsocketHandler(allowedOrigins []string) http.Handler <span class="cov8" title="1">{
        return websocket.Server{
                Handshake: wsHandshakeValidator(allowedOrigins),
                Handler: func(conn *websocket.Conn) </span><span class="cov8" title="1">{
                        srv.ServeCodec(NewJSONCodec(conn), OptionMethodInvocation|OptionSubscriptions)
                }</span>,
        }
}

// NewWSServer creates a new websocket RPC server around an API provider.
//
// Deprecated: use Server.WebsocketHandler
func NewWSServer(allowedOrigins []string, srv *Server) *http.Server <span class="cov0" title="0">{
        return &amp;http.Server{Handler: srv.WebsocketHandler(allowedOrigins)}
}</span>

// wsHandshakeValidator returns a handler that verifies the origin during the
// websocket upgrade process. When a '*' is specified as an allowed origins all
// connections are accepted.
func wsHandshakeValidator(allowedOrigins []string) func(*websocket.Config, *http.Request) error <span class="cov8" title="1">{
        origins := set.New()
        allowAllOrigins := false

        for _, origin := range allowedOrigins </span><span class="cov8" title="1">{
                if origin == "*" </span><span class="cov8" title="1">{
                        allowAllOrigins = true
                }</span>
                <span class="cov8" title="1">if origin != "" </span><span class="cov8" title="1">{
                        origins.Add(strings.ToLower(origin))
                }</span>
        }

        // allow localhost if no allowedOrigins are specified.
        <span class="cov8" title="1">if len(origins.List()) == 0 </span><span class="cov0" title="0">{
                origins.Add("http://localhost")
                if hostname, err := os.Hostname(); err == nil </span><span class="cov0" title="0">{
                        origins.Add("http://" + strings.ToLower(hostname))
                }</span>
        }

        <span class="cov8" title="1">f := func(cfg *websocket.Config, req *http.Request) error </span><span class="cov8" title="1">{
                origin := strings.ToLower(req.Header.Get("Origin"))
                if allowAllOrigins || origins.Has(origin) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("origin %s not allowed", origin)</span>
        }

        <span class="cov8" title="1">return f</span>
}

// DialWebsocket creates a new RPC client that communicates with a JSON-RPC server
// that is listening on the given endpoint.
//
// The context is used for the initial connection establishment. It does not
// affect subsequent interactions with the client.
func DialWebsocket(ctx context.Context, endpoint, origin string) (*Client, error) <span class="cov8" title="1">{
        if origin == "" </span><span class="cov8" title="1">{
                var err error
                if origin, err = os.Hostname(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(endpoint, "wss") </span><span class="cov0" title="0">{
                        origin = "https://" + strings.ToLower(origin)
                }</span><span class="cov8" title="1"> else {
                        origin = "http://" + strings.ToLower(origin)
                }</span>
        }
        <span class="cov8" title="1">config, err := websocket.NewConfig(endpoint, origin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return newClient(ctx, func(ctx context.Context) (net.Conn, error) </span><span class="cov8" title="1">{
                return wsDialContext(ctx, config)
        }</span>)
}

func wsDialContext(ctx context.Context, config *websocket.Config) (*websocket.Conn, error) <span class="cov8" title="1">{
        var conn net.Conn
        var err error
        switch config.Location.Scheme </span>{
        case "ws":<span class="cov8" title="1">
                conn, err = dialContext(ctx, "tcp", wsDialAddress(config.Location))</span>
        case "wss":<span class="cov0" title="0">
                dialer := contextDialer(ctx)
                conn, err = tls.DialWithDialer(dialer, "tcp", wsDialAddress(config.Location), config.TlsConfig)</span>
        default:<span class="cov0" title="0">
                err = websocket.ErrBadScheme</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ws, err := websocket.NewClient(config, conn)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, err
        }</span>
        <span class="cov8" title="1">return ws, err</span>
}

var wsPortMap = map[string]string{"ws": "80", "wss": "443"}

func wsDialAddress(location *url.URL) string <span class="cov8" title="1">{
        if _, ok := wsPortMap[location.Scheme]; ok </span><span class="cov8" title="1">{
                if _, _, err := net.SplitHostPort(location.Host); err != nil </span><span class="cov0" title="0">{
                        return net.JoinHostPort(location.Host, wsPortMap[location.Scheme])
                }</span>
        }
        <span class="cov8" title="1">return location.Host</span>
}

func dialContext(ctx context.Context, network, addr string) (net.Conn, error) <span class="cov8" title="1">{
        d := &amp;net.Dialer{KeepAlive: tcpKeepAliveInterval}
        return d.DialContext(ctx, network, addr)
}</span>

func contextDialer(ctx context.Context) *net.Dialer <span class="cov0" title="0">{
        dialer := &amp;net.Dialer{Cancel: ctx.Done(), KeepAlive: tcpKeepAliveInterval}
        if deadline, ok := ctx.Deadline(); ok </span><span class="cov0" title="0">{
                dialer.Deadline = deadline
        }</span><span class="cov0" title="0"> else {
                dialer.Deadline = time.Now().Add(defaultDialTimeout)
        }</span>
        <span class="cov0" title="0">return dialer</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rpc

import (
        "encoding/json"
        "net"
        "net/rpc"
)

var jErrRequest = json.RawMessage(`{"jsonrpc":"2.0","id":null,"error":{"code":-32600,"message":"invalid request"}}`)

// JSONRPC2 is an internal RPC service used to process batch requests.
type JSONRPC2 struct{}

// BatchArg is a param for internal RPC JSONRPC2.Batch.
type BatchArg struct {
        srv  *rpc.Server
        reqs []*json.RawMessage
}

// Batch is an internal RPC method used to process batch requests.
func (JSONRPC2) Batch(arg BatchArg, replies *[]*json.RawMessage) (err error) <span class="cov0" title="0">{
        cli, srv := net.Pipe()
        defer cli.Close()
        go arg.srv.ServeCodec(NewJSONCodec(srv, arg.srv))

        replyc := make(chan *json.RawMessage, len(arg.reqs))
        donec := make(chan struct{}, 1)

        go func() </span><span class="cov0" title="0">{
                dec := json.NewDecoder(cli)
                *replies = make([]*json.RawMessage, 0, len(arg.reqs))
                for reply := range replyc </span><span class="cov0" title="0">{
                        if reply != nil </span><span class="cov0" title="0">{
                                *replies = append(*replies, reply)
                        }</span><span class="cov0" title="0"> else {
                                *replies = append(*replies, new(json.RawMessage))
                                if dec.Decode((*replies)[len(*replies)-1]) != nil </span><span class="cov0" title="0">{
                                        (*replies)[len(*replies)-1] = &amp;jErrRequest
                                }</span>
                        }
                }
                <span class="cov0" title="0">donec &lt;- struct{}{}</span>
        }()

        <span class="cov0" title="0">var testreq jsonRequest
        for _, req := range arg.reqs </span><span class="cov0" title="0">{
                if req == nil || json.Unmarshal(*req, &amp;testreq) != nil </span><span class="cov0" title="0">{
                        replyc &lt;- &amp;jErrRequest
                }</span><span class="cov0" title="0"> else {
                        if testreq.ID != nil </span><span class="cov0" title="0">{
                                replyc &lt;- nil
                        }</span>
                        <span class="cov0" title="0">if _, err = cli.Write(append(*req, '\n')); err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">close(replyc)
        &lt;-donec
        return</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rpc

import (
        "encoding/json"
        "errors"
        "io"
        "math"
        "net"
        "net/rpc"
        "reflect"
        "sync"
)

const seqNotify = math.MaxUint64

type clientCodec struct {
        dec *json.Decoder // for reading JSON values
        enc *json.Encoder // for writing JSON values
        c   io.Closer

        // temporary work space
        resp clientResponse

        // JSON-RPC responses include the request id but not the request method.
        // Package rpc expects both.
        // We save the request method in pending when sending a request
        // and then look it up by request ID when filling out the rpc Response.
        mutex   sync.Mutex        // protects pending
        pending map[uint64]string // map request id to method name
}

// NewClientCodec returns a new rpc.ClientCodec using JSON-RPC 2.0 on conn.
func NewClientCodec(conn io.ReadWriteCloser) rpc.ClientCodec <span class="cov0" title="0">{
        return &amp;clientCodec{
                dec:     json.NewDecoder(conn),
                enc:     json.NewEncoder(conn),
                c:       conn,
                pending: make(map[uint64]string),
        }
}</span>

type clientRequest struct {
        Version string         `json:"jsonrpc"`
        Method  string         `json:"method"`
        Params  [1]interface{} `json:"params,omitempty"`
        ID      *uint64        `json:"id,omitempty"`
}

func (c *clientCodec) WriteRequest(r *rpc.Request, param interface{}) error <span class="cov0" title="0">{
        // If return error: it will be returned as is for this call.
        // Allow param to be only Array, Slice, Map or Struct.
        // When param is nil or uninitialized Map or Slice - omit "params".
        if param != nil </span><span class="cov0" title="0">{
                switch k := reflect.TypeOf(param).Kind(); k </span>{
                case reflect.Map:<span class="cov0" title="0">
                        if reflect.TypeOf(param).Key().Kind() == reflect.String </span><span class="cov0" title="0">{
                                if reflect.ValueOf(param).IsNil() </span><span class="cov0" title="0">{
                                        param = nil
                                }</span>
                        }
                case reflect.Slice:<span class="cov0" title="0">
                        if reflect.ValueOf(param).IsNil() </span><span class="cov0" title="0">{
                                param = nil
                        }</span>
                case reflect.Array, reflect.Struct:</span><span class="cov0" title="0">
                case reflect.Ptr:<span class="cov0" title="0">
                        switch k := reflect.TypeOf(param).Elem().Kind(); k </span>{
                        case reflect.Map:<span class="cov0" title="0">
                                if reflect.TypeOf(param).Elem().Key().Kind() == reflect.String </span><span class="cov0" title="0">{
                                        if reflect.ValueOf(param).Elem().IsNil() </span><span class="cov0" title="0">{
                                                param = nil
                                        }</span>
                                }
                        case reflect.Slice:<span class="cov0" title="0">
                                if reflect.ValueOf(param).Elem().IsNil() </span><span class="cov0" title="0">{
                                        param = nil
                                }</span>
                        case reflect.Array, reflect.Struct, reflect.String, reflect.Ptr, reflect.Interface:</span><span class="cov0" title="0">
                        default:<span class="cov0" title="0">
                                return NewError(errInternal.Code, "unsupported param type: Ptr to "+k.String())</span>
                        }
                default:<span class="cov0" title="0">
                        return NewError(errInternal.Code, "unsupported param type: "+k.String())</span>
                }
        }

        <span class="cov0" title="0">var req clientRequest
        if r.Seq != seqNotify </span><span class="cov0" title="0">{
                c.mutex.Lock()
                c.pending[r.Seq] = r.ServiceMethod
                c.mutex.Unlock()
                req.ID = &amp;r.Seq
        }</span>
        <span class="cov0" title="0">req.Version = jsonrpcVersion
        req.Method = r.ServiceMethod
        req.Params[0] = param
        if err := c.enc.Encode(&amp;req); err != nil </span><span class="cov0" title="0">{
                return NewError(errInternal.Code, err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type clientResponse struct {
        Version string           `json:"jsonrpc"`
        ID      *uint64          `json:"id"`
        Result  *json.RawMessage `json:"result,omitempty"`
        Error   *Error           `json:"error,omitempty"`
}

func (r *clientResponse) reset() <span class="cov0" title="0">{
        r.Version = ""
        r.ID = nil
        r.Result = nil
        r.Error = nil
}</span>

func (r *clientResponse) UnmarshalJSON(raw []byte) error <span class="cov0" title="0">{
        r.reset()
        type resp *clientResponse
        if err := json.Unmarshal(raw, resp(r)); err != nil </span><span class="cov0" title="0">{
                return errors.New("bad response: " + string(raw))
        }</span>

        <span class="cov0" title="0">var respMap = make(map[string]*json.RawMessage)
        if err := json.Unmarshal(raw, &amp;respMap); err != nil </span><span class="cov0" title="0">{
                return errors.New("bad response: " + string(raw))
        }</span>
        <span class="cov0" title="0">_, okVer := respMap["jsonrpc"]
        _, okID := respMap["id"]
        _, okRes := respMap["result"]
        _, okErr := respMap["error"]
        if !okVer || !okID || !(okRes || okErr) || (okRes &amp;&amp; okErr) || len(respMap) &gt; 3 </span><span class="cov0" title="0">{
                return errors.New("bad response: " + string(raw))
        }</span>
        <span class="cov0" title="0">if r.Version != jsonrpcVersion </span><span class="cov0" title="0">{
                return errors.New("bad response: " + string(raw))
        }</span>
        <span class="cov0" title="0">if okRes &amp;&amp; r.Result == nil </span><span class="cov0" title="0">{
                r.Result = &amp;null
        }</span>
        <span class="cov0" title="0">if okErr </span><span class="cov0" title="0">{
                if respMap["error"] == nil </span><span class="cov0" title="0">{
                        return errors.New("bad response: " + string(raw))
                }</span>
                <span class="cov0" title="0">oe := make(map[string]*json.RawMessage)
                if err := json.Unmarshal(*respMap["error"], &amp;oe); err != nil </span><span class="cov0" title="0">{
                        return errors.New("bad response: " + string(raw))
                }</span>
                <span class="cov0" title="0">if oe["code"] == nil || oe["message"] == nil </span><span class="cov0" title="0">{
                        return errors.New("bad response: " + string(raw))
                }</span>
                <span class="cov0" title="0">if _, ok := oe["data"]; (!ok &amp;&amp; len(oe) &gt; 2) || len(oe) &gt; 3 </span><span class="cov0" title="0">{
                        return errors.New("bad response: " + string(raw))
                }</span>
        }
        <span class="cov0" title="0">if respMap["id"] == nil &amp;&amp; !okErr </span><span class="cov0" title="0">{
                return errors.New("bad response: " + string(raw))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *clientCodec) ReadResponseHeader(r *rpc.Response) error <span class="cov0" title="0">{
        // If return err:
        // - io.EOF will became ErrShutdown or io.ErrUnexpectedEOF
        // - it will be returned as is for all pending calls
        // - client will be shutdown
        // So, return io.EOF as is, return *Error for all other errors.
        if err := c.dec.Decode(&amp;c.resp); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return NewError(errInternal.Code, err.Error())</span>
        }
        <span class="cov0" title="0">if c.resp.ID == nil </span><span class="cov0" title="0">{
                return c.resp.Error
        }</span>

        <span class="cov0" title="0">c.mutex.Lock()
        r.ServiceMethod = c.pending[*c.resp.ID]
        delete(c.pending, *c.resp.ID)
        c.mutex.Unlock()

        r.Error = ""
        r.Seq = *c.resp.ID
        if c.resp.Error != nil </span><span class="cov0" title="0">{
                r.Error = c.resp.Error.Error()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *clientCodec) ReadResponseBody(x interface{}) error <span class="cov0" title="0">{
        // If x!=nil and return error e:
        // - this call get e.Error() appended to "reading body "
        // - other pending calls get error as is XXX actually other calls
        //   shouldn't be affected by this error at all, so let's at least
        //   provide different error message for other calls
        if x == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(*c.resp.Result, x); err != nil </span><span class="cov0" title="0">{
                e := NewError(errInternal.Code, err.Error())
                e.Data = NewError(errInternal.Code, "some other Call failed to unmarshal Reply")
                return e
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *clientCodec) Close() error <span class="cov0" title="0">{
        return c.c.Close()
}</span>

// Client represents a JSON RPC 2.0 Client.
// There may be multiple outstanding Calls associated
// with a single Client, and a Client may be used by
// multiple goroutines simultaneously.
//
// It also provides all methods of net/rpc Client.
type Client struct {
        *rpc.Client
        codec rpc.ClientCodec
}

// Notify try to invoke the named function. It return error only in case
// it wasn't able to send request.
func (c Client) Notify(serviceMethod string, args interface{}) error <span class="cov0" title="0">{
        req := &amp;rpc.Request{
                ServiceMethod: serviceMethod,
                Seq:           seqNotify,
        }
        return c.codec.WriteRequest(req, args)
}</span>

// NewClient returns a new Client to handle requests to the
// set of services at the other end of the connection.
func NewClient(conn io.ReadWriteCloser) *Client <span class="cov0" title="0">{
        return NewClientWithCodec(NewClientCodec(conn))
}</span>

// NewClientWithCodec returns a new Client using the given rpc.ClientCodec.
func NewClientWithCodec(codec rpc.ClientCodec) *Client <span class="cov0" title="0">{
        client := rpc.NewClientWithCodec(codec)
        return &amp;Client{client, codec}
}</span>

// Dial connects to a JSON-RPC 2.0 server at the specified network address.
func Dial(network, address string) (*Client, error) <span class="cov0" title="0">{
        conn, err := net.Dial(network, address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewClient(conn), err</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rpc

import (
        "encoding/json"
        "fmt"
        "strings"
)

var (
        errServer      = NewError(-32000, "Server error")
        errServerError = NewError(-32001, "Jsonrpc2.Error: json.Marshal failed")
        errRequest     = NewError(-32600, "Invalid request")
        errMethod      = NewError(-32601, "Method not found")
        errParams      = NewError(-32602, "Invalid params")
        errInternal    = NewError(-32603, "Internal error")
        errParse       = NewError(-32700, "Parse error")
)

// Error represent JSON-RPC 2.0 "Error object".
type Error struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// NewError returns an Error with given code and message.
func NewError(code int, message string) *Error <span class="cov8" title="1">{
        return &amp;Error{Code: code, Message: message}
}</span>

// newError returns an Error with auto-detected code for given message.
func newError(message string) *Error <span class="cov8" title="1">{
        switch </span>{
        case strings.HasPrefix(message, "rpc: service/method request ill-formed"):<span class="cov0" title="0">
                return NewError(errMethod.Code, message)</span>
        case strings.HasPrefix(message, "rpc: can't find service"):<span class="cov0" title="0">
                return NewError(errMethod.Code, message)</span>
        case strings.HasPrefix(message, "rpc: can't find method"):<span class="cov0" title="0">
                return NewError(errMethod.Code, message)</span>
        default:<span class="cov8" title="1">
                return NewError(errServer.Code, message)</span>
        }
}

// ServerError convert errors returned by Client.Call() into Error.
// User should check for rpc.ErrShutdown and io.ErrUnexpectedEOF before
// calling ServerError.
func ServerError(rpcerr error) *Error <span class="cov0" title="0">{
        if rpcerr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if err, ok := rpcerr.(*Error); ok </span><span class="cov0" title="0">{
                if err.Code == errInternal.Code &amp;&amp; err.Data != nil </span><span class="cov0" title="0">{
                        if err2, ok := err.Data.(*Error); ok </span><span class="cov0" title="0">{
                                // Use alternate error when ReadResponseBody fail on other call.
                                return err2
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">keepData := true
        errmsg := rpcerr.Error()
        if s := strings.Index(errmsg, "{"); strings.HasPrefix(errmsg, "reading ") &amp;&amp; s != -1 &amp;&amp; strings.HasSuffix(errmsg, "}") </span><span class="cov0" title="0">{
                // ReadResponseBody fail on this call.
                errmsg = errmsg[s:]
                keepData = false
        }</span>
        <span class="cov0" title="0">e := &amp;Error{}
        err := json.Unmarshal([]byte(errmsg), e)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("not a jsonrpc2 error: %s (%#q)", err, rpcerr))</span>
        }
        <span class="cov0" title="0">if e.Code == errInternal.Code &amp;&amp; e.Data != nil &amp;&amp; !keepData </span><span class="cov0" title="0">{
                // ReadResponseBody fail on this call.
                e.Data = nil
        }</span>
        <span class="cov0" title="0">return e</span>
}

// Error returns JSON representation of Error.
func (e *Error) Error() string <span class="cov8" title="1">{
        buf, err := json.Marshal(e)
        if err != nil </span><span class="cov0" title="0">{
                msg, err := json.Marshal(err.Error())
                if err != nil </span><span class="cov0" title="0">{
                        msg = []byte(`"` + errServerError.Message + `"`)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf(`{"code":%d,"message":%s}`, errServerError.Code, string(msg))</span>
        }
        <span class="cov8" title="1">return string(buf)</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package rpc

import (
        "errors"
        "io"
        "net"
        "net/http"
        "net/rpc"
        "strings"

        "github.com/rs/cors"
)

var (
        // ErrInvalidHost will be returned when the host is not in the whitelist
        ErrInvalidHost = errors.New("invalid host name")
)

// HTTPServer represents a HTTP RPC server
type HTTPServer struct {
        rpc *rpc.Server
}

// NewHTTPServer returns a new HttpServer and a http handler used by cors
func NewHTTPServer(whitehosts []string, corsList []string) (*HTTPServer, *hostFilter) <span class="cov8" title="1">{
        server := &amp;HTTPServer{
                rpc: &amp;rpc.Server{},
        }
        // cors
        c := cors.New(cors.Options{
                AllowedOrigins: corsList,
                AllowedMethods: []string{http.MethodPost, http.MethodConnect},
                AllowedHeaders: []string{"*"},
                MaxAge:         600,
        })

        // whitelist
        wMap := make(map[string]struct{})
        for _, whitehost := range whitehosts </span><span class="cov8" title="1">{
                wMap[strings.ToLower(whitehost)] = struct{}{}
        }</span>
        <span class="cov8" title="1">hFilter := hostFilter{wMap, c.Handler(server)}

        return server, &amp;hFilter</span>
}

// ServeHTTP implements an http.Handler that answers RPC requests.
// Supports POST and CONNECT http method.
// POST handles requests from the browser
// CONNECT handles requests form other go rpc.Client
func (server *HTTPServer) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        switch req.Method </span>{
        case http.MethodConnect:<span class="cov0" title="0">
                server.rpc.ServeHTTP(w, req)</span>
        case http.MethodPost:<span class="cov8" title="1">
                w.Header().Set("Content-Type", "application/json")
                conn := &amp;httpReadWriteCloser{req.Body, w}
                server.rpc.ServeRequest(NewJSONCodec(conn, server.rpc))</span>
        default:<span class="cov8" title="1">
                w.Header().Set("Content-Type", "text/plain; charset=utf-8")
                w.WriteHeader(http.StatusMethodNotAllowed)
                io.WriteString(w, "405 must POST or CONNECT\n")</span>
        }
}

// GetRPCServer return rpc server of the HTTPServer
func (server *HTTPServer) GetRPCServer() *rpc.Server <span class="cov0" title="0">{
        return server.rpc
}</span>

// httpReadWriteCloser wraps a io.Reader and io.Writer
type httpReadWriteCloser struct {
        io.Reader
        io.Writer
}

func (t *httpReadWriteCloser) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// hostFilter handlers the incoming requests and filters the Host-header.
// To prevent DNS rebinding attacks which do not utilize CORS-headers.
// We use a whitelist to validate the Host-header in domains.
type hostFilter struct {
        whitehosts map[string]struct{}
        handler    http.Handler
}

// ServeHTTP handlers the incoming requests and validate the Host-header
func (h *hostFilter) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if h.isValideHost(r) </span><span class="cov0" title="0">{
                h.handler.ServeHTTP(w, r)
        }</span><span class="cov0" title="0"> else {
                http.Error(w, ErrInvalidHost.Error(), http.StatusForbidden)
        }</span>
}

func (h *hostFilter) isValideHost(r *http.Request) bool <span class="cov8" title="1">{
        if r.Host == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">host, _, err := net.SplitHostPort(r.Host)
        if err != nil </span><span class="cov8" title="1">{
                // no port or too many colons is ok
                // we just filter the whitelist
                host = r.Host
        }</span>

        //ip address is ok
        <span class="cov8" title="1">if ip := net.ParseIP(host); ip != nil </span><span class="cov8" title="1">{
                return true
        }</span>

        // * and nil whitehost do not need to validate
        <span class="cov8" title="1">_, exist := h.whitehosts["*"]
        if exist || len(h.whitehosts) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if _, exist := h.whitehosts[host]; exist </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rpc

import (
        "encoding/json"
        "errors"
        "io"
        "net/rpc"
        "sync"
)

const (
        jsonrpcVersion = "2.0"
)

type jsonCodec struct {
        dec *json.Decoder // for reading JSON values
        enc *json.Encoder // for writing JSON values
        c   io.Closer
        srv *rpc.Server

        // temporary work space
        req jsonRequest

        // JSON-RPC clients can use arbitrary json values as request IDs.
        // Package rpc expects uint64 request IDs.
        // We assign uint64 sequence numbers to incoming requests
        // but save the original request ID in the pending map.
        // When rpc responds, we use the sequence number in
        // the response to find the original request ID.
        mutex    sync.Mutex // protects seq, pending
        encmutex sync.Mutex // protects enc
        seq      uint64
        pending  map[uint64]*json.RawMessage
}

// NewJSONCodec returns a new rpc.ServerCodec using JSON-RPC on conn.
func NewJSONCodec(conn io.ReadWriteCloser, srv *rpc.Server) rpc.ServerCodec <span class="cov8" title="1">{
        if srv == nil </span><span class="cov8" title="1">{
                srv = rpc.DefaultServer
        }</span>
        <span class="cov8" title="1">srv.Register(JSONRPC2{})
        return &amp;jsonCodec{
                dec:     json.NewDecoder(conn),
                enc:     json.NewEncoder(conn),
                c:       conn,
                srv:     srv,
                pending: make(map[uint64]*json.RawMessage),
        }</span>
}

type jsonRequest struct {
        Version string           `json:"jsonrpc"`
        Method  string           `json:"method"`
        Params  *json.RawMessage `json:"params"`
        ID      *json.RawMessage `json:"id"`
}

func (r *jsonRequest) UnmarshalJSON(raw []byte) error <span class="cov8" title="1">{
        r.reset()
        type req *jsonRequest
        if err := json.Unmarshal(raw, req(r)); err != nil </span><span class="cov0" title="0">{
                return errors.New("bad request")
        }</span>

        <span class="cov8" title="1">var reqMap = make(map[string]*json.RawMessage)
        if err := json.Unmarshal(raw, &amp;reqMap); err != nil </span><span class="cov0" title="0">{
                return errors.New("bad request")
        }</span>
        <span class="cov8" title="1">if reqMap["jsonrpc"] == nil || reqMap["method"] == nil </span><span class="cov8" title="1">{
                return errors.New("bad request")
        }</span>
        <span class="cov8" title="1">_, okID := reqMap["id"]
        _, okParams := reqMap["params"]
        if len(reqMap) == 3 &amp;&amp; !(okID || okParams) || len(reqMap) == 4 &amp;&amp; !(okID &amp;&amp; okParams) || len(reqMap) &gt; 4 </span><span class="cov0" title="0">{
                return errors.New("bad request")
        }</span>
        <span class="cov8" title="1">if r.Version != "2.0" </span><span class="cov0" title="0">{
                return errors.New("bad request")
        }</span>
        <span class="cov8" title="1">if okParams </span><span class="cov8" title="1">{
                if r.Params == nil || len(*r.Params) == 0 </span><span class="cov0" title="0">{
                        return errors.New("bad request")
                }</span>
        }
        <span class="cov8" title="1">if okID &amp;&amp; r.ID == nil </span><span class="cov0" title="0">{
                r.ID = nil
        }</span>
        <span class="cov8" title="1">if okID </span><span class="cov8" title="1">{
                if len(*r.ID) == 0 </span><span class="cov0" title="0">{
                        return errors.New("bad request")
                }</span>
                <span class="cov8" title="1">switch []byte(*r.ID)[0] </span>{
                case 't', 'f', '{', '[':<span class="cov0" title="0">
                        return errors.New("bad request")</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *jsonRequest) reset() <span class="cov8" title="1">{
        r.Version = ""
        r.Method = ""
        r.Params = nil
        r.ID = nil
}</span>

type jsonResponse struct {
        Version string           `json:"jsonrpc"`
        ID      *json.RawMessage `json:"id"`
        Result  interface{}      `json:"result,omitempty"`
        Error   interface{}      `json:"error,omitempty"`
}

func (c *jsonCodec) ReadRequestHeader(r *rpc.Request) error <span class="cov8" title="1">{
        var raw json.RawMessage
        if err := c.dec.Decode(&amp;raw); err != nil </span><span class="cov8" title="1">{
                c.encmutex.Lock()
                c.enc.Encode(jsonResponse{Version: jsonrpcVersion, ID: &amp;null, Error: errParse})
                c.encmutex.Unlock()
                return err
        }</span>

        <span class="cov8" title="1">if len(raw) &gt; 0 &amp;&amp; raw[0] == '[' </span><span class="cov0" title="0">{
                c.req.Version = jsonrpcVersion
                c.req.Method = "JSONRPC2.Batch"
                c.req.Params = &amp;raw
                c.req.ID = &amp;null
        }</span><span class="cov8" title="1"> else if err := json.Unmarshal(raw, &amp;c.req); err != nil </span><span class="cov8" title="1">{
                if err.Error() == "bad request" </span><span class="cov8" title="1">{
                        c.encmutex.Lock()
                        c.enc.Encode(jsonResponse{Version: jsonrpcVersion, ID: &amp;null, Error: errRequest})
                        c.encmutex.Unlock()
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">r.ServiceMethod = c.req.Method

        // JSON request id can be any JSON value;
        // RPC package expects uint64.  Translate to
        // internal uint64 and save JSON on the side.
        c.mutex.Lock()
        c.seq++
        c.pending[c.seq] = c.req.ID
        c.req.ID = nil
        r.Seq = c.seq
        c.mutex.Unlock()

        return nil</span>
}

func (c *jsonCodec) ReadRequestBody(x interface{}) error <span class="cov8" title="1">{
        if x == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if c.req.Params == nil </span><span class="cov8" title="1">{
                return errParams
        }</span>
        // JSON params is array value.
        // RPC params is struct.
        // Unmarshal into array containing struct for now.
        // Should think about making RPC more general.
        <span class="cov8" title="1">var params [1]interface{}
        params[0] = x

        if c.req.Method == "JSONRPC2.Batch" </span><span class="cov0" title="0">{
                arg := x.(*BatchArg)
                arg.srv = c.srv
                if err := json.Unmarshal(*c.req.Params, &amp;arg.reqs); err != nil </span><span class="cov0" title="0">{
                        return NewError(errParams.Code, err.Error())
                }</span>
                <span class="cov0" title="0">if len(arg.reqs) == 0 </span><span class="cov0" title="0">{
                        return errRequest
                }</span>
        }<span class="cov8" title="1"> else if err := json.Unmarshal(*c.req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                return NewError(errParams.Code, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

var null = json.RawMessage([]byte("null"))

func (c *jsonCodec) WriteResponse(r *rpc.Response, x interface{}) error <span class="cov8" title="1">{
        c.mutex.Lock()
        b, ok := c.pending[r.Seq]
        if !ok </span><span class="cov0" title="0">{
                c.mutex.Unlock()
                return errors.New("invalid sequence number in response")
        }</span>
        <span class="cov8" title="1">delete(c.pending, r.Seq)
        c.mutex.Unlock()

        if replies, ok := x.(*[]*json.RawMessage); r.ServiceMethod == "JSONRPC2.Batch" &amp;&amp; ok </span><span class="cov0" title="0">{
                if len(*replies) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">c.encmutex.Lock()
                defer c.encmutex.Unlock()
                return c.enc.Encode(replies)</span>
        }

        <span class="cov8" title="1">if b == nil </span><span class="cov0" title="0">{
                // Invalid request so no id. Use JSON null.
                b = &amp;null
        }</span>
        <span class="cov8" title="1">resp := jsonResponse{Version: jsonrpcVersion, ID: b}
        if r.Error == "" </span><span class="cov8" title="1">{
                if x == nil </span><span class="cov0" title="0">{
                        resp.Result = &amp;null
                }</span><span class="cov8" title="1"> else {
                        resp.Result = x
                }</span>
        }<span class="cov8" title="1"> else if r.Error[0] == '{' &amp;&amp; r.Error[len(r.Error)-1] == '}' </span><span class="cov8" title="1">{
                raw := json.RawMessage(r.Error)
                resp.Error = &amp;raw
        }</span><span class="cov8" title="1"> else {
                raw := json.RawMessage(newError(r.Error).Error())
                resp.Error = &amp;raw
        }</span>
        <span class="cov8" title="1">c.encmutex.Lock()
        defer c.encmutex.Unlock()
        return c.enc.Encode(resp)</span>
}

func (c *jsonCodec) Close() error <span class="cov8" title="1">{
        return c.c.Close()
}</span>

// ServeConn runs the JSON-RPC server on a single connection.
// ServeConn blocks, serving the connection until the client hangs up.
// The caller typically invokes ServeConn with go-routine.
func ServeConn(conn io.ReadWriteCloser) <span class="cov8" title="1">{
        rpc.ServeCodec(NewJSONCodec(conn, nil))
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package rpc

import (
        "net/rpc"
)

// MetadataAPI is a default service for RegisterName.
const MetadataAPI = "rpc"

// Server represents a RPC server
type Server struct {
        rpc.Server
}

// API is a collection of methods for the RPC interface.
type API struct {
        // namespace of service
        Namespace string
        // api version
        Version string
        // the service methods holder
        Service interface{}
        // indication if the methods must be considered safe for public use
        Public bool
}

// RPCService offers meta information of the server.
//type RPCService struct {
//        server *Server
//}

// NewServer returns a new Server.
func NewServer() *Server <span class="cov8" title="1">{
        server := &amp;Server{
                rpc.Server{},
        }

        // Not implemented service
        // register a default service which will provide meta information about the RPC service.
        //rpcService := &amp;RPCService{server}
        //server.RegisterName(MetadataAPI, rpcService)

        return server
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package rpc

import (
        "fmt"
        "io"
        "log"
        "net/http"
        "net/rpc"

        "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
}

// WsRPCServer represents a Websocket RPC server
type WsRPCServer struct {
        rpc *rpc.Server
}

// WebsocketServerConn represents a websocket server connection
type WebsocketServerConn struct {
        Ws *websocket.Conn
        r  io.Reader
        w  io.WriteCloser
}

// NewWsRPCServer return a Websocket RPC server
func NewWsRPCServer() *WsRPCServer <span class="cov8" title="1">{
        server := &amp;WsRPCServer{
                rpc: &amp;rpc.Server{},
        }

        return server
}</span>

// GetWsRPCServer return rpc server of the WsRPCServer
func (server *WsRPCServer) GetWsRPCServer() *rpc.Server <span class="cov8" title="1">{
        return server.rpc
}</span>

// ServeWS runs the JSON-RPC server on a single websocket connection.
func (server *WsRPCServer) ServeWS(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ws, err := upgrader.Upgrade(w, r, nil)
        defer ws.Close()

        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return
        }</span>

        <span class="cov0" title="0">server.rpc.ServeCodec(NewJSONCodec(ws.UnderlyingConn(), nil))</span>
}

// Read represents read data from websocket connection.
func (wc *WebsocketServerConn) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if wc.r == nil </span><span class="cov0" title="0">{
                _, wc.r, err = wc.Ws.NextReader()

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return 0, err
                }</span>
        }

        <span class="cov0" title="0">n, err = wc.r.Read(p)
        if err == io.EOF </span><span class="cov0" title="0">{
                wc.r = nil
        }</span>

        <span class="cov0" title="0">return</span>
}

// Write represents write data for websocket connection.
func (wc *WebsocketServerConn) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        if wc.w == nil </span><span class="cov0" title="0">{
                wc.w, err = wc.Ws.NextWriter(websocket.TextMessage)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov0" title="0">n, err = wc.w.Write(p)
        if err != nil || n == len(p) </span><span class="cov0" title="0">{
                err = wc.Close()
        }</span>

        <span class="cov0" title="0">return</span>

}

// Close represents close the websocket connection.
func (wc *WebsocketServerConn) Close() (err error) <span class="cov0" title="0">{
        if wc.w != nil </span><span class="cov0" title="0">{
                err = wc.w.Close()
                wc.w = nil
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package seele

import (
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "runtime/pprof"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/common/hexutil"
        "github.com/seeleteam/go-seele/core/types"
)

// PrivateDebugAPI provides an API to access full node-related information for debug.
type PrivateDebugAPI struct {
        s *SeeleService
}

// NewPrivateDebugAPI creates a new NewPrivateDebugAPI object for rpc service.
func NewPrivateDebugAPI(s *SeeleService) *PrivateDebugAPI <span class="cov0" title="0">{
        return &amp;PrivateDebugAPI{s}
}</span>

// GetBlockRlp retrieves the RLP encoded for of a single block, when height is -1 the chain head is returned
func (api *PrivateDebugAPI) GetBlockRlp(height *int64, result *string) error <span class="cov0" title="0">{
        block, err := getBlock(api.s.chain, *height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">blockRlp, err := common.Serialize(block)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*result = hexutil.BytesToHex(blockRlp)
        return nil</span>
}

// PrintBlock retrieves a block and returns its pretty printed form, when height is -1 the chain head is returned
func (api *PrivateDebugAPI) PrintBlock(height *int64, result *types.Block) error <span class="cov0" title="0">{
        block, err := getBlock(api.s.chain, *height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*result = *block
        return nil</span>
}

// GetTxPoolContent returns the transactions contained within the transaction pool
func (api *PrivateDebugAPI) GetTxPoolContent(input interface{}, result *map[string][]map[string]interface{}) error <span class="cov0" title="0">{
        txPool := api.s.TxPool()
        data := txPool.GetTransactions(false, true)

        content := make(map[string][]map[string]interface{})
        for _, tx := range data </span><span class="cov0" title="0">{
                key := tx.Data.From.ToHex()
                content[key] = append(content[key], PrintableOutputTx(tx))
        }</span>
        <span class="cov0" title="0">*result = content

        return nil</span>
}

// GetTxPoolTxCount returns the number of transaction in the pool
func (api *PrivateDebugAPI) GetTxPoolTxCount(input interface{}, result *uint64) error <span class="cov0" title="0">{
        txPool := api.s.TxPool()
        *result = uint64(txPool.GetPendingTxCount())
        return nil
}</span>

// TpsInfo tps detail info
type TpsInfo struct {
        StartHeight uint64
        EndHeight   uint64
        Count       uint64
        Duration    uint64
}

// GetTPS get tps info
func (api *PrivateDebugAPI) GetTPS(input interface{}, result *TpsInfo) error <span class="cov0" title="0">{
        chain := api.s.BlockChain()
        block := chain.CurrentBlock()
        timeInterval := uint64(150)
        if block.Header.Height == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var count = uint64(len(block.Transactions) - 1)
        var duration uint64
        var endHeight uint64
        startTime := block.Header.CreateTimestamp.Uint64()
        for height := block.Header.Height - 1; height &gt; 0; height-- </span><span class="cov0" title="0">{
                current, err := chain.GetStore().GetBlockByHeight(height)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("get block failed, error:%s, block height:%d", err, height)
                }</span>

                <span class="cov0" title="0">count += uint64(len(current.Transactions) - 1)
                duration = startTime - current.Header.CreateTimestamp.Uint64()
                endHeight = height

                if duration &gt; timeInterval </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">*result = TpsInfo{
                StartHeight: endHeight,
                EndHeight:   block.Header.Height,
                Count:       count,
                Duration:    duration,
        }

        return nil</span>
}

// DumpHeapRequest represents the heamp dump request.
type DumpHeapRequest struct {
        Filename     string
        GCBeforeDump bool
}

// DumpHeap dumps the heap usage.
func (api *PrivateDebugAPI) DumpHeap(request *DumpHeapRequest, result *interface{}) error <span class="cov0" title="0">{
        filename := "heap.dump"

        if len(request.Filename) &gt; 0 </span><span class="cov0" title="0">{
                filename = request.Filename
        }</span>

        <span class="cov0" title="0">if request.GCBeforeDump </span><span class="cov0" title="0">{
                runtime.GC()
        }</span>

        <span class="cov0" title="0">f, err := os.Create(filepath.Join(common.GetDefaultDataFolder(), filename))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return pprof.WriteHeapProfile(f)</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package seele

import (
        "errors"
        "fmt"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/miner"
)

// PrivateMinerAPI provides an API to access miner information.
type PrivateMinerAPI struct {
        s *SeeleService
}

// NewPrivateMinerAPI creates a new PrivateMinerAPI object for miner rpc service.
func NewPrivateMinerAPI(s *SeeleService) *PrivateMinerAPI <span class="cov0" title="0">{
        return &amp;PrivateMinerAPI{s}
}</span>

// Start API is used to start the miner with the given number of threads.
func (api *PrivateMinerAPI) Start(threads *int, result *string) error <span class="cov0" title="0">{
        if threads == nil </span><span class="cov0" title="0">{
                threads = new(int)
        }</span>
        <span class="cov0" title="0">api.s.miner.SetThreads(*threads)

        if api.s.miner.IsMining() </span><span class="cov0" title="0">{
                return miner.ErrMinerIsRunning
        }</span>

        <span class="cov0" title="0">return api.s.miner.Start()</span>
}

// Status API is used to view the miner's status.
func (api *PrivateMinerAPI) Status(input *string, result *string) error <span class="cov0" title="0">{
        if api.s.miner.IsMining() </span><span class="cov0" title="0">{
                *result = "Running"
        }</span><span class="cov0" title="0"> else {
                *result = "Stopped"
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop API is used to stop the miner.
func (api *PrivateMinerAPI) Stop(input *string, result *string) error <span class="cov0" title="0">{
        if !api.s.miner.IsMining() </span><span class="cov0" title="0">{
                return miner.ErrMinerIsStopped
        }</span>
        <span class="cov0" title="0">api.s.miner.Stop()

        return nil</span>
}

// Hashrate returns the POW hashrate.
func (api *PrivateMinerAPI) Hashrate(input *string, hashrate *uint64) error <span class="cov0" title="0">{
        if !api.s.miner.IsMining() </span><span class="cov0" title="0">{
                return miner.ErrMinerIsStopped
        }</span>

        <span class="cov0" title="0">*hashrate = uint64(api.s.miner.Hashrate())

        return nil</span>
}

// SetThreads  API is used to set the number of threads.
func (api *PrivateMinerAPI) SetThreads(threads *int, result *interface{}) error <span class="cov0" title="0">{
        if *threads &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("threads should be greater than zero.")
        }</span>
        <span class="cov0" title="0">api.s.miner.SetThreads(*threads)

        return nil</span>
}

// GetThreads  API is used to get the number of threads.
func (api *PrivateMinerAPI) GetThreads(threads *int, result *int) error <span class="cov0" title="0">{
        *result = api.s.miner.GetThreads()
        return nil
}</span>

// SetCoinbase API is used to set the coinbase.
func (api *PrivateMinerAPI) SetCoinbase(coinbaseStr *string, result *interface{}) error <span class="cov0" title="0">{
        coinbase, err := common.HexToAddress(*coinbaseStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !common.IsShardEnabled() </span><span class="cov0" title="0">{
                return fmt.Errorf("local shard number is invalid:[%v], it must greater than %v, less than %v", common.LocalShardNumber, common.UndefinedShardNumber, common.ShardCount)
        }</span>
        <span class="cov0" title="0">if coinbase.Shard() != common.LocalShardNumber </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid shard number: coinbase shard number is [%v], but local shard number is [%v]", coinbase.Shard(), common.LocalShardNumber)
        }</span>
        <span class="cov0" title="0">api.s.miner.SetCoinbase(coinbase)

        return nil</span>
}

// GetCoinbase API is used to get the coinbase.
func (api *PrivateMinerAPI) GetCoinbase(input interface{}, result *common.Address) error <span class="cov0" title="0">{
        *result = api.s.miner.GetCoinbase()

        return nil
}</span>
</pre>
		
		<pre class="file" id="file115" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package seele

import "github.com/seeleteam/go-seele/p2p"

// PrivateNetworkAPI provides an API to access network information.
type PrivateNetworkAPI struct {
        s *SeeleService
}

// NewPrivateNetworkAPI creates a new PrivateNetworkAPI object for rpc service.
func NewPrivateNetworkAPI(s *SeeleService) *PrivateNetworkAPI <span class="cov0" title="0">{
        return &amp;PrivateNetworkAPI{s}
}</span>

// GetPeersInfo returns all the information of peers at the protocol granularity.
func (n *PrivateNetworkAPI) GetPeersInfo(input interface{}, result *[]p2p.PeerInfo) error <span class="cov0" title="0">{
        *result = *n.s.p2pServer.PeersInfo()
        return nil
}</span>

// GetPeerCount returns the count of peers
func (n *PrivateNetworkAPI) GetPeerCount(input interface{}, result *int) error <span class="cov0" title="0">{
        *result = n.s.p2pServer.PeerCount()
        return nil
}</span>

// GetNetworkVersion returns the network version
func (n *PrivateNetworkAPI) GetNetworkVersion(input interface{}, result *uint64) error <span class="cov0" title="0">{
        *result = n.s.NetVersion()
        return nil
}</span>

// GetProtocolVersion returns the current seele protocol version this node supports
func (n *PrivateNetworkAPI) GetProtocolVersion(input interface{}, result *uint) error <span class="cov0" title="0">{
        *result = n.s.seeleProtocol.Protocol.Version
        return nil
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package seele

import (
        "fmt"
        "math/big"
        "strings"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/common/hexutil"
        "github.com/seeleteam/go-seele/core"
        "github.com/seeleteam/go-seele/core/state"
        "github.com/seeleteam/go-seele/core/store"
        "github.com/seeleteam/go-seele/core/types"
)

// PublicSeeleAPI provides an API to access full node-related information.
type PublicSeeleAPI struct {
        s *SeeleService
}

const maxSizeLimit = 64

// NewPublicSeeleAPI creates a new PublicSeeleAPI object for rpc service.
func NewPublicSeeleAPI(s *SeeleService) *PublicSeeleAPI <span class="cov8" title="1">{
        return &amp;PublicSeeleAPI{s}
}</span>

// MinerInfo miner simple info
type MinerInfo struct {
        Coinbase           common.Address
        CurrentBlockHeight uint64
        HeaderHash         common.Hash
        Shard              uint
        MinerStatus        string
        MinerThread        int
}

// GetBlockByHeightRequest request param for GetBlockByHeight api
type GetBlockByHeightRequest struct {
        Height int64
        FullTx bool
}

// GetBlocksRequest request param for GetBlocks api
type GetBlocksRequest struct {
        GetBlockByHeightRequest
        Size uint
}

// GetBlockByHashRequest request param for GetBlockByHash api
type GetBlockByHashRequest struct {
        HashHex string
        FullTx  bool
}

// GetLogsRequest request param for GetLogs api
type GetLogsRequest struct {
        Height          int64
        ContractAddress string
        Topics          string
}

// GetLogsResponse response param for GetLogs api
type GetLogsResponse struct {
        Txhash   common.Hash
        LogIndex uint
        Log      *types.Log
}

// GetTxByBlockHeightAndIndexRequest request param for GetTransactionByBlockHeightAndIndex api
type GetTxByBlockHeightAndIndexRequest struct {
        Height int64
        Index  uint
}

// GetTxByBlockHashAndIndexRequest request param for GetTransactionByBlockHashAndIndex api
type GetTxByBlockHashAndIndexRequest struct {
        HashHex string
        Index   uint
}

// CallRequest request param for Call api
type CallRequest struct {
        Tx     *types.Transaction
        Height int64
}

// Call is to execute a given transaction on a statedb of a given block height.
// It does not affect this statedb and blockchain and is useful for executing and retrieve values.
func (api *PublicSeeleAPI) Call(request *CallRequest, result *map[string]interface{}) error <span class="cov8" title="1">{
        // Get the block by block height, if the height is less than zero, get the current block.
        block, err := getBlock(api.s.chain, request.Height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the statedb by the given block height
        <span class="cov8" title="1">statedb, err := state.NewStatedb(block.Header.StateHash, api.s.accountStateDB)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the transaction receipt, and the fee give to the miner coinbase
        <span class="cov8" title="1">receipt, err := api.s.chain.ApplyTransaction(request.Tx, 0, api.s.miner.GetCoinbase(), statedb, block.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Format the receipt
        <span class="cov8" title="1">if *result, err = PrintableReceipt(receipt); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetInfo gets the account address that mining rewards will be send to.
func (api *PublicSeeleAPI) GetInfo(input interface{}, info *MinerInfo) error <span class="cov8" title="1">{
        block := api.s.chain.CurrentBlock()

        var status string
        if api.s.miner.IsMining() </span><span class="cov0" title="0">{
                status = "Running"
        }</span><span class="cov8" title="1"> else {
                status = "Stopped"
        }</span>

        <span class="cov8" title="1">*info = MinerInfo{
                Coinbase:           api.s.miner.GetCoinbase(),
                CurrentBlockHeight: block.Header.Height,
                HeaderHash:         block.HeaderHash,
                Shard:              common.LocalShardNumber,
                MinerStatus:        status,
                MinerThread:        api.s.miner.GetThreads(),
        }

        return nil</span>
}

// GetBalance get balance of the account. if the account's address is empty, will get the coinbase balance
func (api *PublicSeeleAPI) GetBalance(account *common.Address, result *big.Int) error <span class="cov0" title="0">{
        if account == nil || account.Equal(common.Address{}) </span><span class="cov0" title="0">{
                *account = api.s.Miner().GetCoinbase()
        }</span>

        <span class="cov0" title="0">state, err := api.s.chain.GetCurrentState()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">balance := state.GetBalance(*account)
        result.Set(balance)
        return nil</span>
}

// AddTx add a tx to miner
func (api *PublicSeeleAPI) AddTx(tx *types.Transaction, result *bool) error <span class="cov0" title="0">{
        shard := tx.Data.From.Shard()
        var err error
        if shard != common.LocalShardNumber </span><span class="cov0" title="0">{
                if err = tx.ValidateWithoutState(true, false); err == nil </span><span class="cov0" title="0">{
                        api.s.seeleProtocol.SendDifferentShardTx(tx, shard)
                }</span>
        }<span class="cov0" title="0"> else {
                err = api.s.txPool.AddTransaction(tx)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                *result = false
                return err
        }</span>

        <span class="cov0" title="0">*result = true
        return nil</span>
}

// GetAccountNonce get account next used nonce
func (api *PublicSeeleAPI) GetAccountNonce(account *common.Address, nonce *uint64) error <span class="cov0" title="0">{
        state, err := api.s.chain.GetCurrentState()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*nonce = state.GetNonce(*account)

        return nil</span>
}

// GetBlockHeight get the block height of the chain head
func (api *PublicSeeleAPI) GetBlockHeight(input interface{}, height *uint64) error <span class="cov0" title="0">{
        block := api.s.chain.CurrentBlock()
        *height = block.Header.Height

        return nil
}</span>

// GetBlockByHeight returns the requested block. When blockNr is -1 the chain head is returned. When fullTx is true all
// transactions in the block are returned in full detail, otherwise only the transaction hash is returned
func (api *PublicSeeleAPI) GetBlockByHeight(request *GetBlockByHeightRequest, result *map[string]interface{}) error <span class="cov0" title="0">{
        block, err := getBlock(api.s.chain, request.Height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">response, err := rpcOutputBlock(block, request.FullTx, api.s.chain.GetStore())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*result = response
        return nil</span>
}

// GetBlocks returns the size of requested block. When the blockNr is -1 the chain head is returned.
//When the size is greater than 64, the size will be set to 64.When it's -1 that the blockNr minus size, the blocks in 64 is returned.
// When fullTx is true all transactions in the block are returned in full detail, otherwise only the transaction hash is returned
func (api *PublicSeeleAPI) GetBlocks(request *GetBlocksRequest, result *[]map[string]interface{}) error <span class="cov8" title="1">{
        blocks := make([]types.Block, 0)
        if request.Height &lt; 0 </span><span class="cov8" title="1">{
                block := api.s.chain.CurrentBlock()
                blocks = append(blocks, *block)
        }</span><span class="cov8" title="1"> else {
                if request.Size &gt; maxSizeLimit </span><span class="cov8" title="1">{
                        request.Size = maxSizeLimit
                }</span>

                <span class="cov8" title="1">if request.Height+1-int64(request.Size) &lt; 0 </span><span class="cov8" title="1">{
                        request.Size = uint(request.Height + 1)
                }</span>

                <span class="cov8" title="1">for i := uint(0); i &lt; request.Size; i++ </span><span class="cov8" title="1">{
                        var block *types.Block
                        block, err := getBlock(api.s.chain, request.Height-int64(i))
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">blocks = append(blocks, *block)</span>
                }
        }
        <span class="cov8" title="1">response, err := rpcOutputBlocks(blocks, request.FullTx, api.s.chain.GetStore())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*result = response
        return nil</span>
}

// GetBlockByHash returns the requested block. When fullTx is true all transactions in the block are returned in full
// detail, otherwise only the transaction hash is returned
func (api *PublicSeeleAPI) GetBlockByHash(request *GetBlockByHashRequest, result *map[string]interface{}) error <span class="cov0" title="0">{
        store := api.s.chain.GetStore()
        hashByte, err := hexutil.HexToBytes(request.HashHex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">hash := common.BytesToHash(hashByte)
        block, err := store.GetBlock(hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">response, err := rpcOutputBlock(block, request.FullTx, store)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*result = response
        return nil</span>
}

// GetLogs Get the logs that satisfies the condition in the block by height and filter
func (api *PublicSeeleAPI) GetLogs(request *GetLogsRequest, result *[]GetLogsResponse) error <span class="cov8" title="1">{
        // Check input parameters
        contractAddress, err := common.HexToAddress(request.ContractAddress)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid contract address, %s", err)
        }</span>

        <span class="cov8" title="1">hash, err := common.HexToHash(request.Topics)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid topic, %s", err)
        }</span>

        // Do filter
        <span class="cov8" title="1">block, err := getBlock(api.s.chain, request.Height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">store := api.s.chain.GetStore()
        receipts, err := store.GetReceiptsByBlockHash(block.HeaderHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">logs := make([]GetLogsResponse, 0)
        for _, receipt := range receipts </span><span class="cov8" title="1">{
                for logIndex, log := range receipt.Logs </span><span class="cov8" title="1">{
                        // Matches contract address
                        if !contractAddress.Equal(log.Address) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Matches topics
                        // Because of the topics is always only one
                        <span class="cov8" title="1">if len(log.Topics) &lt; 1 || !hash.Equal(log.Topics[0]) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">logs = append(logs, GetLogsResponse{
                                Txhash:   receipt.TxHash,
                                LogIndex: uint(logIndex),
                                Log:      log,
                        })</span>
                }
        }

        <span class="cov8" title="1">*result = logs

        return nil</span>
}

// rpcOutputBlock converts the given block to the RPC output which depends on fullTx
func rpcOutputBlock(b *types.Block, fullTx bool, store store.BlockchainStore) (map[string]interface{}, error) <span class="cov8" title="1">{
        head := b.Header
        fields := map[string]interface{}{
                "height":     head.Height,
                "hash":       b.HeaderHash.ToHex(),
                "parentHash": head.PreviousBlockHash.ToHex(),
                "nonce":      head.Nonce,
                "stateHash":  head.StateHash.ToHex(),
                "txHash":     head.TxHash.ToHex(),
                "creator":    head.Creator.ToHex(),
                "timestamp":  head.CreateTimestamp,
                "difficulty": head.Difficulty,
        }

        txs := b.Transactions
        transactions := make([]interface{}, len(txs))
        for i, tx := range txs </span><span class="cov8" title="1">{
                if fullTx </span><span class="cov8" title="1">{
                        transactions[i] = PrintableOutputTx(tx)
                }</span><span class="cov0" title="0"> else {
                        transactions[i] = tx.Hash.ToHex()
                }</span>
        }
        <span class="cov8" title="1">fields["transactions"] = transactions

        totalDifficulty, err := store.GetBlockTotalDifficulty(b.HeaderHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">fields["totalDifficulty"] = totalDifficulty

        return fields, nil</span>
}

func rpcOutputBlocks(b []types.Block, fullTx bool, store store.BlockchainStore) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        fields := make([]map[string]interface{}, 0)

        for i := range b </span><span class="cov8" title="1">{
                if field, err := rpcOutputBlock(&amp;b[i], fullTx, store); err == nil </span><span class="cov8" title="1">{
                        fields = append(fields, field)
                }</span>
        }
        <span class="cov8" title="1">return fields, nil</span>
}

// PrintableOutputTx converts the given tx to the RPC output
func PrintableOutputTx(tx *types.Transaction) map[string]interface{} <span class="cov8" title="1">{
        toAddr := ""
        if !tx.Data.To.IsEmpty() </span><span class="cov8" title="1">{
                toAddr = tx.Data.To.ToHex()
        }</span>

        <span class="cov8" title="1">transaction := map[string]interface{}{
                "hash":         tx.Hash.ToHex(),
                "from":         tx.Data.From.ToHex(),
                "to":           toAddr,
                "amount":       tx.Data.Amount,
                "accountNonce": tx.Data.AccountNonce,
                "payload":      tx.Data.Payload,
                "timestamp":    tx.Data.Timestamp,
                "fee":          tx.Data.Fee,
        }
        return transaction</span>
}

// PrintableReceipt converts the given Receipt to the RPC output
func PrintableReceipt(re *types.Receipt) (map[string]interface{}, error) <span class="cov8" title="1">{
        outMap := map[string]interface{}{
                "result":    hexutil.BytesToHex(re.Result),
                "poststate": re.PostState.ToHex(),
                "txhash":    re.TxHash.ToHex(),
                "contract":  "0x",
        }

        if len(re.ContractAddress) &gt; 0 </span><span class="cov0" title="0">{
                contractAddr, err := common.NewAddress(re.ContractAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">outMap["contract"] = contractAddr.ToHex()</span>
        }

        <span class="cov8" title="1">if len(re.Logs) &gt; 0 </span><span class="cov0" title="0">{
                var logOuts []map[string]interface{}

                for _, log := range re.Logs </span><span class="cov0" title="0">{
                        logOut, err := printableLog(log)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">logOuts = append(logOuts, logOut)</span>
                }

                <span class="cov0" title="0">outMap["logs"] = logOuts</span>
        }

        <span class="cov8" title="1">return outMap, nil</span>
}

func printableLog(log *types.Log) (map[string]interface{}, error) <span class="cov0" title="0">{
        if (len(log.Data) % 32) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid log data length %v", len(log.Data))
        }</span>

        <span class="cov0" title="0">outMap := map[string]interface{}{
                "address": log.Address.ToHex(),
        }

        // data
        dataLen := len(log.Data) / 32
        if dataLen &gt; 0 </span><span class="cov0" title="0">{
                var data []string
                for i := 0; i &lt; dataLen; i++ </span><span class="cov0" title="0">{
                        data = append(data, hexutil.BytesToHex(log.Data[i*32:(i+1)*32]))
                }</span>
                <span class="cov0" title="0">outMap["data"] = data</span>
        }

        // topics
        <span class="cov0" title="0">switch len(log.Topics) </span>{
        case 0:</span><span class="cov0" title="0">
                // do not print empty topic
        case 1:<span class="cov0" title="0">
                outMap["topic"] = log.Topics[0].ToHex()</span>
        default:<span class="cov0" title="0">
                var topics []string
                for _, t := range log.Topics </span><span class="cov0" title="0">{
                        topics = append(topics, t.ToHex())
                }</span>
                <span class="cov0" title="0">outMap["topics"] = fmt.Sprintf("[%v]", strings.Join(topics, ", "))</span>
        }

        <span class="cov0" title="0">return outMap, nil</span>
}

// getBlock returns block by height,when height is -1 the chain head is returned
func getBlock(chain *core.Blockchain, height int64) (*types.Block, error) <span class="cov8" title="1">{
        var block *types.Block
        if height &lt; 0 </span><span class="cov8" title="1">{
                block = chain.CurrentBlock()
        }</span><span class="cov8" title="1"> else {
                var err error
                block, err = chain.GetStore().GetBlockByHeight(uint64(height))
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return block, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package seele

import (
        "errors"
        "strconv"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/common/hexutil"
)

var (
        errTransactionNotFound = errors.New("transaction not found")
)

// PrivateTransactionPoolAPI provides an API to access transaction pool information.
type PrivateTransactionPoolAPI struct {
        s *SeeleService
}

// NewPrivateTransactionPoolAPI creates a new PrivateTransactionPoolAPI object for transaction pool rpc service.
func NewPrivateTransactionPoolAPI(s *SeeleService) *PrivateTransactionPoolAPI <span class="cov0" title="0">{
        return &amp;PrivateTransactionPoolAPI{s}
}</span>

// GetBlockTransactionCountByHeight returns the count of transactions in the block with the given height.
func (api *PrivateTransactionPoolAPI) GetBlockTransactionCountByHeight(height *int64, result *int) error <span class="cov0" title="0">{
        block, err := getBlock(api.s.chain, *height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*result = len(block.Transactions)
        return nil</span>
}

// GetBlockTransactionCountByHash returns the count of transactions in the block with the given hash.
func (api *PrivateTransactionPoolAPI) GetBlockTransactionCountByHash(blockHash *string, result *int) error <span class="cov0" title="0">{
        store := api.s.chain.GetStore()
        hashByte, err := hexutil.HexToBytes(*blockHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">hash := common.BytesToHash(hashByte)
        block, err := store.GetBlock(hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*result = len(block.Transactions)
        return nil</span>
}

// GetTransactionByBlockHeightAndIndex returns the transaction in the block with the given block height and index.
func (api *PrivateTransactionPoolAPI) GetTransactionByBlockHeightAndIndex(request *GetTxByBlockHeightAndIndexRequest, result *map[string]interface{}) error <span class="cov0" title="0">{
        block, err := getBlock(api.s.chain, request.Height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">txs := block.Transactions
        if request.Index &gt;= uint(len(txs)) </span><span class="cov0" title="0">{
                return errors.New("index out of block transaction list range, the max index is " + strconv.Itoa(len(txs)-1))
        }</span>

        <span class="cov0" title="0">*result = PrintableOutputTx(txs[request.Index])
        return nil</span>
}

// GetTransactionByBlockHashAndIndex returns the transaction in the block with the given block hash and index.
func (api *PrivateTransactionPoolAPI) GetTransactionByBlockHashAndIndex(request *GetTxByBlockHashAndIndexRequest, result *map[string]interface{}) error <span class="cov0" title="0">{
        store := api.s.chain.GetStore()
        hashByte, err := hexutil.HexToBytes(request.HashHex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">hash := common.BytesToHash(hashByte)
        block, err := store.GetBlock(hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">txs := block.Transactions
        if request.Index &gt;= uint(len(txs)) </span><span class="cov0" title="0">{
                return errors.New("index out of block transaction list range, the max index is " + strconv.Itoa(len(txs)-1))
        }</span>
        <span class="cov0" title="0">*result = PrintableOutputTx(txs[request.Index])
        return nil</span>
}

// GetReceiptByTxHash get receipt by transaction hash
func (api *PrivateTransactionPoolAPI) GetReceiptByTxHash(txHash *string, result *map[string]interface{}) error <span class="cov0" title="0">{
        hashByte, err := hexutil.HexToBytes(*txHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">hash := common.BytesToHash(hashByte)

        store := api.s.chain.GetStore()
        receipt, err := store.GetReceiptByTxHash(hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">out, err := PrintableReceipt(receipt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*result = out
        return nil</span>
}

// GetTransactionByHash returns the transaction by the given transaction hash.
func (api *PrivateTransactionPoolAPI) GetTransactionByHash(txHash *string, result *map[string]interface{}) error <span class="cov0" title="0">{
        store := api.s.chain.GetStore()
        hashByte, err := hexutil.HexToBytes(*txHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">hash := common.BytesToHash(hashByte)

        // Try to get transaction in txpool
        tx := api.s.TxPool().GetTransaction(hash)
        if tx != nil </span><span class="cov0" title="0">{
                output := PrintableOutputTx(tx)
                output["status"] = "pool"
                *result = output
                return nil
        }</span>

        // Try to get finalized transaction
        <span class="cov0" title="0">txIndex, err := store.GetTxIndex(hash)
        if err != nil </span><span class="cov0" title="0">{
                api.s.log.Info(err.Error())
                return errTransactionNotFound
        }</span>

        <span class="cov0" title="0">if txIndex != nil </span><span class="cov0" title="0">{
                block, err := store.GetBlock(txIndex.BlockHash)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">output := PrintableOutputTx(block.Transactions[txIndex.Index])
                output["status"] = "block"
                *result = output
                return nil</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetPendingTransactions returns all pending transactions
func (api *PrivateTransactionPoolAPI) GetPendingTransactions(input interface{}, result *[]map[string]interface{}) error <span class="cov0" title="0">{
        pendingTxs := api.s.TxPool().GetTransactions(true, true)
        var transactions []map[string]interface{}
        for _, tx := range pendingTxs </span><span class="cov0" title="0">{
                transactions = append(transactions, PrintableOutputTx(tx))
        }</span>
        <span class="cov0" title="0">*result = transactions
        return nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package downloader

// PrivatedownloaderAPI provides an API to access downloader information.
type PrivatedownloaderAPI struct {
        d *Downloader
}

// NewPrivatedownloaderAPI creates a new PrivatedownloaderAPI object for rpc service.
func NewPrivatedownloaderAPI(d *Downloader) *PrivatedownloaderAPI <span class="cov0" title="0">{
        return &amp;PrivatedownloaderAPI{d}
}</span>

// SyncInfo sync information for current downloader sessoin.
type SyncInfo struct {
        Status     string // readable string of downloader.syncStatus
        Duration   string // duration in seconds
        StartNum   uint64 // start block number
        Amount     uint64 // amount of blocks need to download
        Downloaded uint64
}

// GetStatus gets the SyncInfo.
func (api *PrivatedownloaderAPI) GetStatus(input interface{}, result *map[string]interface{}) error <span class="cov0" title="0">{
        var info SyncInfo
        api.d.getSyncInfo(&amp;info)

        *result = map[string]interface{}{
                "status":     info.Status,
                "duration":   info.Duration,
                "startNum":   info.StartNum,
                "amount":     info.Amount,
                "downloaded": info.Downloaded,
        }

        return nil
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package downloader

import (
        "errors"
        "fmt"
        "math/big"
        rand2 "math/rand"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/event"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/p2p"
)

const (
        GetBlockHeadersMsg uint16 = 8
        BlockHeadersMsg    uint16 = 9
        GetBlocksMsg       uint16 = 10
        BlocksPreMsg       uint16 = 11 // BlocksPreMsg is sent before BlockMsg, containing block numbers of BlockMsg.
        BlocksMsg          uint16 = 12
)

func CodeToStr(code uint16) string <span class="cov0" title="0">{
        switch code </span>{
        case GetBlockHeadersMsg:<span class="cov0" title="0">
                return "downloader.GetBlockHeadersMsg"</span>
        case BlockHeadersMsg:<span class="cov0" title="0">
                return "downloader.BlockHeadersMsg"</span>
        case GetBlocksMsg:<span class="cov0" title="0">
                return "downloader.GetBlocksMsg"</span>
        case BlocksPreMsg:<span class="cov0" title="0">
                return "downloader.BlocksPreMsg"</span>
        case BlocksMsg:<span class="cov0" title="0">
                return "downloader.BlocksMsg"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

var (
        MaxBlockFetch  = 10  // Amount of blocks to be fetched per retrieval request
        MaxHeaderFetch = 256 // Amount of block headers to be fetched per retrieval request

        MaxForkAncestry = 90000       // Maximum chain reorganisation
        peerIdleTime    = time.Second // peer's wait time for next turn if no task now

        MaxMessageLength = 8 * 1024 * 1024
        statusNone       = 1 // no sync session
        statusPreparing  = 2 // sync session is preparing
        statusFetching   = 3 // sync session is downloading
        statusCleaning   = 4 // sync session is cleaning
)

var (
        errHashNotMatch        = errors.New("Hash not match")
        errInvalidAncestor     = errors.New("Ancestor is invalid")
        errInvalidPacketRecved = errors.New("Invalid packet received")
        ErrIsSynchronising     = errors.New("Is synchronising")
        errMaxForkAncestor     = errors.New("Can not find ancestor when reached MaxForkAncestry")
        errPeerNotFound        = errors.New("Peer not found")
        errSyncErr             = errors.New("Err occurs when syncing")
)

// Downloader sync block chain with remote peer
type Downloader struct {
        cancelCh   chan struct{}        // Cancel current synchronising session
        masterPeer string               // Identifier of the best peer
        peers      map[string]*peerConn // peers map. peerID=&gt;peer

        syncStatus int
        tm         *taskMgr

        chain     *core.Blockchain
        sessionWG sync.WaitGroup
        log       *log.SeeleLog
        lock      sync.RWMutex
}

// BlockHeadersMsgBody represents a message struct for BlockHeadersMsg
type BlockHeadersMsgBody struct {
        Magic   uint32
        Headers []*types.BlockHeader
}

// BlocksMsgBody represents a message struct for BlocksMsg
type BlocksMsgBody struct {
        Magic  uint32
        Blocks []*types.Block
}

// NewDownloader create Downloader
func NewDownloader(chain *core.Blockchain) *Downloader <span class="cov8" title="1">{
        d := &amp;Downloader{
                peers:      make(map[string]*peerConn),
                chain:      chain,
                syncStatus: statusNone,
        }
        d.log = log.GetLogger("download", common.LogConfig.PrintLog)
        return d
}</span>

func (d *Downloader) getReadableStatus() string <span class="cov0" title="0">{
        var status string
        switch d.syncStatus </span>{
        case statusNone:<span class="cov0" title="0">
                status = "NotSyncing"</span>
        case statusPreparing:<span class="cov0" title="0">
                status = "Preparing"</span>
        case statusFetching:<span class="cov0" title="0">
                status = "Downloading"</span>
        case statusCleaning:<span class="cov0" title="0">
                status = "Cleaning"</span>
        }
        <span class="cov0" title="0">return status</span>
}

// getSyncInfo gets sync information of the current session.
func (d *Downloader) getSyncInfo(info *SyncInfo) <span class="cov0" title="0">{
        d.lock.RLock()
        defer d.lock.RUnlock()

        info.Status = d.getReadableStatus()
        if d.syncStatus != statusFetching </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">info.Duration = fmt.Sprintf("%.2f", time.Now().Sub(d.tm.startTime).Seconds())
        info.StartNum = d.tm.fromNo
        info.Amount = d.tm.toNo - d.tm.fromNo + 1
        info.Downloaded = d.tm.downloadedNum</span>
}

// Synchronise try to sync with remote peer.
func (d *Downloader) Synchronise(id string, head common.Hash, td *big.Int, localTD *big.Int) error <span class="cov0" title="0">{
        // Make sure only one routine can pass at once
        d.lock.Lock()
        if d.syncStatus != statusNone </span><span class="cov0" title="0">{
                d.lock.Unlock()
                return ErrIsSynchronising
        }</span>
        <span class="cov0" title="0">d.syncStatus = statusPreparing
        d.cancelCh = make(chan struct{})
        d.masterPeer = id
        p, ok := d.peers[id]
        if !ok </span><span class="cov0" title="0">{
                close(d.cancelCh)
                d.syncStatus = statusNone
                d.lock.Unlock()
                return errPeerNotFound
        }</span>
        <span class="cov0" title="0">d.lock.Unlock()

        err := d.doSynchronise(p, head, td, localTD)
        d.lock.Lock()
        d.syncStatus = statusNone
        d.sessionWG.Wait()
        d.cancelCh = nil
        d.lock.Unlock()
        return err</span>
}

func (d *Downloader) doSynchronise(conn *peerConn, head common.Hash, td *big.Int, localTD *big.Int) (err error) <span class="cov0" title="0">{
        d.log.Debug("Downloader.doSynchronise start")
        event.BlockDownloaderEventManager.Fire(event.DownloaderStartEvent)
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        d.log.Info("download end with failed, err %s", err)
                        event.BlockDownloaderEventManager.Fire(event.DownloaderFailedEvent)
                }</span><span class="cov0" title="0"> else {
                        d.log.Debug("download end success")
                        event.BlockDownloaderEventManager.Fire(event.DownloaderDoneEvent)
                }</span>
        }()

        <span class="cov0" title="0">rand2.Seed(time.Now().UnixNano())
        latest, err := d.fetchHeight(conn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">height := latest.Height

        ancestor, err := d.findCommonAncestorHeight(conn, height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">d.log.Debug("start task manager from height:%d, target height:%d", ancestor, height)
        tm := newTaskMgr(d, d.masterPeer, ancestor+1, height)
        d.tm = tm
        d.lock.Lock()
        d.syncStatus = statusFetching
        for _, pConn := range d.peers </span><span class="cov0" title="0">{
                _, peerTD := pConn.peer.Head()
                if localTD.Cmp(peerTD) &gt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">d.sessionWG.Add(1)

                go d.peerDownload(pConn, tm)</span>
        }
        <span class="cov0" title="0">d.lock.Unlock()
        d.sessionWG.Wait()

        d.lock.Lock()
        d.syncStatus = statusCleaning
        d.lock.Unlock()
        tm.close()
        d.tm = nil
        d.log.Debug("downloader.doSynchronise quit!")

        if tm.isDone() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return errSyncErr</span>
}

// fetchHeight gets the latest head of peer
func (d *Downloader) fetchHeight(conn *peerConn) (*types.BlockHeader, error) <span class="cov0" title="0">{
        head, _ := conn.peer.Head()

        magic := rand2.Uint32()
        go conn.peer.RequestHeadersByHashOrNumber(magic, head, 0, 1, false)
        msg, err := conn.waitMsg(magic, BlockHeadersMsg, d.cancelCh)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">headers := msg.([]*types.BlockHeader)
        if len(headers) != 1 </span><span class="cov0" title="0">{
                return nil, errInvalidPacketRecved
        }</span>
        <span class="cov0" title="0">if headers[0].Hash() != head </span><span class="cov0" title="0">{
                return nil, errHashNotMatch
        }</span>
        <span class="cov0" title="0">return headers[0], nil</span>
}

// findCommonAncestorHeight finds the common ancestor height
func (d *Downloader) findCommonAncestorHeight(conn *peerConn, height uint64) (uint64, error) <span class="cov8" title="1">{
        // Get the top height
        block := d.chain.CurrentBlock()
        localHeight := block.Header.Height
        var top uint64
        if localHeight &lt;= height </span><span class="cov8" title="1">{
                top = localHeight
        }</span><span class="cov0" title="0"> else {
                top = height
        }</span>

        <span class="cov8" title="1">if top == 0 </span><span class="cov8" title="1">{
                return top, nil
        }</span>

        // get maximum chain reorganisation
        <span class="cov0" title="0">var maxFetchAncestry int
        if top &gt;= uint64(MaxForkAncestry) </span><span class="cov0" title="0">{
                maxFetchAncestry = MaxForkAncestry
        }</span><span class="cov0" title="0"> else {
                maxFetchAncestry = int(top) + 1
        }</span>

        // Compare the peer and local block head hash and return the ancestor height
        <span class="cov0" title="0">var cmpCount = 0
        for </span><span class="cov0" title="0">{
                localTop := top - uint64(cmpCount)
                var fetchCount = 0
                if (maxFetchAncestry - cmpCount) &gt;= MaxHeaderFetch </span><span class="cov0" title="0">{
                        fetchCount = MaxHeaderFetch
                }</span><span class="cov0" title="0"> else {
                        fetchCount = maxFetchAncestry - cmpCount
                }</span>
                <span class="cov0" title="0">if fetchCount == 0 </span><span class="cov0" title="0">{
                        return 0, errMaxForkAncestor
                }</span>

                // Get peer block headers
                <span class="cov0" title="0">magic := rand2.Uint32()
                go conn.peer.RequestHeadersByHashOrNumber(magic, common.EmptyHash, localTop, fetchCount, true)
                msg, err := conn.waitMsg(magic, BlockHeadersMsg, d.cancelCh)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">headers := msg.([]*types.BlockHeader)
                if len(headers) == 0 </span><span class="cov0" title="0">{
                        return 0, errInvalidAncestor
                }</span>
                <span class="cov0" title="0">cmpCount += len(headers)

                // Is ancenstor found
                for i := 0; i &lt; len(headers); i++ </span><span class="cov0" title="0">{
                        cmpHeight := headers[i].Height
                        localHash, err := d.chain.GetStore().GetBlockHash(cmpHeight)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">if localHash == headers[i].Hash() </span><span class="cov0" title="0">{
                                return cmpHeight, nil
                        }</span>
                }
        }
}

// RegisterPeer add peer to download routine
func (d *Downloader) RegisterPeer(peerID string, peer Peer) <span class="cov0" title="0">{
        d.lock.Lock()
        defer d.lock.Unlock()
        newConn := newPeerConn(peer, peerID, d.log)
        d.peers[peerID] = newConn

        if d.syncStatus == statusFetching </span><span class="cov0" title="0">{
                d.sessionWG.Add(1)
                go d.peerDownload(newConn, d.tm)
        }</span>
}

// UnRegisterPeer remove peer from download routine
func (d *Downloader) UnRegisterPeer(peerID string) <span class="cov0" title="0">{
        d.lock.Lock()
        defer d.lock.Unlock()
        if peerConn, ok := d.peers[peerID]; ok </span><span class="cov0" title="0">{
                peerConn.close()
                delete(d.peers, peerID)
        }</span>
}

// DeliverMsg called by seeleprotocol to deliver recved msg from network
func (d *Downloader) DeliverMsg(peerID string, msg *p2p.Message) <span class="cov0" title="0">{
        d.lock.Lock()
        peerConn, ok := d.peers[peerID]
        d.lock.Unlock()
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">peerConn.deliverMsg(msg.Code, msg)
        return</span>
}

// Cancel cancels current session.
func (d *Downloader) Cancel() <span class="cov0" title="0">{
        d.lock.Lock()
        defer d.lock.Unlock()
        if d.cancelCh != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-d.cancelCh:</span><span class="cov0" title="0">
                default:<span class="cov0" title="0">
                        close(d.cancelCh)</span>
                }
        }
}

// Terminate close Downloader, cannot called anymore.
func (d *Downloader) Terminate() <span class="cov0" title="0">{
        d.Cancel()
        d.sessionWG.Wait()
        // TODO release variables if needed
}</span>

// peerDownload peer download routine
func (d *Downloader) peerDownload(conn *peerConn, tm *taskMgr) <span class="cov0" title="0">{
        defer d.sessionWG.Done()
        d.log.Debug("Downloader.peerDownload start")
        bMaster := (conn.peerID == d.masterPeer)
        peerID := conn.peerID
        var err error
outLoop:
        for !tm.isDone() </span><span class="cov0" title="0">{
                hasReqData := false
                if startNo, amount := tm.getReqHeaderInfo(conn); amount &gt; 0 </span><span class="cov0" title="0">{
                        d.log.Debug("tm.getReqHeaderInfo. startNo:%d amount:%d", startNo, amount)
                        hasReqData = true

                        d.log.Debug("request header by number. start %d, amount %d", startNo, amount)
                        magic := rand2.Uint32()
                        if err = conn.peer.RequestHeadersByHashOrNumber(magic, common.Hash{}, startNo, amount, false); err != nil </span><span class="cov0" title="0">{
                                d.log.Warn("RequestHeadersByHashOrNumber err! %s pid=%s", err, peerID)
                                break</span>
                        }
                        <span class="cov0" title="0">msg, err := conn.waitMsg(magic, BlockHeadersMsg, d.cancelCh)
                        if err != nil </span><span class="cov0" title="0">{
                                d.log.Warn("peerDownload waitMsg BlockHeadersMsg err! %s", err)
                                break</span>
                        }

                        <span class="cov0" title="0">headers := msg.([]*types.BlockHeader)
                        startHeight := uint64(0)
                        endHeight := uint64(0)
                        if len(headers) &gt; 0 </span><span class="cov0" title="0">{
                                startHeight = headers[0].Height
                                endHeight = headers[len(headers)-1].Height
                        }</span>
                        <span class="cov0" title="0">d.log.Debug("got block header msg length %d. start %d, end %d", len(headers), startHeight, endHeight)

                        if err = tm.deliverHeaderMsg(peerID, headers); err != nil </span><span class="cov0" title="0">{
                                d.log.Warn("peerDownload deliverHeaderMsg err! %s", err)
                                break</span>
                        }

                        <span class="cov0" title="0">d.log.Debug("get request header info success")</span>
                }

                <span class="cov0" title="0">if startNo, amount := tm.getReqBlocks(conn); amount &gt; 0 </span><span class="cov0" title="0">{
                        d.log.Debug("download.peerdown getReqBlocks startNo=%d amount=%d", startNo, amount)
                        hasReqData = true

                        d.log.Debug("request block by number. start %d, amount %d", startNo, amount)
                        magic := rand2.Uint32()
                        if err = conn.peer.RequestBlocksByHashOrNumber(magic, common.Hash{}, startNo, amount); err != nil </span><span class="cov0" title="0">{
                                d.log.Warn("RequestBlocksByHashOrNumber err! %s", err)
                                break</span>
                        }

                        <span class="cov0" title="0">msg, err := conn.waitMsg(magic, BlocksMsg, d.cancelCh)
                        if err != nil </span><span class="cov0" title="0">{
                                d.log.Warn("peerDownload waitMsg BlocksMsg err! %s", err)
                                break</span>
                        }

                        <span class="cov0" title="0">blocks := msg.([]*types.Block)
                        startHeight := uint64(0)
                        endHeight := uint64(0)
                        if len(blocks) &gt; 0 </span><span class="cov0" title="0">{
                                startHeight = blocks[0].Header.Height
                                endHeight = blocks[len(blocks)-1].Header.Height
                        }</span>
                        <span class="cov0" title="0">d.log.Debug("got blocks message length %d. start %d, end %d", len(blocks), startHeight, endHeight)

                        tm.deliverBlockMsg(peerID, blocks)
                        d.log.Debug("get request blocks success")</span>
                }

                <span class="cov0" title="0">if hasReqData </span><span class="cov0" title="0">{
                        d.log.Debug("got request data, continue to request")
                        continue</span>
                }

        <span class="cov0" title="0">outFor:
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-d.cancelCh:<span class="cov0" title="0">
                                break outLoop</span>
                        case &lt;-conn.quitCh:<span class="cov0" title="0">
                                break outLoop</span>
                        case &lt;-time.After(peerIdleTime):<span class="cov0" title="0">
                                d.log.Debug("peerDownload peerIdleTime timeout")
                                break outFor</span>
                        }
                }
        }

        <span class="cov0" title="0">tm.onPeerQuit(peerID)
        if bMaster </span><span class="cov0" title="0">{
                d.Cancel()
        }</span>
        <span class="cov0" title="0">d.log.Debug("Downloader.peerDownload end")</span>
}

// processBlocks writes blocks to the blockchain.
func (d *Downloader) processBlocks(headInfos []*downloadInfo) <span class="cov0" title="0">{
        for _, h := range headInfos </span><span class="cov0" title="0">{
                d.log.Debug("height:%d hash:%s &lt;- preHash:%s ", h.block.Header.Height, h.block.HeaderHash.ToHex(), h.block.Header.PreviousBlockHash.ToHex())
        }</span>

        <span class="cov0" title="0">for _, h := range headInfos </span><span class="cov0" title="0">{
                d.log.Debug("d.processBlock %d", h.block.Header.Height)
                if err := d.chain.WriteBlock(h.block); err != nil &amp;&amp; err != core.ErrBlockAlreadyExists </span><span class="cov0" title="0">{
                        d.log.Error("downloader processBlocks err. %s", err)
                        d.Cancel()
                        break</span>
                }
                <span class="cov0" title="0">h.status = taskStatusProcessed</span>
        }
}
</pre>
		
		<pre class="file" id="file120" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package downloader

import (
        "errors"
        "fmt"
        "math/big"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/p2p"
)

// This timeout should not be happened, but we need to handle it in case of such errors.
const MsgWaitTimeout = time.Second * 120

var (
        errRecvedQuitMsg = errors.New("Recved quit msg")
        errPeerQuit      = errors.New("Peer quit")
)

type Peer interface {
        Head() (common.Hash, *big.Int)
        RequestHeadersByHashOrNumber(magic uint32, origin common.Hash, num uint64, amount int, reverse bool) error
        RequestBlocksByHashOrNumber(magic uint32, origin common.Hash, num uint64, amount int) error
}

type peerConn struct {
        peerID         string
        peer           Peer
        waitingMsgMap  map[uint16]chan *p2p.Message //
        lockForWaiting sync.RWMutex                 //

        log    *log.SeeleLog
        quitCh chan struct{}
}

func newPeerConn(p Peer, peerID string, log *log.SeeleLog) *peerConn <span class="cov8" title="1">{
        return &amp;peerConn{
                peerID:        peerID,
                peer:          p,
                waitingMsgMap: make(map[uint16]chan *p2p.Message),
                log:           log,
                quitCh:        make(chan struct{}),
        }
}</span>

func (p *peerConn) close() <span class="cov0" title="0">{
        close(p.quitCh)
}</span>

func (p *peerConn) waitMsg(magic uint32, msgCode uint16, cancelCh chan struct{}) (ret interface{}, err error) <span class="cov0" title="0">{
        rcvCh := make(chan *p2p.Message)
        p.lockForWaiting.Lock()
        p.waitingMsgMap[msgCode] = rcvCh
        p.lockForWaiting.Unlock()

</span>Again:
        <span class="cov0" title="0">timeout := time.NewTimer(MsgWaitTimeout)
        select </span>{
        case &lt;-p.quitCh:<span class="cov0" title="0">
                err = errPeerQuit</span>
        case &lt;-cancelCh:<span class="cov0" title="0">
                err = errRecvedQuitMsg</span>
        case msg := &lt;-rcvCh:<span class="cov0" title="0">
                switch msgCode </span>{
                case BlockHeadersMsg:<span class="cov0" title="0">
                        var reqMsg BlockHeadersMsgBody
                        if err := common.Deserialize(msg.Payload, &amp;reqMsg); err != nil </span><span class="cov0" title="0">{
                                goto Again</span>
                        }
                        <span class="cov0" title="0">if reqMsg.Magic != magic </span><span class="cov0" title="0">{
                                p.log.Debug("Downloader.waitMsg  BlockHeadersMsg MAGIC_NOT_MATCH msg=%s pid=%s", CodeToStr(msgCode), p.peerID)
                                goto Again</span>
                        }
                        <span class="cov0" title="0">ret = reqMsg.Headers</span>
                case BlocksMsg:<span class="cov0" title="0">
                        var reqMsg BlocksMsgBody
                        if err := common.Deserialize(msg.Payload, &amp;reqMsg); err != nil </span><span class="cov0" title="0">{
                                goto Again</span>
                        }
                        <span class="cov0" title="0">if reqMsg.Magic != magic </span><span class="cov0" title="0">{
                                p.log.Debug("Downloader.waitMsg  BlocksMsg MAGIC_NOT_MATCH msg=%s pid=%s", CodeToStr(msgCode), p.peerID)
                                goto Again</span>
                        }
                        <span class="cov0" title="0">ret = reqMsg.Blocks</span>
                }
        case &lt;-timeout.C:<span class="cov0" title="0">
                err = fmt.Errorf("wait for msg %s timeout", CodeToStr(msgCode))</span>
        }

        <span class="cov0" title="0">p.lockForWaiting.Lock()
        delete(p.waitingMsgMap, msgCode)
        p.lockForWaiting.Unlock()
        close(rcvCh)
        return</span>
}

func (p *peerConn) deliverMsg(msgCode uint16, msg *p2p.Message) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if recover() != nil </span><span class="cov0" title="0">{
                        p.log.Info("peerConn.deliverMsg PANIC msg=%s pid=%s", CodeToStr(msgCode), p.peerID)
                }</span>
        }()
        <span class="cov0" title="0">p.lockForWaiting.Lock()
        ch, ok := p.waitingMsgMap[msgCode]
        p.lockForWaiting.Unlock()
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ch &lt;- msg</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package downloader

import (
        "errors"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/log"
)

const (
        taskStatusIdle           = 0 // request task is not assigned
        taskStatusDownloading    = 1 // block is downloading
        taskStatusWaitProcessing = 2 // block is downloaded, needs to process
        taskStatusProcessed      = 3 // block is written to chain

        maxBlocksWaiting = 1024 // max blocks waiting to download
)

var (
        errMasterHeadersNotMatch = errors.New("Master headers not match")
        errHeadInfoNotFound      = errors.New("Header info not found")
)

// downloadInfo header info for master peer
type downloadInfo struct {
        header *types.BlockHeader
        block  *types.Block
        peerID string
        status int // block download status
}

// peerHeadInfo header info for ordinary peer
type peerHeadInfo struct {
        headers map[uint64]*types.BlockHeader // block height=&gt; block header
        maxNo   uint64                        //max block height in headers
}

func newPeerHeadInfo() *peerHeadInfo <span class="cov0" title="0">{
        return &amp;peerHeadInfo{
                headers: make(map[uint64]*types.BlockHeader),
        }
}</span>

type taskMgr struct {
        downloader       *Downloader
        fromNo, toNo     uint64 // block number range [from, to]
        curNo            uint64 // the smallest block number need to recv
        downloadedNum    uint64
        peersHeaderMap   map[string]*peerHeadInfo // peer's header information
        downloadInfoList []*downloadInfo          // download process info

        masterPeer string
        lock       sync.RWMutex
        quitCh     chan struct{}
        wg         sync.WaitGroup
        log        *log.SeeleLog
        startTime  time.Time
}

func newTaskMgr(d *Downloader, masterPeer string, from uint64, to uint64) *taskMgr <span class="cov0" title="0">{
        t := &amp;taskMgr{
                log:              d.log,
                downloader:       d,
                fromNo:           from,
                toNo:             to,
                curNo:            from,
                downloadedNum:    0,
                masterPeer:       masterPeer,
                startTime:        time.Now(),
                peersHeaderMap:   make(map[string]*peerHeadInfo),
                downloadInfoList: make([]*downloadInfo, 0, to-from+1),
                quitCh:           make(chan struct{}),
        }
        t.wg.Add(1)
        go t.run()
        return t
}</span>

func (t *taskMgr) run() <span class="cov0" title="0">{
        defer t.wg.Done()
loopOut:
        for </span><span class="cov0" title="0">{
                t.lock.Lock()
                startPos := int(t.curNo - t.fromNo)
                num := 0
                for (startPos+num &lt; len(t.downloadInfoList)) &amp;&amp; (t.downloadInfoList[startPos+num].status == taskStatusWaitProcessing) </span><span class="cov0" title="0">{
                        num = num + 1
                }</span>

                <span class="cov0" title="0">results := t.downloadInfoList[startPos : startPos+num]
                t.curNo = t.curNo + uint64(num)
                t.lock.Unlock()
                t.downloader.processBlocks(results)

                select </span>{
                case &lt;-time.After(time.Second):</span><span class="cov0" title="0">
                case &lt;-t.quitCh:<span class="cov0" title="0">
                        break loopOut</span>
                }
        }
}

func (t *taskMgr) close() <span class="cov0" title="0">{
        select </span>{
        case &lt;-t.quitCh:</span><span class="cov0" title="0">
        default:<span class="cov0" title="0">
                close(t.quitCh)</span>
        }
        <span class="cov0" title="0">t.wg.Wait()</span>
}

// getReqHeaderInfo gets header request information, returns the start block number and amount of headers.
func (t *taskMgr) getReqHeaderInfo(conn *peerConn) (uint64, int) <span class="cov0" title="0">{
        t.lock.Lock()
        defer t.lock.Unlock()
        headInfo, ok := t.peersHeaderMap[conn.peerID]
        if !ok </span><span class="cov0" title="0">{
                headInfo = newPeerHeadInfo()
                t.peersHeaderMap[conn.peerID] = headInfo
                t.log.Debug("getReqHeaderInfo. create headInfo for peer: %s", conn.peerID)
        }</span>

        // try remove headers that already downloaded
        <span class="cov0" title="0">for no := range headInfo.headers </span><span class="cov0" title="0">{
                if no &lt; t.curNo </span><span class="cov0" title="0">{
                        delete(headInfo.headers, no)
                }</span>
        }

        <span class="cov0" title="0">var startNo uint64
        if conn.peerID == t.masterPeer </span><span class="cov0" title="0">{
                startNo = t.fromNo + uint64(len(t.downloadInfoList))
                if startNo-t.curNo &gt; maxBlocksWaiting </span><span class="cov0" title="0">{
                        return 0, 0
                }</span>
        }<span class="cov0" title="0"> else {
                startNo = headInfo.maxNo + 1
                if len(headInfo.headers) == 0 </span><span class="cov0" title="0">{
                        headInfo.maxNo = 0
                        startNo = t.curNo
                }</span>
        }

        <span class="cov0" title="0">if startNo == t.toNo+1 || startNo-t.curNo &gt;= uint64(MaxHeaderFetch) </span><span class="cov0" title="0">{
                // do not need to recv headers now.
                return 0, 0
        }</span>

        <span class="cov0" title="0">amount := MaxHeaderFetch
        if uint64(MaxHeaderFetch) &gt; (t.toNo + 1 - startNo) </span><span class="cov0" title="0">{
                amount = int(t.toNo - startNo + 1)
        }</span>
        <span class="cov0" title="0">return startNo, amount</span>
}

// getReqBlocks get block request information, returns the start block number and amount of blocks.
// should set masterHead.isDownloading = false, if send request msg error or download finished.
func (t *taskMgr) getReqBlocks(conn *peerConn) (uint64, int) <span class="cov0" title="0">{
        t.lock.Lock()
        defer t.lock.Unlock()
        headInfo, ok := t.peersHeaderMap[conn.peerID]
        if !ok || len(headInfo.headers) == 0 </span><span class="cov0" title="0">{
                return 0, 0
        }</span>
        <span class="cov0" title="0">var startNo uint64
        var amount int
        // find the first block that not requested yet and exists in conn
        for _, masterHead := range t.downloadInfoList[t.curNo-t.fromNo:] </span><span class="cov0" title="0">{
                if masterHead.status != taskStatusIdle </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">curHeight := masterHead.header.Height
                peerHead, ok := headInfo.headers[curHeight]
                if !ok || peerHead.Hash() != masterHead.header.Hash() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">startNo = masterHead.header.Height
                masterHead.status = taskStatusDownloading
                masterHead.peerID = conn.peerID
                amount = 1
                break</span>
        }

        <span class="cov0" title="0">if amount == 0 </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        <span class="cov0" title="0">for _, masterHead := range t.downloadInfoList[startNo+1-t.fromNo:] </span><span class="cov0" title="0">{
                if masterHead.status == taskStatusIdle </span><span class="cov0" title="0">{
                        peerHead, ok := headInfo.headers[startNo+uint64(amount)]
                        // if block is not found in headers or hash not match, then breaks the loop
                        if !ok || peerHead.Hash() != masterHead.header.Hash() </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if amount &lt; MaxBlockFetch </span><span class="cov0" title="0">{
                                amount++
                                masterHead.status = taskStatusDownloading
                                masterHead.peerID = conn.peerID
                        }</span><span class="cov0" title="0"> else {
                                break</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">return startNo, amount</span>
}

// isDone returns if all blocks are downloaded
func (t *taskMgr) isDone() bool <span class="cov0" title="0">{
        t.lock.Lock()
        defer t.lock.Unlock()
        t.log.Debug("task is done check cur:%d, target:%d", t.curNo, t.toNo)
        return t.curNo == t.toNo+1
}</span>

// onPeerQuit needs to remove tasks assigned to peer
func (t *taskMgr) onPeerQuit(peerID string) <span class="cov0" title="0">{
        t.lock.Lock()
        defer t.lock.Unlock()
        for _, masterHead := range t.downloadInfoList[t.curNo-t.fromNo:] </span><span class="cov0" title="0">{
                if masterHead.status == taskStatusDownloading &amp;&amp; masterHead.peerID == peerID </span><span class="cov0" title="0">{
                        masterHead.peerID = ""
                        masterHead.status = taskStatusIdle
                }</span>
        }
}

// deliverHeaderMsg recved header msg from peer.
func (t *taskMgr) deliverHeaderMsg(peerID string, headers []*types.BlockHeader) error <span class="cov0" title="0">{
        t.lock.Lock()
        defer t.lock.Unlock()

        if len(headers) == 0 </span><span class="cov0" title="0">{
                t.log.Debug("get block header msg with empty header info")
                return nil
        }</span>

        <span class="cov0" title="0">if peerID == t.masterPeer </span><span class="cov0" title="0">{
                lastNo := t.fromNo + uint64(len(t.downloadInfoList))
                t.log.Debug("masterPeer deliverHeaderMsg. lastNo=%d fromNo:%d header.height:%d", lastNo, t.fromNo, headers[0].Height)
                if lastNo != headers[0].Height </span><span class="cov0" title="0">{
                        return errMasterHeadersNotMatch
                }</span>
                <span class="cov0" title="0">for _, h := range headers </span><span class="cov0" title="0">{
                        t.downloadInfoList = append(t.downloadInfoList, &amp;downloadInfo{
                                header: h,
                                status: taskStatusIdle,
                        })
                }</span>
        }

        <span class="cov0" title="0">headInfo, ok := t.peersHeaderMap[peerID]
        if !ok </span><span class="cov0" title="0">{
                return errHeadInfoNotFound
        }</span>

        <span class="cov0" title="0">for _, h := range headers </span><span class="cov0" title="0">{
                headInfo.headers[h.Height] = h
                if headInfo.maxNo &lt; h.Height </span><span class="cov0" title="0">{
                        headInfo.maxNo = h.Height
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// deliverBlockMsg recved blocks msg from peer.
func (t *taskMgr) deliverBlockMsg(peerID string, blocks []*types.Block) <span class="cov0" title="0">{
        t.lock.Lock()
        defer t.lock.Unlock()
        for _, b := range blocks </span><span class="cov0" title="0">{
                headInfo := t.downloadInfoList[int(b.Header.Height-t.fromNo)]
                if headInfo.peerID != peerID </span><span class="cov0" title="0">{
                        t.log.Info("Recved block from different peer, discard this block. peerID=%s", peerID)
                        continue</span>
                }

                <span class="cov0" title="0">headInfo.block = b
                headInfo.status = taskStatusWaitProcessing
                t.downloadedNum++</span>
        }
}
</pre>
		
		<pre class="file" id="file122" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package seele

import (
        "encoding/hex"
        "errors"
        "fmt"
        "math/big"
        "sync"

        "github.com/hashicorp/golang-lru"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/p2p"
        "github.com/seeleteam/go-seele/seele/download"
)

const (
        // DiscHandShakeErr peer handshake error
        DiscHandShakeErr = "disconnect because got handshake error"

        maxKnownTxs    = 32768 // Maximum transactions hashes to keep in the known list
        maxKnownBlocks = 1024  // Maximum block hashes to keep in the known list
)

var (
        errMsgNotMatch     = errors.New("Message not match")
        errNetworkNotMatch = errors.New("NetworkID not match")
)

// PeerInfo represents a short summary of a connected peer.
type PeerInfo struct {
        Version    uint     `json:"version"`    // Seele protocol version negotiated
        Difficulty *big.Int `json:"difficulty"` // Total difficulty of the peer's blockchain
        Head       string   `json:"head"`       // SHA3 hash of the peer's best owned block
}

type peer struct {
        *p2p.Peer
        peerID    common.Address // id of the peer
        peerStrID string
        version   uint // Seele protocol version negotiated
        head      common.Hash
        td        *big.Int // total difficulty
        lock      sync.RWMutex

        rw p2p.MsgReadWriter // the read write method for this peer

        knownTxs    *lru.Cache // Set of transaction hashes known by this peer
        knownBlocks *lru.Cache // Set of block hashes known by this peer

        log *log.SeeleLog
}

func idToStr(id common.Address) string <span class="cov8" title="1">{
        return fmt.Sprintf("%x", id[:8])
}</span>

func newPeer(version uint, p *p2p.Peer, rw p2p.MsgReadWriter, log *log.SeeleLog) *peer <span class="cov8" title="1">{
        knownTxsCache, err := lru.New(maxKnownTxs)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">knownBlockCache, err := lru.New(maxKnownBlocks)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return &amp;peer{
                Peer:        p,
                version:     version,
                td:          big.NewInt(0),
                peerID:      p.Node.ID,
                peerStrID:   idToStr(p.Node.ID),
                knownTxs:    knownTxsCache,
                knownBlocks: knownBlockCache,
                rw:          rw,
                log:         log,
        }</span>
}

// Info gathers and returns a collection of metadata known about a peer.
func (p *peer) Info() *PeerInfo <span class="cov8" title="1">{
        hash, td := p.Head()

        return &amp;PeerInfo{
                Version:    p.version,
                Difficulty: td,
                Head:       hex.EncodeToString(hash[0:]),
        }
}</span>

func (p *peer) sendTransactionHash(txHash common.Hash) error <span class="cov0" title="0">{
        if p.knownTxs.Contains(txHash) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">buff := common.SerializePanic(txHash)

        if common.PrintExplosionLog </span><span class="cov0" title="0">{
                p.log.Debug("peer send [transactionHashMsgCode] with size %d byte", len(buff))
        }</span>
        <span class="cov0" title="0">err := p2p.SendMessage(p.rw, transactionHashMsgCode, buff)
        if err == nil </span><span class="cov0" title="0">{
                p.knownTxs.Add(txHash, nil)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (p *peer) sendTransactionRequest(txHash common.Hash) error <span class="cov0" title="0">{
        buff := common.SerializePanic(txHash)

        if common.PrintExplosionLog </span><span class="cov0" title="0">{
                p.log.Debug("peer send [transactionRequestMsgCode] with size %d byte", len(buff))
        }</span>
        <span class="cov0" title="0">return p2p.SendMessage(p.rw, transactionRequestMsgCode, buff)</span>
}

func (p *peer) sendTransaction(tx *types.Transaction) error <span class="cov0" title="0">{
        return p.sendTransactions([]*types.Transaction{tx})
}</span>

func (p *peer) SendBlockHash(blockHash common.Hash) error <span class="cov0" title="0">{
        if p.knownBlocks.Contains(blockHash) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">buff := common.SerializePanic(blockHash)

        p.log.Debug("peer send [blockHashMsgCode] with size %d byte", len(buff))
        err := p2p.SendMessage(p.rw, blockHashMsgCode, buff)
        if err == nil </span><span class="cov0" title="0">{
                p.knownBlocks.Add(blockHash, nil)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (p *peer) SendBlockRequest(blockHash common.Hash) error <span class="cov0" title="0">{
        buff := common.SerializePanic(blockHash)

        p.log.Debug("peer send [blockRequestMsgCode] with size %d byte", len(buff))
        return p2p.SendMessage(p.rw, blockRequestMsgCode, buff)
}</span>

func (p *peer) sendTransactions(txs []*types.Transaction) error <span class="cov0" title="0">{
        buff := common.SerializePanic(txs)

        if common.PrintExplosionLog </span><span class="cov0" title="0">{
                p.log.Debug("peer send [transactionsMsgCode] with length %d, size %d byte", len(txs), len(buff))
        }</span>

        <span class="cov0" title="0">return p2p.SendMessage(p.rw, transactionsMsgCode, buff)</span>
}

func (p *peer) SendBlock(block *types.Block) error <span class="cov0" title="0">{
        buff := common.SerializePanic(block)

        p.log.Debug("peer send [blockMsgCode] with height %d, size %d byte", block.Header.Height, len(buff))
        return p2p.SendMessage(p.rw, blockMsgCode, buff)
}</span>

// Head retrieves a copy of the current head hash and total difficulty.
func (p *peer) Head() (hash common.Hash, td *big.Int) <span class="cov8" title="1">{
        p.lock.RLock()
        defer p.lock.RUnlock()

        copy(hash[:], p.head[:])
        return hash, new(big.Int).Set(p.td)
}</span>

// SetHead updates the head hash and total difficulty of the peer.
func (p *peer) SetHead(hash common.Hash, td *big.Int) <span class="cov8" title="1">{
        p.lock.Lock()
        defer p.lock.Unlock()

        copy(p.head[:], hash[:])
        p.td.Set(td)
}</span>

// RequestHeadersByHashOrNumber fetches a batch of blocks' headers corresponding to the
// specified header query, based on the hash of an origin block.
func (p *peer) RequestHeadersByHashOrNumber(magic uint32, origin common.Hash, num uint64, amount int, reverse bool) error <span class="cov0" title="0">{
        query := &amp;blockHeadersQuery{
                Magic:   magic,
                Hash:    origin,
                Number:  num,
                Amount:  uint64(amount),
                Reverse: reverse,
        }

        buff := common.SerializePanic(query)
        p.log.Debug("peer send [downloader.GetBlockHeadersMsg] with size %d byte peerid:%s", len(buff), p.peerStrID)
        return p2p.SendMessage(p.rw, downloader.GetBlockHeadersMsg, buff)
}</span>

func (p *peer) sendBlockHeaders(magic uint32, headers []*types.BlockHeader) error <span class="cov0" title="0">{
        sendMsg := &amp;downloader.BlockHeadersMsgBody{
                Magic:   magic,
                Headers: headers,
        }
        buff := common.SerializePanic(sendMsg)

        p.log.Debug("peer send [downloader.BlockHeadersMsg] with length %d size %d byte peerid:%s", len(headers), len(buff), p.peerStrID)
        return p2p.SendMessage(p.rw, downloader.BlockHeadersMsg, buff)
}</span>

// RequestBlocksByHashOrNumber fetches a batch of blocks corresponding to the
// specified header query, based on the hash of an origin block.
func (p *peer) RequestBlocksByHashOrNumber(magic uint32, origin common.Hash, num uint64, amount int) error <span class="cov0" title="0">{
        query := &amp;blocksQuery{
                Magic:  magic,
                Hash:   origin,
                Number: num,
                Amount: uint64(amount),
        }
        buff := common.SerializePanic(query)

        p.log.Debug("peer send [downloader.GetBlocksMsg] query with size %d byte", len(buff))
        return p2p.SendMessage(p.rw, downloader.GetBlocksMsg, buff)
}</span>

func (p *peer) sendBlocks(magic uint32, blocks []*types.Block) error <span class="cov0" title="0">{
        sendMsg := &amp;downloader.BlocksMsgBody{
                Magic:  magic,
                Blocks: blocks,
        }
        buff := common.SerializePanic(sendMsg)

        p.log.Debug("peer send [downloader.BlocksMsg] with length: %d, size:%d byte peerid:%s", len(blocks), len(buff), p.peerStrID)
        return p2p.SendMessage(p.rw, downloader.BlocksMsg, buff)
}</span>

func (p *peer) sendHeadStatus(msg *chainHeadStatus) error <span class="cov0" title="0">{
        buff := common.SerializePanic(msg)

        p.log.Debug("peer send [statusChainHeadMsgCode] with size %d byte", len(buff))
        return p2p.SendMessage(p.rw, statusChainHeadMsgCode, buff)
}</span>

// handShake exchange networkid td etc between two connected peers.
func (p *peer) handShake(networkID uint64, td *big.Int, head common.Hash, genesis common.Hash) error <span class="cov0" title="0">{
        msg := &amp;statusData{
                ProtocolVersion: uint32(SeeleVersion),
                NetworkID:       networkID,
                TD:              td,
                CurrentBlock:    head,
                GenesisBlock:    genesis,
        }

        if err := p2p.SendMessage(p.rw, statusDataMsgCode, common.SerializePanic(msg)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">retMsg, err := p.rw.ReadMsg()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if retMsg.Code != statusDataMsgCode </span><span class="cov0" title="0">{
                return errMsgNotMatch
        }</span>

        <span class="cov0" title="0">var retStatusMsg statusData
        if err = common.Deserialize(retMsg.Payload, &amp;retStatusMsg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if retStatusMsg.NetworkID != networkID || retStatusMsg.GenesisBlock != genesis </span><span class="cov0" title="0">{
                return errNetworkNotMatch
        }</span>

        <span class="cov0" title="0">p.head = retStatusMsg.CurrentBlock
        p.td = retStatusMsg.TD
        return nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package seele

import (
        "math/big"
        "sync"

        "github.com/seeleteam/go-seele/common"
)

type peerSet struct {
        peerMap    map[common.Address]*peer
        shardPeers [1 + common.ShardCount]map[common.Address]*peer
        lock       sync.RWMutex
}

func newPeerSet() *peerSet <span class="cov8" title="1">{
        ps := &amp;peerSet{
                peerMap: make(map[common.Address]*peer),
                lock:    sync.RWMutex{},
        }

        for i := 0; i &lt; 1+common.ShardCount; i++ </span><span class="cov8" title="1">{
                ps.shardPeers[i] = make(map[common.Address]*peer)
        }</span>

        <span class="cov8" title="1">return ps</span>
}

func (p *peerSet) bestPeer(shard uint) *peer <span class="cov0" title="0">{
        var (
                bestPeer *peer
                bestTd   *big.Int
        )

        p.ForEach(shard, func(p *peer) bool </span><span class="cov0" title="0">{
                if _, td := p.Head(); bestPeer == nil || td.Cmp(bestTd) &gt; 0 </span><span class="cov0" title="0">{
                        bestPeer, bestTd = p, td
                }</span>

                <span class="cov0" title="0">return true</span>
        })

        <span class="cov0" title="0">return bestPeer</span>
}

func (p *peerSet) Find(address common.Address) *peer <span class="cov8" title="1">{
        p.lock.RLock()
        defer p.lock.RUnlock()

        return p.peerMap[address]
}</span>

func (p *peerSet) Remove(address common.Address) <span class="cov8" title="1">{
        p.lock.Lock()
        defer p.lock.Unlock()

        result := p.peerMap[address]
        if result != nil </span><span class="cov8" title="1">{
                delete(p.peerMap, address)
                delete(p.shardPeers[result.Node.Shard], address)
        }</span>
}

func (p *peerSet) Add(pe *peer) <span class="cov8" title="1">{
        p.lock.Lock()
        defer p.lock.Unlock()

        address := pe.Node.ID
        result := p.peerMap[address]
        if result != nil </span><span class="cov8" title="1">{
                delete(p.peerMap, address)
                delete(p.shardPeers[result.Node.Shard], address)
        }</span>

        <span class="cov8" title="1">p.peerMap[address] = pe
        p.shardPeers[pe.Node.Shard][address] = pe</span>
}

func (p *peerSet) ForEach(shard uint, handle func(*peer) bool) <span class="cov8" title="1">{
        p.lock.RLock()
        defer p.lock.RUnlock()

        for _, v := range p.shardPeers[shard] </span><span class="cov8" title="1">{
                if !handle(v) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
}

func (p *peerSet) ForEachAll(handle func(*peer) bool) <span class="cov0" title="0">{
        p.lock.RLock()
        defer p.lock.RUnlock()

        for _, v := range p.peerMap </span><span class="cov0" title="0">{
                if !handle(v) </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}

func (p *peerSet) getPeerByShard(shard uint) []*peer <span class="cov0" title="0">{
        p.lock.RLock()
        defer p.lock.RUnlock()

        value := make([]*peer, len(p.shardPeers[shard]))
        index := 0
        for _, v := range p.shardPeers[shard] </span><span class="cov0" title="0">{
                value[index] = v
                index++
        }</span>

        <span class="cov0" title="0">return value</span>
}

func (p *peerSet) getPeerCountByShard(shard uint) int <span class="cov0" title="0">{
        p.lock.RLock()
        defer p.lock.RUnlock()

        return len(p.shardPeers[shard])
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package seele

import (
        "errors"
        "sync"
        "time"

        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/core"
        "github.com/seeleteam/go-seele/core/types"
        "github.com/seeleteam/go-seele/event"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/p2p"
        "github.com/seeleteam/go-seele/seele/download"
)

var (
        errSyncFinished = errors.New("Sync Finished!")
)

var (
        transactionHashMsgCode    uint16 = 0
        transactionRequestMsgCode uint16 = 1
        transactionsMsgCode       uint16 = 2
        blockHashMsgCode          uint16 = 3
        blockRequestMsgCode       uint16 = 4
        blockMsgCode              uint16 = 5

        statusDataMsgCode      uint16 = 6
        statusChainHeadMsgCode uint16 = 7

        protocolMsgCodeLength uint16 = 13
)

func codeToStr(code uint16) string <span class="cov0" title="0">{
        switch code </span>{
        case transactionHashMsgCode:<span class="cov0" title="0">
                return "transactionHashMsgCode"</span>
        case transactionRequestMsgCode:<span class="cov0" title="0">
                return "transactionRequestMsgCode"</span>
        case transactionsMsgCode:<span class="cov0" title="0">
                return "transactionsMsgCode"</span>
        case blockHashMsgCode:<span class="cov0" title="0">
                return "blockHashMsgCode"</span>
        case blockRequestMsgCode:<span class="cov0" title="0">
                return "blockRequestMsgCode"</span>
        case blockMsgCode:<span class="cov0" title="0">
                return "blockMsgCode"</span>
        case statusDataMsgCode:<span class="cov0" title="0">
                return "statusDataMsgCode"</span>
        case statusChainHeadMsgCode:<span class="cov0" title="0">
                return "statusChainHeadMsgCode"</span>
        }

        <span class="cov0" title="0">return downloader.CodeToStr(code)</span>
}

// SeeleProtocol service implementation of seele
type SeeleProtocol struct {
        p2p.Protocol
        peerSet *peerSet

        networkID  uint64
        downloader *downloader.Downloader
        txPool     *core.TransactionPool
        chain      *core.Blockchain

        wg     sync.WaitGroup
        quitCh chan struct{}
        syncCh chan struct{}
        log    *log.SeeleLog
}

// Downloader return a pointer of the downloader
func (s *SeeleProtocol) Downloader() *downloader.Downloader <span class="cov0" title="0">{ return s.downloader }</span>

// NewSeeleProtocol create SeeleProtocol
func NewSeeleProtocol(seele *SeeleService, log *log.SeeleLog) (s *SeeleProtocol, err error) <span class="cov8" title="1">{
        s = &amp;SeeleProtocol{
                Protocol: p2p.Protocol{
                        Name:    SeeleProtoName,
                        Version: SeeleVersion,
                        Length:  protocolMsgCodeLength,
                },
                networkID:  seele.networkID,
                txPool:     seele.TxPool(),
                chain:      seele.BlockChain(),
                downloader: downloader.NewDownloader(seele.BlockChain()),
                log:        log,
                quitCh:     make(chan struct{}),
                syncCh:     make(chan struct{}),

                peerSet: newPeerSet(),
        }

        s.Protocol.AddPeer = s.handleAddPeer
        s.Protocol.DeletePeer = s.handleDelPeer
        s.Protocol.GetPeer = s.handleGetPeer

        event.TransactionInsertedEventManager.AddAsyncListener(s.handleNewTx)
        event.BlockMinedEventManager.AddAsyncListener(s.handleNewMinedBlock)
        return s, nil
}</span>

func (sp *SeeleProtocol) Start() <span class="cov0" title="0">{
        sp.log.Debug("SeeleProtocol.Start called!")
        go sp.syncer()
}</span>

// Stop stops protocol, called when seeleService quits.
func (sp *SeeleProtocol) Stop() <span class="cov0" title="0">{
        event.BlockMinedEventManager.RemoveListener(sp.handleNewMinedBlock)
        event.TransactionInsertedEventManager.RemoveListener(sp.handleNewTx)
        close(sp.quitCh)
        close(sp.syncCh)
        sp.wg.Wait()
}</span>

// syncer try to synchronise with remote peer
func (sp *SeeleProtocol) syncer() <span class="cov0" title="0">{
        defer sp.downloader.Terminate()
        defer sp.wg.Done()
        sp.wg.Add(1)

        forceSync := time.NewTicker(forceSyncInterval)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sp.syncCh:<span class="cov0" title="0">
                        go sp.synchronise(sp.peerSet.bestPeer(common.LocalShardNumber))</span>
                case &lt;-forceSync.C:<span class="cov0" title="0">
                        go sp.synchronise(sp.peerSet.bestPeer(common.LocalShardNumber))</span>
                case &lt;-sp.quitCh:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (sp *SeeleProtocol) synchronise(p *peer) <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if common.PrintExplosionLog </span><span class="cov0" title="0">{
                sp.log.Debug("sp.synchronise called.")
        }</span>

        <span class="cov0" title="0">block := sp.chain.CurrentBlock()
        localTD, err := sp.chain.GetStore().GetBlockTotalDifficulty(block.HeaderHash)
        if err != nil </span><span class="cov0" title="0">{
                sp.log.Error("sp.synchronise GetBlockTotalDifficulty err.[%s]", err)
                return
        }</span>
        <span class="cov0" title="0">pHead, pTd := p.Head()

        // if total difficulty is not smaller than remote peer td, then do not need synchronise.
        if localTD.Cmp(pTd) &gt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = sp.downloader.Synchronise(p.peerStrID, pHead, pTd, localTD)
        if err != nil </span><span class="cov0" title="0">{
                if err == downloader.ErrIsSynchronising </span><span class="cov0" title="0">{
                        sp.log.Info("exit synchronise as it is already running.")
                }</span><span class="cov0" title="0"> else {
                        sp.log.Error("synchronise err. %s", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        //broadcast chain head
        <span class="cov0" title="0">sp.broadcastChainHead()</span>
}

func (sp *SeeleProtocol) broadcastChainHead() <span class="cov0" title="0">{
        block := sp.chain.CurrentBlock()
        head := block.HeaderHash
        localTD, err := sp.chain.GetStore().GetBlockTotalDifficulty(head)
        if err != nil </span><span class="cov0" title="0">{
                sp.log.Error("broadcastChainHead GetBlockTotalDifficulty err. %s", err)
                return
        }</span>

        <span class="cov0" title="0">status := &amp;chainHeadStatus{
                TD:           localTD,
                CurrentBlock: head,
        }
        sp.peerSet.ForEach(common.LocalShardNumber, func(peer *peer) bool </span><span class="cov0" title="0">{
                err := peer.sendHeadStatus(status)
                if err != nil </span><span class="cov0" title="0">{
                        sp.log.Warn("send chain head info failed %s", err)
                }</span>
                <span class="cov0" title="0">return true</span>
        })
}

// syncTransactions sends pending transactions to remote peer.
func (sp *SeeleProtocol) syncTransactions(p *peer) <span class="cov0" title="0">{
        defer sp.wg.Done()
        sp.wg.Add(1)
        pending := sp.txPool.GetTransactions(false, true)

        sp.log.Debug("syncTransactions peerid:%s pending length:%d", p.peerStrID, len(pending))
        if len(pending) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var (
                resultCh = make(chan error, 1)
                curPos   = 0
        )

        send := func(pos int) </span><span class="cov0" title="0">{
                // sends txs from pos
                needSend := len(pending) - pos
                if needSend &gt; txsyncPackSize </span><span class="cov0" title="0">{
                        needSend = txsyncPackSize
                }</span>

                <span class="cov0" title="0">if needSend == 0 </span><span class="cov0" title="0">{
                        resultCh &lt;- errSyncFinished
                        return
                }</span>
                <span class="cov0" title="0">curPos = curPos + needSend
                go func() </span><span class="cov0" title="0">{ resultCh &lt;- p.sendTransactions(pending[pos : pos+needSend]) }</span>()
        }

        <span class="cov0" title="0">send(curPos)
loopOut:
        for </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-resultCh:<span class="cov0" title="0">
                        if err == errSyncFinished || err != nil </span><span class="cov0" title="0">{
                                break loopOut</span>
                        }
                        <span class="cov0" title="0">send(curPos)</span>
                case &lt;-sp.quitCh:<span class="cov0" title="0">
                        break loopOut</span>
                }
        }
        <span class="cov0" title="0">close(resultCh)</span>
}

func (p *SeeleProtocol) handleNewTx(e event.Event) <span class="cov0" title="0">{
        if common.PrintExplosionLog </span><span class="cov0" title="0">{
                p.log.Debug("find new tx")
        }</span>

        <span class="cov0" title="0">tx := e.(*types.Transaction)

        // find shardId by tx from address.
        shardId := tx.Data.From.Shard()
        p.peerSet.ForEach(shardId, func(peer *peer) bool </span><span class="cov0" title="0">{
                if err := peer.sendTransactionHash(tx.Hash); err != nil </span><span class="cov0" title="0">{
                        p.log.Warn("send transaction to %s failed %s", peer.Node.GetUDPAddr(), err)
                }</span>
                <span class="cov0" title="0">return true</span>
        })
}

func (p *SeeleProtocol) handleNewMinedBlock(e event.Event) <span class="cov0" title="0">{
        block := e.(*types.Block)

        p.peerSet.ForEach(common.LocalShardNumber, func(peer *peer) bool </span><span class="cov0" title="0">{
                err := peer.SendBlockHash(block.HeaderHash)
                if err != nil </span><span class="cov0" title="0">{
                        p.log.Warn("send mined block hash failed %s", err.Error())
                }</span>
                <span class="cov0" title="0">return true</span>
        })

        <span class="cov0" title="0">p.log.Debug("handleNewMinedBlock broadcast chainhead changed. new block: %d %s &lt;- %s ",
                block.Header.Height, block.HeaderHash.ToHex(), block.Header.PreviousBlockHash.ToHex())

        p.broadcastChainHead()</span>
}

func (p *SeeleProtocol) handleAddPeer(p2pPeer *p2p.Peer, rw p2p.MsgReadWriter) <span class="cov0" title="0">{
        if p.peerSet.Find(p2pPeer.Node.ID) != nil </span><span class="cov0" title="0">{
                p.log.Error("handleAddPeer called, but peer of this public-key has already existed, so need quit!")
                return
        }</span>

        <span class="cov0" title="0">newPeer := newPeer(SeeleVersion, p2pPeer, rw, p.log)

        block := p.chain.CurrentBlock()
        head := block.HeaderHash
        localTD, err := p.chain.GetStore().GetBlockTotalDifficulty(head)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := newPeer.handShake(p.networkID, localTD, head, common.EmptyHash); err != nil </span><span class="cov0" title="0">{
                p.log.Error("handleAddPeer err. %s", err)
                newPeer.Disconnect(DiscHandShakeErr)
                return
        }</span>

        <span class="cov0" title="0">p.log.Info("add peer %s -&gt; %s to SeeleProtocol.", p2pPeer.LocalAddr(), p2pPeer.RemoteAddr())
        p.peerSet.Add(newPeer)
        p.downloader.RegisterPeer(newPeer.peerStrID, newPeer)
        go p.syncTransactions(newPeer)
        go p.handleMsg(newPeer)</span>
}

func (s *SeeleProtocol) handleGetPeer(address common.Address) interface{} <span class="cov0" title="0">{
        if p := s.peerSet.peerMap[address]; p != nil </span><span class="cov0" title="0">{
                return p.Info()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *SeeleProtocol) handleDelPeer(peer *p2p.Peer) <span class="cov0" title="0">{
        s.log.Debug("delete peer from peer set. %s", peer.Node)
        s.peerSet.Remove(peer.Node.ID)
        s.downloader.UnRegisterPeer(idToStr(peer.Node.ID))
}</span>

func (p *SeeleProtocol) SendDifferentShardTx(tx *types.Transaction, shard uint) <span class="cov0" title="0">{
        sendTxFun := func(peer *peer) bool </span><span class="cov0" title="0">{
                if !peer.knownTxs.Contains(tx.Hash) </span><span class="cov0" title="0">{
                        err := peer.sendTransaction(tx)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("send transaction to peer %s failed, tx hash %s", peer.Node, tx.Hash)
                                return true
                        }</span>

                        <span class="cov0" title="0">peer.knownTxs.Add(tx.Hash, nil)</span>
                }

                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">if p.peerSet.getPeerCountByShard(shard) &gt; 0 </span><span class="cov0" title="0">{
                p.peerSet.ForEach(shard, sendTxFun)
        }</span><span class="cov0" title="0"> else {
                p.peerSet.ForEachAll(sendTxFun)
        }</span>
}

func (p *SeeleProtocol) handleMsg(peer *peer) <span class="cov0" title="0">{
handler:
        for </span><span class="cov0" title="0">{
                msg, err := peer.rw.ReadMsg()
                if err != nil </span><span class="cov0" title="0">{
                        p.log.Error("get error when read msg from %s, %s", peer.peerStrID, err)
                        break</span>
                }

                // skip unsupported message from different shard peer
                <span class="cov0" title="0">if peer.Node.Shard != common.LocalShardNumber </span><span class="cov0" title="0">{
                        if msg.Code != transactionsMsgCode </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">if common.PrintExplosionLog </span><span class="cov0" title="0">{
                        p.log.Debug("got msg with type:%s", codeToStr(msg.Code))
                }</span>

                <span class="cov0" title="0">switch msg.Code </span>{
                case transactionHashMsgCode:<span class="cov0" title="0">
                        var txHash common.Hash
                        err := common.Deserialize(msg.Payload, &amp;txHash)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("deserialize transaction hash msg failed %s", err.Error())
                                continue</span>
                        }

                        <span class="cov0" title="0">if common.PrintExplosionLog </span><span class="cov0" title="0">{
                                p.log.Debug("got tx hash %s", txHash.ToHex())
                        }</span>

                        <span class="cov0" title="0">if !peer.knownTxs.Contains(txHash) </span><span class="cov0" title="0">{
                                peer.knownTxs.Add(txHash, nil) //update peer known transaction
                                err := peer.sendTransactionRequest(txHash)
                                if err != nil </span><span class="cov0" title="0">{
                                        p.log.Warn("send transaction request msg failed %s", err.Error())
                                        break handler</span>
                                }
                        }<span class="cov0" title="0"> else {
                                if common.PrintExplosionLog </span><span class="cov0" title="0">{
                                        p.log.Debug("already have this tx %s", txHash.ToHex())
                                }</span>
                        }

                case transactionRequestMsgCode:<span class="cov0" title="0">
                        var txHash common.Hash
                        err := common.Deserialize(msg.Payload, &amp;txHash)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("deserialize transaction request msg failed %s", err.Error())
                                continue</span>
                        }

                        <span class="cov0" title="0">if common.PrintExplosionLog </span><span class="cov0" title="0">{
                                p.log.Debug("got tx request %s", txHash.ToHex())
                        }</span>

                        <span class="cov0" title="0">tx := p.txPool.GetTransaction(txHash)
                        if tx == nil </span><span class="cov0" title="0">{
                                p.log.Debug("[transactionRequestMsgCode] not found tx in tx pool %s", txHash.ToHex())
                                continue</span>
                        }

                        <span class="cov0" title="0">err = peer.sendTransaction(tx)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("send transaction msg failed %s", err.Error())
                                break handler</span>
                        }

                case transactionsMsgCode:<span class="cov0" title="0">
                        var txs []*types.Transaction
                        err := common.Deserialize(msg.Payload, &amp;txs)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("deserialize transaction msg failed %s", err.Error())
                                break</span>
                        }

                        <span class="cov0" title="0">if common.PrintExplosionLog </span><span class="cov0" title="0">{
                                p.log.Debug("received %d transactions", len(txs))
                        }</span>

                        <span class="cov0" title="0">for _, tx := range txs </span><span class="cov0" title="0">{
                                peer.knownTxs.Add(tx.Hash, nil)
                                shard := tx.Data.From.Shard()
                                if shard != common.LocalShardNumber </span><span class="cov0" title="0">{
                                        p.SendDifferentShardTx(tx, shard)
                                        continue</span>
                                }<span class="cov0" title="0"> else {
                                        p.txPool.AddTransaction(tx)
                                }</span>
                        }

                case blockHashMsgCode:<span class="cov0" title="0">
                        var blockHash common.Hash
                        err := common.Deserialize(msg.Payload, &amp;blockHash)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("deserialize block hash msg failed %s", err.Error())
                                continue</span>
                        }

                        <span class="cov0" title="0">p.log.Debug("got block hash msg %s", blockHash.ToHex())

                        if !peer.knownBlocks.Contains(blockHash) </span><span class="cov0" title="0">{
                                peer.knownBlocks.Add(blockHash, nil)
                                err := peer.SendBlockRequest(blockHash)
                                if err != nil </span><span class="cov0" title="0">{
                                        p.log.Warn("send block request msg failed %s", err.Error())
                                        break handler</span>
                                }
                        }

                case blockRequestMsgCode:<span class="cov0" title="0">
                        var blockHash common.Hash
                        err := common.Deserialize(msg.Payload, &amp;blockHash)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("deserialize block request msg failed %s", err.Error())
                                continue</span>
                        }

                        <span class="cov0" title="0">p.log.Debug("got block request msg %s", blockHash.ToHex())
                        block, err := p.chain.GetStore().GetBlock(blockHash)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("not found request block %s", err.Error())
                                continue</span>
                        }

                        <span class="cov0" title="0">err = peer.SendBlock(block)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("send block msg failed %s", err.Error())
                        }</span>

                case blockMsgCode:<span class="cov0" title="0">
                        var block types.Block
                        err := common.Deserialize(msg.Payload, &amp;block)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("deserialize block msg failed %s", err.Error())
                                continue</span>
                        }

                        <span class="cov0" title="0">p.log.Info("got block message and save it. height:%d, hash:%s", block.Header.Height, block.HeaderHash.ToHex())
                        peer.knownBlocks.Add(block.HeaderHash, nil)
                        if block.GetShardNumber() == common.LocalShardNumber </span><span class="cov0" title="0">{
                                // @todo need to make sure WriteBlock handle block fork
                                p.chain.WriteBlock(&amp;block)
                        }</span>

                case downloader.GetBlockHeadersMsg:<span class="cov0" title="0">
                        var query blockHeadersQuery
                        err := common.Deserialize(msg.Payload, &amp;query)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Error("deserialize downloader.GetBlockHeadersMsg failed, quit! %s", err.Error())
                                break</span>
                        }
                        <span class="cov0" title="0">var headList []*types.BlockHeader
                        var head *types.BlockHeader
                        orgNum := query.Number

                        if query.Hash != common.EmptyHash </span><span class="cov0" title="0">{
                                if head, err = p.chain.GetStore().GetBlockHeader(query.Hash); err != nil </span><span class="cov0" title="0">{
                                        p.log.Error("HandleMsg GetBlockHeader err from query hash. %s", err)
                                        break</span>
                                }
                                <span class="cov0" title="0">orgNum = head.Height</span>
                        }

                        <span class="cov0" title="0">p.log.Debug("Received downloader.GetBlockHeadersMsg start %d, amount %d", orgNum, query.Amount)
                        maxHeight := p.chain.CurrentBlock().Header.Height
                        for cnt := uint64(0); cnt &lt; query.Amount; cnt++ </span><span class="cov0" title="0">{
                                var curNum uint64
                                if query.Reverse </span><span class="cov0" title="0">{
                                        curNum = orgNum - cnt
                                }</span><span class="cov0" title="0"> else {
                                        curNum = orgNum + cnt
                                }</span>

                                <span class="cov0" title="0">if curNum &gt; maxHeight </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">hash, err := p.chain.GetStore().GetBlockHash(curNum)
                                if err != nil </span><span class="cov0" title="0">{
                                        p.log.Error("get error when get block hash by height. err=%s curNum=%d", err, curNum)
                                        break</span>
                                }

                                <span class="cov0" title="0">if head, err = p.chain.GetStore().GetBlockHeader(hash); err != nil </span><span class="cov0" title="0">{
                                        p.log.Error("get error when get block by block hash. err: %s, hash:%s", err, hash)
                                        break</span>
                                }
                                <span class="cov0" title="0">headList = append(headList, head)</span>
                        }

                        <span class="cov0" title="0">if err = peer.sendBlockHeaders(query.Magic, headList); err != nil </span><span class="cov0" title="0">{
                                p.log.Error("HandleMsg sendBlockHeaders err. %s", err)
                                break handler</span>
                        }
                        <span class="cov0" title="0">p.log.Debug("send downloader.sendBlockHeaders. len=%d", len(headList))</span>

                case downloader.GetBlocksMsg:<span class="cov0" title="0">
                        p.log.Debug("Received downloader.GetBlocksMsg")
                        var query blocksQuery
                        err := common.Deserialize(msg.Payload, &amp;query)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Error("deserialize downloader.GetBlocksMsg failed, quit! %s", err.Error())
                                break</span>
                        }

                        <span class="cov0" title="0">var blocksL []*types.Block
                        var head *types.BlockHeader
                        var block *types.Block
                        orgNum := query.Number
                        if query.Hash != common.EmptyHash </span><span class="cov0" title="0">{
                                if head, err = p.chain.GetStore().GetBlockHeader(query.Hash); err != nil </span><span class="cov0" title="0">{
                                        p.log.Error("HandleMsg GetBlockHeader err. %s", err)
                                        break</span>
                                }
                                <span class="cov0" title="0">orgNum = head.Height</span>
                        }

                        <span class="cov0" title="0">p.log.Debug("Received downloader.GetBlocksMsg length %d, start %d, end %d", query.Amount, orgNum, orgNum+query.Amount)

                        totalLen := 0
                        var numL []uint64
                        for cnt := uint64(0); cnt &lt; query.Amount; cnt++ </span><span class="cov0" title="0">{
                                curNum := orgNum + cnt
                                hash, err := p.chain.GetStore().GetBlockHash(curNum)
                                if err != nil </span><span class="cov0" title="0">{
                                        p.log.Warn("get block with height %d failed, err %s", curNum, err)
                                        break</span>
                                }

                                <span class="cov0" title="0">if block, err = p.chain.GetStore().GetBlock(hash); err != nil </span><span class="cov0" title="0">{
                                        p.log.Error("HandleMsg GetBlocksMsg p.chain.GetStore().GetBlock err. %s", err)
                                        break handler</span>
                                }

                                <span class="cov0" title="0">curLen := len(common.SerializePanic(block))
                                if totalLen &gt; 0 &amp;&amp; (totalLen+curLen) &gt; downloader.MaxMessageLength </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">totalLen += curLen
                                blocksL = append(blocksL, block)
                                numL = append(numL, curNum)</span>
                        }

                        <span class="cov0" title="0">if len(blocksL) == 0 </span><span class="cov0" title="0">{
                                p.log.Debug("send blocks with empty")
                        }</span><span class="cov0" title="0"> else {
                                p.log.Debug("send blocks length %d, start %d, end %d", len(blocksL), blocksL[0].Header.Height, blocksL[len(blocksL)-1].Header.Height)
                        }</span>

                        <span class="cov0" title="0">if err = peer.sendBlocks(query.Magic, blocksL); err != nil </span><span class="cov0" title="0">{
                                p.log.Error("HandleMsg GetBlocksMsg sendBlocks err. %s", err)
                                break handler</span>
                        }

                        <span class="cov0" title="0">p.log.Debug("send downloader.sendBlocks")</span>

                case downloader.BlockHeadersMsg, downloader.BlocksPreMsg, downloader.BlocksMsg:<span class="cov0" title="0">
                        p.log.Debug("Received downloader Msg. %s peerid:%s", codeToStr(msg.Code), peer.peerStrID)
                        p.downloader.DeliverMsg(peer.peerStrID, &amp;msg)</span>

                case statusChainHeadMsgCode:<span class="cov0" title="0">
                        var status chainHeadStatus
                        err := common.Deserialize(msg.Payload, &amp;status)
                        if err != nil </span><span class="cov0" title="0">{
                                p.log.Error("deserialize statusChainHeadMsgCode failed, quit! %s", err.Error())
                                break</span>
                        }

                        <span class="cov0" title="0">p.log.Debug("Recved statusChainHeadMsgCode")
                        peer.SetHead(status.CurrentBlock, status.TD)
                        p.syncCh &lt;- struct{}{}</span>

                default:<span class="cov0" title="0">
                        p.log.Warn("unknown code %s", msg.Code)</span>
                }
        }

        <span class="cov0" title="0">p.handleDelPeer(peer.Peer)
        p.log.Debug("seele.peer.run out!peer=%s!", peer.peerStrID)</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package seele

import (
        "context"
        "path/filepath"

        "github.com/seeleteam/go-seele/core"
        "github.com/seeleteam/go-seele/core/store"
        "github.com/seeleteam/go-seele/database"
        "github.com/seeleteam/go-seele/database/leveldb"
        "github.com/seeleteam/go-seele/log"
        "github.com/seeleteam/go-seele/miner"
        "github.com/seeleteam/go-seele/node"
        "github.com/seeleteam/go-seele/p2p"
        rpc "github.com/seeleteam/go-seele/rpc2"
        "github.com/seeleteam/go-seele/seele/download"
)

// SeeleService implements full node service.
type SeeleService struct {
        networkID     uint64
        p2pServer     *p2p.Server
        seeleProtocol *SeeleProtocol
        log           *log.SeeleLog

        txPool         *core.TransactionPool
        chain          *core.Blockchain
        chainDB        database.Database // database used to store blocks.
        accountStateDB database.Database // database used to store account state info.
        miner          *miner.Miner
}

// ServiceContext is a collection of service configuration inherited from node
type ServiceContext struct {
        DataDir string
}

func (s *SeeleService) TxPool() *core.TransactionPool <span class="cov8" title="1">{ return s.txPool }</span>
func (s *SeeleService) BlockChain() *core.Blockchain  <span class="cov8" title="1">{ return s.chain }</span>
func (s *SeeleService) NetVersion() uint64            <span class="cov0" title="0">{ return s.networkID }</span>
func (s *SeeleService) Miner() *miner.Miner           <span class="cov0" title="0">{ return s.miner }</span>
func (s *SeeleService) Downloader() *downloader.Downloader <span class="cov0" title="0">{
        return s.seeleProtocol.Downloader()
}</span>

// NewSeeleService create SeeleService
func NewSeeleService(ctx context.Context, conf *node.Config, log *log.SeeleLog) (s *SeeleService, err error) <span class="cov8" title="1">{
        s = &amp;SeeleService{
                log:       log,
                networkID: conf.P2PConfig.NetworkID,
        }

        serviceContext := ctx.Value("ServiceContext").(ServiceContext)

        // Initialize blockchain DB.
        chainDBPath := filepath.Join(serviceContext.DataDir, BlockChainDir)
        log.Info("NewSeeleService BlockChain datadir is %s", chainDBPath)
        s.chainDB, err = leveldb.NewLevelDB(chainDBPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("NewSeeleService Create BlockChain err. %s", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">leveldb.StartMetrics(s.chainDB, "chaindb", log)

        // Initialize account state info DB.
        accountStateDBPath := filepath.Join(serviceContext.DataDir, AccountStateDir)
        log.Info("NewSeeleService account state datadir is %s", accountStateDBPath)
        s.accountStateDB, err = leveldb.NewLevelDB(accountStateDBPath)
        if err != nil </span><span class="cov0" title="0">{
                s.chainDB.Close()
                log.Error("NewSeeleService Create BlockChain err: failed to create account state DB, %s", err)
                return nil, err
        }</span>

        // initialize and validate genesis
        <span class="cov8" title="1">bcStore := store.NewCachedStore(store.NewBlockchainDatabase(s.chainDB))
        genesis := core.GetGenesis(conf.SeeleConfig.GenesisConfig)

        err = genesis.InitializeAndValidate(bcStore, s.accountStateDB)
        if err != nil </span><span class="cov0" title="0">{
                s.chainDB.Close()
                s.accountStateDB.Close()
                log.Error("NewSeeleService genesis.Initialize err. %s", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">recoveryPointFile := filepath.Join(serviceContext.DataDir, BlockChainRecoveryPointFile)
        s.chain, err = core.NewBlockchain(bcStore, s.accountStateDB, recoveryPointFile)
        if err != nil </span><span class="cov0" title="0">{
                s.chainDB.Close()
                s.accountStateDB.Close()
                log.Error("NewSeeleService init chain failed. %s", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">s.txPool, err = core.NewTransactionPool(conf.SeeleConfig.TxConf, s.chain)
        if err != nil </span><span class="cov0" title="0">{
                s.chainDB.Close()
                s.accountStateDB.Close()
                log.Error("NewSeeleService create transaction pool failed, %s", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">s.seeleProtocol, err = NewSeeleProtocol(s, log)
        if err != nil </span><span class="cov0" title="0">{
                s.chainDB.Close()
                s.accountStateDB.Close()
                log.Error("NewSeeleService create seeleProtocol err. %s", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">s.miner = miner.NewMiner(conf.SeeleConfig.Coinbase, s)

        return s, nil</span>
}

// Protocols implements node.Service, returning all the currently configured
// network protocols to start.
func (s *SeeleService) Protocols() (protos []p2p.Protocol) <span class="cov0" title="0">{
        protos = append(protos, s.seeleProtocol.Protocol)
        return
}</span>

// Start implements node.Service, starting goroutines needed by SeeleService.
func (s *SeeleService) Start(srvr *p2p.Server) error <span class="cov0" title="0">{
        s.p2pServer = srvr

        s.seeleProtocol.Start()
        return nil
}</span>

// Stop implements node.Service, terminating all internal goroutines.
func (s *SeeleService) Stop() error <span class="cov0" title="0">{
        s.seeleProtocol.Stop()

        //TODO
        // s.txPool.Stop() s.chain.Stop()
        // retries? leave it to future
        s.chainDB.Close()
        s.accountStateDB.Close()
        return nil
}</span>

// APIs implements node.Service, returning the collection of RPC services the seele package offers.
func (s *SeeleService) APIs() (apis []rpc.API) <span class="cov0" title="0">{
        return append(apis, []rpc.API{
                {
                        Namespace: "seele",
                        Version:   "1.0",
                        Service:   NewPublicSeeleAPI(s),
                        Public:    true,
                },
                {
                        Namespace: "txpool",
                        Version:   "1.0",
                        Service:   NewPrivateTransactionPoolAPI(s),
                        Public:    false,
                },
                {
                        Namespace: "download",
                        Version:   "1.0",
                        Service:   downloader.NewPrivatedownloaderAPI(s.seeleProtocol.downloader),
                        Public:    false,
                },
                {
                        Namespace: "network",
                        Version:   "1.0",
                        Service:   NewPrivateNetworkAPI(s),
                        Public:    false,
                },
                {
                        Namespace: "debug",
                        Version:   "1.0",
                        Service:   NewPrivateDebugAPI(s),
                        Public:    false,
                },
                {
                        Namespace: "miner",
                        Version:   "1.0",
                        Service:   NewPrivateMinerAPI(s),
                        Public:    false,
                },
        }...)
}</span>
</pre>
		
		<pre class="file" id="file126" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package trie

const (
        // numBranchChildren number children in branch node
        numBranchChildren int = 17 // for 0-f branches + value node; reduce the height of tree for performance

        nodeStatusDirty     nodeStatus = iota // node is newly created or modified, but not update the node hash
        nodeStatusUpdated                     // node hash updated
        nodeStatusPersisted                   // node persisted in DB, in which case the node hash also updated
)

type nodeStatus byte

// Noder interface for node
type noder interface {
        Hash() []byte                // return the node hash
        Status() nodeStatus          // return the node status
        SetHash(hash []byte)         // update the node hash
        SetStatus(status nodeStatus) // update the node status
}

// Node is trie node struct
type Node struct {
        hash   []byte     // hash of the node
        status nodeStatus // status of the node
}

// ExtensionNode is extension node struct
type ExtensionNode struct {
        Node
        Key      []byte // for shared nibbles
        NextNode noder  // for next node
}

// LeafNode is leaf node struct
type LeafNode struct {
        Node
        Key   []byte // for key-end
        Value []byte // the value of leafnode
}

// BranchNode is node for branch
type BranchNode struct {
        Node
        Children [numBranchChildren]noder
}

// hashNode is just used by NextNode of ExtensionNode
// when it does not load real node from database
type hashNode []byte

// Hash return the hash of node
func (n hashNode) Hash() []byte <span class="cov0" title="0">{
        return n
}</span>

// Status return the status of node
func (n hashNode) Status() nodeStatus <span class="cov0" title="0">{
        return nodeStatusPersisted
}</span>

// SetHash do nothing
func (n hashNode) SetHash(hash []byte) <span class="cov0" title="0">{
        panic("hashnode do not support to change hash")</span>
}

// SetStatus do nothing
func (n hashNode) SetStatus(status nodeStatus) <span class="cov0" title="0">{
        panic("hashnode do not support to change status")</span>
}

// Hash return the hash of node
func (n *Node) Hash() []byte <span class="cov8" title="1">{
        return n.hash
}</span>

// Status return the status of node
func (n *Node) Status() nodeStatus <span class="cov8" title="1">{
        return n.status
}</span>

// SetHash set the node hash
func (n *Node) SetHash(hash []byte) <span class="cov8" title="1">{
        copy(n.hash, hash)
}</span>

// SetStatus set the node status
func (n *Node) SetStatus(status nodeStatus) <span class="cov8" title="1">{
        n.status = status
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">/**
*  @file
*  @copyright defined in go-seele/LICENSE
 */

package trie

import (
        "bytes"
        "errors"
        "fmt"
        "hash"
        "io"

        "github.com/ethereum/go-ethereum/rlp"
        "github.com/seeleteam/go-seele/common"
        "github.com/seeleteam/go-seele/crypto/sha3"
        "github.com/seeleteam/go-seele/database"
)

var (
        errNodeFormat   = errors.New("node format is invalid")
        errNodeNotExist = errors.New("node not exist in db")
)

// Trie is a Merkle Patricia Trie
type Trie struct {
        db       database.Database
        root     noder     // root node of the Trie
        dbprefix []byte    // db prefix of Trie node
        sha      hash.Hash // hash calc for trie
}

// ShallowCopy returns a new trie with the same root.
func (t *Trie) ShallowCopy() (*Trie, error) <span class="cov0" title="0">{
        rootHash := t.Hash()
        t, err := NewTrie(rootHash, t.dbprefix, t.db)
        if err != nil </span><span class="cov0" title="0">{
                return t, fmt.Errorf("request hash: %s, error: %s", rootHash.ToHex(), err)
        }</span>

        <span class="cov0" title="0">return t, nil</span>
}

// NewTrie new a trie tree
// param dbprefix will be used as prefix of hash key to save db.
// because we save all of trie trees in the same db,dbprefix protects key/values for different trees
func NewTrie(root common.Hash, dbprefix []byte, db database.Database) (*Trie, error) <span class="cov8" title="1">{
        trie := &amp;Trie{
                db:       db,
                dbprefix: dbprefix,
                sha:      sha3.NewKeccak256(),
        }

        if root != common.EmptyHash </span><span class="cov8" title="1">{
                rootnode, err := trie.loadNode(root.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">trie.root = rootnode</span>
        }

        <span class="cov8" title="1">return trie, nil</span>
}

// Put add or update [key,value] in the trie
func (t *Trie) Put(key, value []byte) error <span class="cov8" title="1">{
        key = keybytesToHex(key)
        _, node, err := t.insert(t.root, key, value)
        if err == nil </span><span class="cov8" title="1">{
                t.root = node
        }</span>
        <span class="cov8" title="1">return err</span>
}

// Delete delete node with key in the trie
// return true is delete successfully;false mean the key not exist
func (t *Trie) Delete(key []byte) bool <span class="cov8" title="1">{
        if t.root != nil </span><span class="cov8" title="1">{
                key = keybytesToHex(key)
                match, newnode, err := t.delete(t.root, key)
                if err == nil &amp;&amp; match </span><span class="cov8" title="1">{
                        t.root = newnode
                }</span>
                <span class="cov8" title="1">return match</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Get get the value by key
func (t *Trie) Get(key []byte) ([]byte, bool) <span class="cov8" title="1">{
        if t.root != nil </span><span class="cov8" title="1">{
                key = keybytesToHex(key)
                val, _ := t.get(t.root, key, 0)
                if len(val) &gt; 0 </span><span class="cov8" title="1">{
                        return val, true
                }</span>
        }
        <span class="cov8" title="1">return nil, false</span>
}

// Hash return the hash of trie
func (t *Trie) Hash() common.Hash <span class="cov8" title="1">{
        if t.root != nil </span><span class="cov8" title="1">{
                buf := new(bytes.Buffer)
                t.sha.Reset()
                t.hash(t.root, buf, t.sha, nil)
                return common.BytesToHash(t.root.Hash())
        }</span>
        <span class="cov0" title="0">return common.EmptyHash</span>
}

// Commit commit the dirty node to database with given batch.
// Note, it will panic on nil batch, please use Hash() instead
// to get the root hash.
func (t *Trie) Commit(batch database.Batch) common.Hash <span class="cov8" title="1">{
        if t.root != nil </span><span class="cov8" title="1">{
                buf := new(bytes.Buffer)
                t.sha.Reset()
                t.hash(t.root, buf, t.sha, batch)
                return common.BytesToHash(t.root.Hash())
        }</span>
        <span class="cov0" title="0">return common.EmptyHash</span>
}

func (t *Trie) hash(node noder, buf *bytes.Buffer, sha hash.Hash, batch database.Batch) []byte <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // node already persisted after call Commit(batch)
        <span class="cov8" title="1">if node.Status() == nodeStatusPersisted </span><span class="cov0" title="0">{
                return node.Hash()
        }</span>

        // node hash alredy updated after call Hash()
        <span class="cov8" title="1">if node.Status() == nodeStatusUpdated &amp;&amp; batch == nil </span><span class="cov0" title="0">{
                return node.Hash()
        }</span>

        // node hash is dirty or requires to commit with specified batch
        <span class="cov8" title="1">switch n := node.(type) </span>{
        case *LeafNode:<span class="cov8" title="1">
                buf.Reset()
                rlp.Encode(buf, []interface{}{
                        n.Key,
                        n.Value,
                })</span>
        case *ExtensionNode:<span class="cov8" title="1">
                nexthash := t.hash(n.NextNode, buf, sha, batch)

                buf.Reset()
                rlp.Encode(buf, []interface{}{
                        true, //add it to diff with extension node;modify later using compact func?
                        n.Key,
                        nexthash,
                })</span>
        case *BranchNode:<span class="cov8" title="1">
                var children [numBranchChildren][]byte
                for i, child := range n.Children </span><span class="cov8" title="1">{
                        children[i] = t.hash(child, buf, sha, batch)
                }</span>

                <span class="cov8" title="1">buf.Reset()
                rlp.Encode(buf, []interface{}{
                        children,
                })</span>
        case hashNode:<span class="cov0" title="0">
                return n.Hash()</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("invalid node: %v", node))</span>
        }

        // update node hash and status if dirty
        <span class="cov8" title="1">if node.Status() == nodeStatusDirty </span><span class="cov8" title="1">{
                sha.Reset()
                sha.Write(buf.Bytes())
                hash := sha.Sum(nil)
                node.SetHash(hash)
                node.SetStatus(nodeStatusUpdated)
        }</span>

        // persist node if batch specified
        <span class="cov8" title="1">if batch != nil </span><span class="cov8" title="1">{
                batch.Put(append(t.dbprefix, node.Hash()...), buf.Bytes())
                node.SetStatus(nodeStatusPersisted)
        }</span>

        <span class="cov8" title="1">return node.Hash()</span>
}

// return true if insert succeed,it also mean node is dirty,should recalc hash
func (t *Trie) insert(node noder, key []byte, value []byte) (bool, noder, error) <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *ExtensionNode:<span class="cov8" title="1">
                return t.insertExtensionNode(n, key, value)</span>
        case *LeafNode:<span class="cov8" title="1">
                return t.insertLeafNode(n, key, value)</span>
        case *BranchNode:<span class="cov8" title="1">
                _, child, err := t.insert(n.Children[key[0]], key[1:], value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">n.Children[key[0]] = child
                n.status = nodeStatusDirty
                return true, n, nil</span>
        case hashNode:<span class="cov8" title="1">
                loadnode, err := t.loadNode(n)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">dirty, newnode, err := t.insert(loadnode, key, value)
                return dirty, newnode, err</span>
        case nil:<span class="cov8" title="1">
                newnode := &amp;LeafNode{
                        Node: Node{
                                status: nodeStatusDirty,
                                hash:   make([]byte, common.HashLength),
                        },
                        Key:   key,
                        Value: value,
                }
                return true, newnode, nil</span>
        }
        <span class="cov0" title="0">return false, nil, nil</span>
}

func (t *Trie) insertExtensionNode(n *ExtensionNode, key []byte, value []byte) (bool, noder, error) <span class="cov8" title="1">{
        matchlen := matchkeyLen(n.Key, key)
        if matchlen == len(n.Key) </span><span class="cov8" title="1">{ // key match insert in nextNode
                var dirty bool
                dirty, n.NextNode, _ = t.insert(n.NextNode, key[matchlen:], value)
                if dirty </span><span class="cov8" title="1">{
                        n.status = nodeStatusDirty
                }</span>
                <span class="cov8" title="1">return dirty, n, nil</span>
        }
        <span class="cov8" title="1">branchnode := &amp;BranchNode{
                Node: Node{
                        status: nodeStatusDirty,
                        hash:   make([]byte, common.HashLength),
                },
        }

        if matchlen != len(n.Key)-1 </span><span class="cov8" title="1">{
                branchnode.Children[n.Key[matchlen]] = n
                n.Key = n.Key[matchlen+1:]
                n.status = nodeStatusDirty
        }</span><span class="cov0" title="0"> else {
                branchnode.Children[n.Key[matchlen]] = n.NextNode
        }</span>

        <span class="cov8" title="1">var err error
        _, branchnode.Children[key[matchlen]], err = t.insert(nil, key[matchlen+1:], value)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>
        <span class="cov8" title="1">if matchlen == 0 </span><span class="cov8" title="1">{ // not match key value return branch node
                return true, branchnode, nil
        }</span>

        <span class="cov8" title="1">return true, &amp;ExtensionNode{ // have match key,return extension node
                Node: Node{
                        status: nodeStatusDirty,
                        hash:   make([]byte, common.HashLength),
                },
                Key:      key[:matchlen],
                NextNode: branchnode,
        }, nil</span>
}

func (t *Trie) insertLeafNode(n *LeafNode, key []byte, value []byte) (bool, noder, error) <span class="cov8" title="1">{
        matchlen := matchkeyLen(n.Key, key)
        if matchlen == len(n.Key) </span><span class="cov8" title="1">{ // key match, change the value of leaf node
                n.Value = value
                n.status = nodeStatusDirty
                return true, n, nil
        }</span>
        <span class="cov8" title="1">branchnode := &amp;BranchNode{
                Node: Node{
                        status: nodeStatusDirty,
                        hash:   make([]byte, common.HashLength),
                },
        }
        var err error
        branchnode.Children[n.Key[matchlen]] = n
        n.Key = n.Key[matchlen+1:]
        n.status = nodeStatusDirty

        _, branchnode.Children[key[matchlen]], err = t.insert(nil, key[matchlen+1:], value)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>
        <span class="cov8" title="1">if matchlen == 0 </span><span class="cov0" title="0">{ // not match key value return branch node
                return true, branchnode, nil
        }</span>

        <span class="cov8" title="1">return true, &amp;ExtensionNode{ // have match key,return extension node
                Node: Node{
                        status: nodeStatusDirty,
                        hash:   make([]byte, common.HashLength),
                },
                Key:      key[:matchlen],
                NextNode: branchnode,
        }, nil</span>
}

func (t *Trie) delete(node noder, key []byte) (bool, noder, error) <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *LeafNode:<span class="cov8" title="1">
                matchlen := matchkeyLen(key, n.Key)
                if matchlen == len(n.Key) </span><span class="cov8" title="1">{
                        return true, nil, nil
                }</span>
                <span class="cov0" title="0">return false, n, nil</span>
        case *ExtensionNode:<span class="cov8" title="1">
                matchlen := matchkeyLen(key, n.Key)
                if matchlen == len(n.Key) </span><span class="cov8" title="1">{
                        match, newnode, err := t.delete(n.NextNode, key[matchlen:])
                        if err == nil &amp;&amp; match </span><span class="cov8" title="1">{
                                n.status = nodeStatusDirty
                                n.NextNode = newnode
                                if newnode == nil </span><span class="cov0" title="0">{
                                        return true, nil, nil
                                }</span>
                                <span class="cov8" title="1">return true, n, nil</span>
                        }
                }
                <span class="cov8" title="1">return false, n, nil</span>
        case *BranchNode:<span class="cov8" title="1">
                match, newnode, err := t.delete(n.Children[key[0]], key[1:])
                if err == nil </span><span class="cov8" title="1">{
                        n.Children[key[0]] = newnode
                }</span>
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        n.status = nodeStatusDirty
                }</span>
                <span class="cov8" title="1">pos := -1
                count := 0
                for i, child := range n.Children </span><span class="cov8" title="1">{
                        if child != nil </span><span class="cov8" title="1">{
                                pos = i
                                count++
                        }</span>
                }
                <span class="cov8" title="1">if count == 1 </span><span class="cov8" title="1">{
                        var childnode noder
                        var err error
                        childnode = n.Children[pos]
                        if hashnode, ok := childnode.(hashNode); ok </span><span class="cov8" title="1">{
                                childnode, err = t.loadNode(hashnode)
                                if err != nil </span><span class="cov0" title="0">{
                                        return match, nil, err
                                }</span>
                        }
                        <span class="cov8" title="1">switch childnode := childnode.(type) </span>{
                        case *LeafNode:<span class="cov8" title="1">
                                newnode := &amp;LeafNode{
                                        Node: Node{
                                                status: nodeStatusDirty,
                                                hash:   make([]byte, common.HashLength),
                                        },
                                        Key:   append([]byte{byte(pos)}, childnode.Key...),
                                        Value: childnode.Value,
                                }
                                return true, newnode, nil</span>
                        case *ExtensionNode:<span class="cov8" title="1">
                                newnode := &amp;ExtensionNode{
                                        Node: Node{
                                                status: nodeStatusDirty,
                                                hash:   make([]byte, common.HashLength),
                                        },
                                        Key:      append([]byte{byte(pos)}, childnode.Key...),
                                        NextNode: childnode.NextNode,
                                }
                                return true, newnode, nil</span>
                        }
                }
                <span class="cov8" title="1">return match, n, nil</span>
        case hashNode:<span class="cov8" title="1">
                loadnode, err := t.loadNode(n)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">match, newnode, err := t.delete(loadnode, key)
                if err != nil </span><span class="cov0" title="0">{
                        return false, loadnode, err
                }</span>
                <span class="cov8" title="1">return match, newnode, nil</span>
        case nil:<span class="cov0" title="0">
                return false, nil, nil</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("invalid node: %v (%v)", n, key))</span>
        }
}

// loadNode get node from memory cache or database
func (t *Trie) loadNode(hash []byte) (noder, error) <span class="cov8" title="1">{
        //TODO need cache nodes
        key := append(t.dbprefix, hash...)
        val, err := t.db.Get(key)
        if err != nil || len(val) == 0 </span><span class="cov0" title="0">{
                return nil, errNodeNotExist
        }</span>
        <span class="cov8" title="1">return t.decodeNode(hash, val)</span>
}

// decodeNode decode node from buf byte
func (t *Trie) decodeNode(hash, value []byte) (noder, error) <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov0" title="0">{
                return nil, io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">vals, _, err := rlp.SplitList(value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">switch n, _ := rlp.CountValues(vals); n </span>{
        case 1:<span class="cov8" title="1">
                return t.decodeBranchNode(hash, vals)</span>
        case 2:<span class="cov8" title="1">
                return t.decodeLeafNode(hash, vals)</span>
        case 3:<span class="cov8" title="1">
                return t.decodeExtensionNode(hash, vals)</span>
        default:<span class="cov0" title="0">
                return nil, nil</span>
        }
}

func (t *Trie) decodeLeafNode(hash, values []byte) (noder, error) <span class="cov8" title="1">{
        key, rest, err := rlp.SplitString(values)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">val, _, err := rlp.SplitString(rest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;LeafNode{
                Node: Node{
                        status: nodeStatusPersisted,
                        hash:   hash,
                },
                Key:   key,
                Value: val,
        }, nil</span>
}

func (t *Trie) decodeExtensionNode(hash, values []byte) (noder, error) <span class="cov8" title="1">{
        _, bufs, err := rlp.SplitString(values)
        key, rest, err := rlp.SplitString(bufs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">val, _, err := rlp.SplitString(rest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ExtensionNode{
                Node: Node{
                        status: nodeStatusPersisted,
                        hash:   hash,
                },
                Key:      key,
                NextNode: append(hashNode{}, val...),
        }, nil</span>
}

func (t *Trie) decodeBranchNode(hash, values []byte) (noder, error) <span class="cov8" title="1">{

        kind, elems, _, err := rlp.Split(values)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">itemcount, _ := rlp.CountValues(elems)
        if kind != rlp.List &amp;&amp; itemcount != numBranchChildren </span><span class="cov0" title="0">{
                return nil, errNodeFormat
        }</span>
        <span class="cov8" title="1">branchnode := &amp;BranchNode{
                Node: Node{
                        status: nodeStatusPersisted,
                        hash:   hash,
                },
        }
        for i := 0; i &lt; numBranchChildren; i++ </span><span class="cov8" title="1">{
                kind, val, rest, err := rlp.Split(elems)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">elems = rest
                if kind == rlp.String </span><span class="cov8" title="1">{
                        length := len(val)
                        if length == common.HashLength </span><span class="cov8" title="1">{
                                branchnode.Children[i] = append(hashNode{}, val...)
                        }</span><span class="cov8" title="1"> else {
                                branchnode.Children[i] = nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return branchnode, nil</span>
}

func (t *Trie) get(node noder, key []byte, pos int) (value []byte, newnode noder) <span class="cov8" title="1">{
        switch n := (node).(type) </span>{
        case nil:<span class="cov0" title="0">
                return nil, nil</span>
        case *ExtensionNode:<span class="cov8" title="1">
                if len(key)-pos &lt; len(n.Key) || !bytes.Equal(n.Key, key[pos:pos+len(n.Key)]) </span><span class="cov8" title="1">{
                        return nil, n
                }</span>
                <span class="cov8" title="1">val, newnode := t.get(n.NextNode, key, pos+len(n.Key))
                n.NextNode = newnode
                return val, n</span>
        case hashNode:<span class="cov8" title="1">
                child, err := t.loadNode(n)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, n
                }</span>
                <span class="cov8" title="1">val, _ := t.get(child, key, pos)
                return val, child</span>
        case *LeafNode:<span class="cov8" title="1">
                if len(key)-pos &lt; len(n.Key) || !bytes.Equal(n.Key, key[pos:pos+len(n.Key)]) </span><span class="cov8" title="1">{
                        // key not found in trie
                        return nil, n
                }</span>
                <span class="cov8" title="1">return n.Value, n</span>
        case *BranchNode:<span class="cov8" title="1">
                val, newnode := t.get(n.Children[key[pos]], key, pos+1)
                n.Children[key[pos]] = newnode
                return val, n</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("invalid node: %v", node))</span>
        }
}

func keybytesToHex(str []byte) []byte <span class="cov8" title="1">{
        l := len(str)*2 + 1
        var nibbles = make([]byte, l)
        for i, b := range str </span><span class="cov8" title="1">{
                nibbles[i*2] = b / byte(numBranchChildren-1)   // now is b / 16
                nibbles[i*2+1] = b % byte(numBranchChildren-1) // now is b% 16
        }</span>
        <span class="cov8" title="1">nibbles[l-1] = byte(numBranchChildren - 1) // term key is 16
        return nibbles</span>
}

func matchkeyLen(a, b []byte) int <span class="cov8" title="1">{
        length := len(a)
        lengthb := len(b)
        if lengthb &lt; length </span><span class="cov8" title="1">{
                length = lengthb
        }</span>
        <span class="cov8" title="1">var i = 0
        for ; i &lt; length; i++ </span><span class="cov8" title="1">{
                if a[i] != b[i] </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return i</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
